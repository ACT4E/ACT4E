% !TEX root = ../ACT4E-full.tex

\section{Co-Design Problems}
\label{sec:Design-Problems}

We start by defining
a ``design problem with implementation'', which is a tuple of ``\Fcol{functionality}
space'', ``\Icol{implementation} space'', and ``\Rcol{resources}
space'', together with two maps that describe the feasibility relations
between these three spaces~(\cref{fig:setup}).
\begin{definition}
  \label{def:DPI}A \emph{design problem with implementation}
  (DPI) is a tuple
  \begin{equation}
    \tup{\F{F},\R{R},\Icol{I},\prov,\req}
  \end{equation}
  where:

  \begin{itemize}
    \item $\funsp$ is a poset, called \emph{\Fcol{functionality} space};
    \item $\ressp$ is a poset, called \emph{\Rcol{requirements} space};
    \item $\impsp$ is a set, called \emph{\Icol{implementation} space};
    \item the map~$\prov\colon\impsp\rightarrow\funsp$
    maps an implementation to the functionality it provides;
    \item the map~$\req\colon\impsp\rightarrow\ressp$
    maps an implementation to the resources it requires.
  \end{itemize}

  \begin{figure}[h]
    \begin{center}
      \includegraphics[scale=0.4]{gmcdp_setup.pdf}
    \end{center}
    \caption{\label{fig:setup}}
  \end{figure}
  \todo{Redo figure with consistent style, change resources to requirements,
  eval/exec to requires/provides.}
\end{definition}


A graphical notation will help reasoning about composition. A DPI is represented as a box with~$\dpinumf$ green edges and~$\dpinumr$ red edges~(\cref{fig:dp_graphical}).

\begin{figure}[h]
  \centering
  \includegraphics[scale=0.4]{gmcdp_dp_graphical.pdf}
  \caption{\label{fig:dp_graphical}}
\end{figure}
\todo{Redo figure with consistent style.}
%\captionsideleft{\label{fig:dp_graphical}}{\includegraphics[scale=0.33]{gmcdp_dp_graphical.pdf}}

\noindent This means that the functionality and resources spaces
can be factorized in~$\dpinumf$ and~$\dpinumr$ components: $\funsp=\prod_{i=1}^{\dpinumf}\pi_{i}\funsp_{i},$
$\ressp=\prod_{j=1}^{\dpinumr}\pi_{j}\ressp$, where ``$\pi_{i}$''
represents the projection to the $i$-th component. If there are no
green (respectively, red) edges, then $\dpinumf$ (respectively, $\dpinumr$)
is zero, and $\funsp$ (respectively, $\ressp$) is equal to~$\One=\{\left\langle \right\rangle \}$,
the set containing one element, the empty tuple~$\left\langle \right\rangle $.

These \emph{co-design diagrams} are not to be confused with signal
flow diagrams, in which the boxes represent oriented systems and the
edges represent signals.


\begin{example}[Motor design]
  \label{exa:motor}Suppose we need to choose a motor for a robot from
  a given set. The \emph{functionality} of a motor could be parametrized
  by \F{torque} and \F{speed}. The \emph{resources} to consider
  could include the \R{cost {[}\${]}}, the \R{mass {[}g{]}}, the
  input \R{voltage {[}V{]}}, and the input \R{current {[}A{]}}.
  The map~$\prov:\impsp\rightarrow\funsp$ assigns to each motor its
  functionality, and the map~$\req:\impsp\rightarrow\ressp$ assigns
  to each motor the resources it needs~(\cref{fig:motor}).
\end{example}

\begin{figure}[h]
  \centering
  \includegraphics[scale=0.4]{gmcdp_motor_evalexec}
  \caption{\label{fig:motor_evalexec}}
\end{figure}
\todo{Redo figure with consistent style}
%\captionsideleft{\label{fig:motor_evalexec}}{\includegraphics[scale=0.33]{gmcdp_motor_evalexec}}


\begin{example}[Chassis design]
  \label{exa:chassis}Suppose we need to choose a chassis for a robot~(\cref{fig:gmcdp_chassis_eval}).
  The implementation space~$\impsp$ could be the set of all chassis
  that could ever be designed (in case of a theoretical analysis), or
  just the set of chassis available in the catalogue at hand (in case
  of a practical design decision). The functionality of a chassis could
  be formalized as ``the ability to transport a certain \F{payload
      {[}g{]}}'' and ``at a given \F{speed {[}m/s{]}}''. More refined
  functional requirements would include maneuverability, the cargo volume,
  etc. The resources to consider could be the \R{cost {[}\${]}} of
  the chassis; the total mass; and, for each motor to be placed in the
  chassis, the required \R{speed {[}rad/s{]}} and \R{torque {[}Nm{]}}.
\end{example}
\begin{figure}[h]
  \centering
  \includegraphics[scale=0.4]{gmcdp_chassis_eval.pdf}
  \caption{\label{fig:gmcdp_chassis_eval}}
\end{figure}
\todo{Redo figure with consistent style}
%\captionsideleft{\label{fig:gmcdp_chassis_eval}}{\includegraphics[scale=0.33]{gmcdp_chassis_eval.pdf}}

\subsection{Mechatronics}

% $A^{\op} \profto B \to \Set$

Many mechanisms can be readily modeled as relations between a provided
functionality and required resources.


\begin{example}
  The \F{functionality} of a DC motor~(\cref{fig:dc_motor})
  is to provide a certain \F{speed} and \F{torque}, and the \R{resources}
  are \R{current} and \R{voltage}.
\end{example}

\begin{figure}[h]
  \begin{center}
    \includesag{520_dc_motor}
  \end{center}
  \caption{\label{fig:dc_motor}}
\end{figure}


\begin{example}
  A gearbox (\cref{fig:gearbox}) provides a certain \F{output
  torque $\tau_o$} and \F{speed $\tau_o$}, given a certain
  \R{input torque $\tau_i$} and \R{speed $\omega_i$}. For
  an ideal gearbox with a reduction ratio $r \in \mathbb{Q}_+$ and
  efficiency ratio $\gamma$, $0<\gamma<1$, the constraints among
  those quantities are ${\colR \omega_i}\geq r\,{\colF \omega_o}$
  and ${\colR \tau_i\omega_i}\geq\gamma\,{\colF \tau_o\omega_o}.$
\end{example}

\begin{figure}[h]
  \begin{center}
    \includesag{520_dp_gearbox}
  \end{center}
  \caption{\label{fig:gearbox}}
\end{figure}


\begin{example}
  \emph{Propellers}~(\cref{fig:propeller}) generate \F{thrust}
  given a certain \R{torque} and \R{speed}.
\end{example}

\begin{figure}[h]
  \begin{center}
\includesag{520_dp_propellers}
  \end{center}
  \caption{\label{fig:propeller}}
\end{figure}

\begin{example}
  A \emph{crank-rocker} (\figref{crack}) converts \R{rotational
  motion} into a \F{rocking motion}.
\end{example}

\begin{figure}[h]
  \centering
  \includesag{520_crank}
  \caption{\label{fig:crack}}
\end{figure}

\subsection{Geometrical constraints}

Geometrical constraints are examples of constraints that are easily
recognized as monotone, but possibly hard to write down in closed
form.

\begin{example}[Bin packing]
  Suppose that each internal component occupies a volume
  bounded by a parallelepiped, and that we must choose the minimal enclosure
  in which to place all components~(\figref{packing}). What
  is the minimal size of the enclosure? This is a variation of the \emph{bin
  packing} problem, which is in NP for both 2D and 3D~\cite{lodi02two}.
  It is easy to see that the problem is monotone, by noticing that,
  if one the components shapes increases, then the size of the enclosure
  cannot shrink.
\end{example}

\begin{figure}[h]
  \centering
  \includegraphics[scale=0.33]{reits2_fit_boxes}
  \caption{\label{fig:packing}}
\end{figure}
\todo{Add pics as res/fun}

\subsection{Inference}

Many inference problems have a monotone formalization, taking the
\F{accuracy} or \F{robustness} as functionality, and \R{computation}
or \R{sensing} as resources. Typically these bounds are known in
a closed form only for restricted classes of systems, such as the
linear/Gaussian setting.

\begin{example}
  (SLAM) One issue with particle-filter-based estimation procedures,
  such as the ones used in the popular GMapping~\cite{grisetti07improved}
  method, is that the filter might diverge if there aren't enough particles.
  Although the relation might be hard to characterize, there is a monotone
  relation between the \F{robustness} (1 - probability of failure),
  the \F{accuracy}, and the \R{number of particles}~(\figref{gmapping}).
\end{example}

\begin{figure}[h]
  \centering
  \includesag{520_mapping}
  \caption{\label{fig:gmapping} }
\end{figure}



\begin{example}
  (Stereo reconstruction) Progressive reconstruction system (e.g.,~\cite{locher16progressive}),
  which start with a coarse approximation of the solution that is progressively
  refined, are described by a smooth relation between the \F{resolution}
  and the \R{latency} to obtain the answer~(\figref{progressive}).
  A similar relation characterizes any anytime algorithms in other domains,
  such as robot motion planning.
\end{example}


\begin{figure}[h]
  \centering
  \includesag{520_stereo}
  \caption{\label{fig:progressive}}
\end{figure}


\begin{example}
  The empirical characterization of the monotone relation between \F{the
  accuracy of a visual SLAM solution} and \R{the power consumption}
  is the goal of recent work by Davison and colleagues~\cite{nardi15introducing,zia16comparative}.
\end{example}

\todo{Reproduce plot from paper.}

\subsection{Communication}

\begin{example}[Transducers]
  Any type of "transducer" that bridges between different
  mediums can be modeled as a DP. For example, an access point~(\figref{accesspoint})
  provides the \F{"wireless access"} functionality, and requires
  that the infrastructure provides the \R{"Ethernet access"} resource.
\end{example}


\begin{figure}[h]
  \centering
  \includesag{520_ethernet}
  \caption{\label{fig:accesspoint}}
\end{figure}

\begin{example}[Wireless link]
  The basic functionality of a wireless link is to provide
  a certain \F{bandwidth}. Further refinements could include bounds
  on the latency or the probability that a packet drop is dropped. Given
  the established convention about the the preference relations for
  functionality, in which a \emph{lower} functionality is "easier"
  to achieve, one needs to choose "\F{\emph{minus} the latency}"
  and "\F{\emph{minus} the packet drop probability}" for them
  to count as functionality. As for the resources, apart from the \R{transmission
  power [W]}, one should consider at least \R{the spectrum occupation},
  which could be described as an interval $[f_0,f_1]$ of the frequency
  axis $\Runit{Hz}$. Thus the resources space is $\ressp=\colR\Runit{W}Ã—\vmath{intervals}(\Runit{Hz})$.
\end{example}

\begin{figure}[h]
  \begin{center}
    \includesag{520_dp_wireless}
  \end{center}
  \caption{ \label{fig:networklink}}
\end{figure}

\subsection{Multi-robot systems}

In a multi-robot system there is always a trade-off between the number
of robots and the capabilities of the single robot.
\begin{example}
  Suppose we need to create a swarm of agents whose functionality is
  \F{to sweep an area}. If the functionality is fixed, one expects
  a three-way trade-off between the three resources: number of agents,
  the speed of a single agent, and the execution time. For example,
  if the time available decreases, one has to increase either the speed
  of an agent or the number of agents~(\figref{multirobot2}).
\end{example}

\begin{figure}[h]
  \subfloat[]{
    \includegraphics[scale=0.33]{reits2_multirobot}

  }\subfloat[\label{fig:multirobot2}]{
    \includegraphics[scale=0.33]{reits2_multirobot2}

  }\caption{}
\end{figure}

\subsection{LQG Control}

\todo[inline]{Write short summary}

\subsection{Computation}


The trivial model of a CPU is as a device that provides \Fcol{computation,
measured in flops}, and requires \Rcol{power [W]}. Clearly there
is a monotone relation between the two.

\begin{figure}[h]
  \begin{center}
    \includesag{520_dp_cpu}
  \end{center}
  \caption{}
\end{figure}

A similar monotone relation between application requirements and computation
resources holds in a much more general setting, where both application
and computation resources are represented by graphs. This will be
an example of a monotone relation between nontrivial partial orders.

In the Static Data Flow (SDF) model of computation~\cite[Chapter 3]{sriram00,lee10},
the application is represented as a graph of procedures that need
to be allocated on a network of processors.

\todo{Make the three small wrapped figures as 3 subfigures in the same figures}
% keep wrapped
\begin{wrapfigure}{r}{0\columnwidth}
  \includegraphics[scale=0.33]{reits2_small_app_graph}
\end{wrapfigure}

Define the\emph{ application graph }(sometimes called "computation
graph") as a graph where each node is a procedure (or "actor")
and each edge is a message that needs to be passed between procedures.
Each node is labeled by the number of ops necessary to run the procedure.
Each edge is labeled by the size of the message. There is a partial
order $ \leq$ on application graphs. In this order, it holds that $A_1 \leq A_2$
if the application graph $A_2$ needs more computation or bandwidth
for its execution than $A_1$. Formally, it holds that $A_1 \leq A_2$
if there is a homomorphism $\varphi:A_1  \Rightarrow A_2$; and,
for each node $n \in A_1$, the node $\varphi(n)$ has equal or
larger computational requirements than $n$; and for each edge $âŸ¨n_1,n_2âŸ© $
in $A_2$, the edge $âŸ¨\varphi(n_1),\varphi(n_2)âŸ© $
has equal or larger message size.

\begin{wrapfigure}{r}{0\columnwidth}
  \includegraphics[scale=0.33]{reits2_small_res_graph}
\end{wrapfigure}

Define a\emph{ resource graph} as a graph where each node represents
a processor, and each edge represents a network link. Each node is
labeled by the processor capacity [flops] Each edge is labeled
by latency [s] and bandwidth [B/s]. There is a partial order
on resources graph as well: it holds that $R_1 \leq R_2$ if
the resource graph $R_2$ has more computation or network available
than $R_1$. The definition is similar to the case of the application
graph: there must exist a graph homomorphism $\varphi : R_1  \Rightarrow R_2$
and the corresponding nodes (edges) of $R_2$ must have larger
or equal computation (bandwidth) than those of $R_1$.

\begin{wrapfigure}{r}{0\columnwidth}
  \includegraphics[scale=0.33]{reits2_small_allocation}
\end{wrapfigure}

Given an application graph $A$ and a resource graph $R$, a typical
resource allocation problem consists in choosing in which processor
each actor must be scheduled to maximize the throughput $T$~[Hz].
This is equivalent to the problem of finding a graph homomorphism $\Psi : A \Rightarrow R$.
Let $T^{\ast}$ be the optimal throughput, and write it as a function
of the two graphs:
\[
  T^{\ast}=T^{\ast}(A,R).
\]
Then the optimal throughput $T^{*}$ is decreasing in $A$ (a more
computationally demanding application graph decreases the throughput)
and increasing in $R$ (more available computation/bandwidth increase
the throughput).

Therefore, we can formalize this as a design problem where the two
functionalities are \F{the throughput $T$ [Hz]} and \F{the
application graph $A$}, and the \R{resource graph $R$} is the
resource.

\begin{figure}

  \includegraphics[scale=0.33]{reits2_resourcegraph1}

  \caption{}
\end{figure}



\begin{example}
  Svorenova\,\,\etal~\cite{svorenova16resource} consider a joint
  sensor scheduling and control synthesis problem, in which a robot
  can decide to not perform sensing to save power, given performance
  objectives on the probability of reaching the target and the probability
  of collision. The method outputs a Pareto frontier of all possible
  operating points. This can be cast as a design problem with functionality
  equal to the \F{probability of reaching the target} and (the inverse
  of) \F{the collision probability}, and with resources equal to the
  \R{actuation power}, \R{sensing power}, and \R{sensor accuracy}.

\end{example}

\begin{figure}[h]
  \centering
  \includegraphics[scale=0.33]{batteries_svorenova.pdf}
  \caption{\label{fig:progressive-1-1}}
\end{figure}
%\captionsideleft{\label{fig:progressive-1-1}}{\includegraphics[scale=0.33]{batteries_svorenova.pdf}}


\begin{example}
  Nardi\,\,\etal~\cite{zia16comparative} describe a benchmarking
  system for visual SLAM that provides the empirical characterization
  of the monotone relation between \F{the accuracy} of the visual
  SLAM solution, the \F{throughput {[}frames/s{]}} and \R{the energy
  for computation {[}J/frame{]}}. The implementation space is the product
  of algorithmic parameters, compiler flags, and architecture choices,
  such as the number of GPU cores active. This is an example of a design
  problem whose functionality-resources map needs to be experimentally
  evaluated.
\end{example}

\begin{figure}[h]
  \centering
  \includegraphics[scale=0.33]{batteries_zia.pdf}
  \caption{}
\end{figure}

%\captionsideleft{}{\includegraphics[scale=0.33]{batteries_zia.pdf}}

\subsection{Other examples in minimal robotics}

Many works have sought to find ``minimal'' designs for robots, and
can be understood as characterizing the relation between the poset
of \F{tasks} and the poset of physical resources, which is the product
of \R{sensing}, \R{actuation}, and \R{computation} resources,
plus other non-physical resources, such as \R{prior knowledge}~(\cref{fig:robot-generic}).
Given a task, there is a minimal antichain in the resources poset
that describes the possible trade-offs (e.g., compensating lousier
sensors with more computation).

\begin{figure}
  \centering
  \includegraphics[scale=0.33]{batteries_okane.pdf}
  \caption{\label{fig:robot-generic}}
\end{figure}

%\captionsideleft{\label{fig:robot-generic}}{\includegraphics[scale=0.33]{batteries_okane.pdf}}

The poset structure arises naturally: for example, in the \emph{sensor
lattice}~\cite{lavalle12sensing}, a sensor dominates another
if it induces a finer partition of the state space. Similar dominance
relations can be defined for actuation and computation. O'Kane and
Lavalle~\cite{okane08comparing} define a robot as a union of ``robotic
primitives'', where each primitive is an abstraction for a set of
sensors, actuators, and control strategies that can be used together
(e.g., a compass plus a contact sensor allow to ``drive North until
a wall is hit''). The effect of each primitive is modeled as an operator
on the robot's information space. It is possible to work out what
are the minimal combinations of robotic primitives (minimal antichain)
that are sufficient to perform a task (e.g., global localization),
and describe a dominance relation (partial order) of primitives. Other
works have focused on minimizing the complexity of the controller.
Egerstedt~\cite{egerstedt03motion} studies the relation between
the \F{complexity of the environment} and a notion of \R{minimum
description length of control strategies}, which can be taken as
a proxy for the computation necessary to perform the task. Soatto~\cite{soatto11steps}
studies the relation between the \F{performance of a visual task},
and the \R{minimal representation} that is needed to perform that
task.



\begin{example}[Hoare logic]
  \todo{to write}
\end{example}

\section{Querying a DPI}

A DP is a model that induces a family of optimization problems.

\todo{Connect with discussion at beginning of the part.}

One query is
``Given a lower bound on the functionality~\fun, what
are the implementations that have minimal resources usage?''~(\cref{fig:setup-1}).

\begin{problem}[FixFunMinReq]
  \label{prob:problem1}Given~$\fun\in\funsp$, find the implementations
  in~$\impsp$ that realize the functionality~\fun (or higher)
  with minimal resources, or provide a proof that there are none:
  \begin{equation}
    \begin{cases}
      \with & \imp\in\impsp,\\
      \Min_{\resleq} & \res,\\
      \subto & \res=\req(\imp),\\
      & \fun\funleq\prov(\imp).
    \end{cases}\label{eq:objective}
  \end{equation}
\end{problem}
\captionsideleft{\label{fig:setup-1}}{\includegraphics[scale=0.33]{gmcdp_setup_query_f.pdf}}


\begin{remark}[Minimal \emph{vs} least solutions]
  Note the use of~``$\Min_{\resleq}$'' in~(\ref{eq:objective}),
  which indicates the set of minimal (non-dominated) elements according
  to~$\resleq$, rather than~``$\min_{\resleq}$'', which would
  presume the existence of a least element. In all problems in this
  paper, the goal is to find the optimal trade-off of resources (``Pareto
  front''). So, for each~\fun, we expect to find an antichain~${\colR R}\in\Aressp$.
  We will see that this formalization allows an elegant way to treat
  multi-objective optimization. The algorithm to be developed will directly
  solve for the set~${\colR R}$, without resorting to techniques such
  as \emph{scalarization}, and therefore is able to work with arbitrary
  posets, possibly discrete.
\end{remark}


In an entirely symmetric fashion, we could fix an upper bound on
the resources usage, and then maximize the functionality provided~(\cref{fig:setup_max_f}).
The formulation is entirely dual, in the sense that it is obtained
from \eqref{objective} by swapping~$\Min$ with~$\Max$, $\funsp$~with~$\ressp$,
and $\prov$~with~$\req$.

\begin{problem}[FixResMinFun]
  Given~$\res\in\ressp$, find the implementations
  in~$\impsp$ that requires~\res (or lower)
  and provide the maximal functionality, or provide a proof that there are none:
  \begin{equation}
    \begin{cases}
      \with & \imp\in\impsp,\\
      \Max_{\funleq} & \fun,\\
      \subto & \fun=\prov(\imp),\\
      & \res\posgeq_{\ressp}\req(\imp).
    \end{cases}\label{eq:objective-1}
  \end{equation}
\end{problem}

\captionsideleft{\label{fig:setup_max_f}}{\includegraphics[scale=0.4]{gmcdp_setup_query_r.pdf}}

\section{Co-design problems\label{sec:Co-design-problems}}

A ``co-design problem'' will be defined as a multigraph of design
problems. Graphically, one is allowed to connect only edges of different
color, and of the same type. This interconnection is indicated with the symbol~``$\posleq$''
in a rounded box~(\cref{fig:connection}).

\begin{figure}[h]
  \centering
  \includegraphics[scale=0.33]{unc_connection.pdf}
  \caption{\label{fig:connection}}
\end{figure}

%\captionsideleft{\label{fig:connection}}{\includegraphics[scale=0.33]{papers/uncertainty/unc_connection.pdf}}

\noindent The semantics of the interconnection is that the resources
required by the first DPI are provided by the second DPI. This is
a partial order inequality constraint of the type~$\res_{1}\posleq\fun_{2}$.

\begin{definition}
  \label{def:cdpi}A \emph{Co-Design Problem with Implementation} (CDPI)
  is a tuple $\left\langle \funsp,\ressp,\left\langle \cdpiN,\mathcal{E}\right\rangle \right\rangle ,$
  where~$\funsp$ and~$\ressp$ are two posets, and~$\left\langle \cdpiN,\mathcal{E}\right\rangle $
  is a\emph{ }multigraph of DPIs. Each node~$\cdpin\in\cdpiN$ is a
  DPI $\cdpin=\left\langle \funsp_{\cdpin},\ressp_{\cdpin},\impsp_{\cdpin},\prov_{\cdpin},\req_{\cdpin}\right\rangle .$
  An edge~$e\in\mathcal{E}$ is a tuple $e=\left\langle \left\langle \cdpinA,\cdpiresindA\right\rangle ,\left\langle \cdpinB,\cdpifunindB\right\rangle \right\rangle $,
  where~$\cdpinA,\cdpinB\in\cdpiN$ are two nodes and~$\cdpiresindA$
  and~$\cdpifunindB$ are the indices of the components of the functionality
  and resources to be connected, and it holds that~$\pi_{\cdpiresindA}\ressp_{\cdpinA}=\pi_{\cdpifunindB}\funsp_{\cdpinB}$~(\cref{fig:mcdps}).

  \begin{figure}[h]
    \centering
    \includegraphics[scale=0.33]{gmcdptro_cdpi.pdf}
    \caption{\label{fig:mcdps}}
  \end{figure}


\end{definition}

A CDPI is equivalent to a DPI with an implementation space~$\impsp$
that is a subset of the product $\prod_{\cdpin\in\cdpiN}\impsp_{\cdpin}$,
and contains only the tuples that satisfy the co-design constraints.
An implementation tuple~$\imp\in\prod_{\cdpin\in\cdpiN}\impsp_{\cdpin}$
belongs to~$\impsp$ iff it respects all functionality\textendash resources
constraints on the edges, in the sense that, for all edges~$\left\langle \left\langle \cdpinA,\cdpiresindA\right\rangle ,\left\langle \cdpinB,\cdpifunindB\right\rangle \right\rangle $
in~$\mathcal{E}$, it holds that
\[
  \pi_{\cdpiresindA}\req_{\cdpinA}(\pi_{\cdpinA}\imp)\posleq\pi_{\cdpifunindB}\prov_{\cdpinB}(\pi_{\cdpinB}\imp).
\]
The posets~$\funsp,\ressp$ for the entire CDPI are the products
of the functionality and resources of the nodes that remain unconnected.
For a node~$\cdpin$, let~$\unconnectedfun_{\cdpin}$ and~$\unconnectedres_{\cdpin}$
be the set of unconnected functionalities and resources. Then~$\funsp$
and~$\ressp$ for the CDPI are defined as the product of the unconnected
functionality and resources of all DPIs: $\funsp=\prod_{\cdpin\in\cdpiN}\prod_{\cdpifunind\in\unconnectedfun_{\cdpin}}\pi_{\cdpifunind}\funsp_{\cdpin}$
and $\ressp=\prod_{\cdpin\in\cdpiN}\prod_{\cdpiresind\in\unconnectedres_{\cdpin}}\pi_{\cdpiresind}\ressp_{\cdpin}.$
The maps $\prov,\req$ return the values of the unconnected functionality
and resources:
\begin{align*}
  \prov:\imp & \mapsto{\scriptstyle {\displaystyle \prod_{\cdpin\in\cdpiN}\prod_{\cdpifunind\in\unconnectedfun_{\cdpin}}}}\pi_{\cdpifunind}\prov_{\cdpin}(\pi_{\cdpin}\imp),\\
  \req:\imp & \mapsto{\displaystyle \prod_{\cdpin\in\cdpiN}\prod_{\cdpiresind\in\unconnectedres_{\cdpin}}}\pi_{\cdpiresind}\req_{\cdpin}(\pi_{\cdpin}\imp).
\end{align*}

\begin{example}
  \label{exa:chassis_plus_motor}Consider the co-design of chassis (\cref{exa:chassis})
  plus motor (\cref{exa:motor}). The design problem for a motor has \F{speed}
  and \F{torque} as the provided functionality (what the motor must
  provide), and \R{cost}, \R{mass}, \R{voltage}, and \R{current}
  as the required resources~(\cref{fig:motor}).

  \begin{figure}[h]
    \centering
    \includegraphics[scale=0.5]{gmcdp_motor.pdf}
    \label{fig:motor}
  \end{figure}

%\captionsideleft{\label{fig:motor}}{\includegraphics[scale=0.33]{gmcdp_motor.pdf}}

  \noindent For the chassis (\cref{fig:gmcdp_chassis}), the provided
  functionality is parameterized by the \F{mass} of the payload and
  the platform \F{velocity}. The required resources include the \R{cost},
  \R{total mass}, and what the chassis needs from its motor(s), such
  as \R{speed} and \R{torque}.

  \begin{figure}[h]
    \centering
    \includegraphics[scale=0.5]{gmcdp_chassis.pdf}
    \caption{\label{fig:gmcdp_chassis}}
  \end{figure}

%\captionsideleft{\label{fig:gmcdp_chassis}}{\includegraphics[scale=0.33]{gmcdp_chassis.pdf}}

  \noindent The two design problem can be connected at the edges for
  torque and speed~(\cref{fig:gmcdp_chassis_plus_motor_series}). The
  semantics is that the motor needs to have\emph{ at least }the given
  torque and speed.

  \begin{figure}[h]
    \centering
    \includegraphics[scale=0.33]{gmcdp_chassis_plus_motor_series.pdf}
    \caption{\label{fig:gmcdp_chassis_plus_motor_series}}
  \end{figure}

%\captionsideleft{\label{fig:gmcdp_chassis_plus_motor_series}}{\includegraphics[scale=0.33]{gmcdp_chassis_plus_motor_series.pdf}}

  \noindent Resources can be summed together using a trivial DP corresponding
  to the map $\ftor:\left\langle \fun_{1},\fun_{2}\right\rangle \mapsto\{\fun_{1}+\fun_{2}\}$
  (\cref{fig:total_cost}).

  \begin{figure}[h]
    \centering
    \includegraphics[scale=0.33]{gmcdp_weightsum.pdf}
    \caption{\label{fig:total_cost}}
  \end{figure}

%\captionsideleft{\label{fig:total_cost}}{\includegraphics[scale=0.33]{gmcdp_weightsum.pdf}}

  \noindent A co-design problem might contain recursive co-design constraints.
  For example, if we set the payload to be transported to be the sum
  of the motor mass plus some extra payload, a cycle appears in the
  graph~(\cref{fig:gmcdp_chassis_plus_motor}).


  \begin{figure}[h]
    \centering{}\includegraphics[scale=0.33]{gmcdp_chassis_plus_motor.pdf}
    \caption{\label{fig:gmcdp_chassis_plus_motor}}
  \end{figure}

  This formalism makes it easy to abstract away the details
  in which we are not interested. Once a diagram like~\cref{fig:gmcdp_chassis_plus_motor}
  is obtained, we can draw a box around it and consider the abstracted
  problem~(\cref{fig:gmcdp_chassis_plus_motor-1}).

  \begin{figure}[h]
    \centering
    \includegraphics[scale=0.33]{gmcdp_chassis_plus_motor2.pdf}
    \caption{\label{fig:gmcdp_chassis_plus_motor-1}}
  \end{figure}

%\captionsideleft{\label{fig:gmcdp_chassis_plus_motor-1}}{\includegraphics[scale=0.33]{gmcdp_chassis_plus_motor2.pdf}}

  \label{exa:finish}Let us finish assembling our robot. A motor needs
  a motor control board. The functional requirements are the (peak)
  \F{output current} and the \F{output voltage range}~(\cref{fig:mcb}).

  \begin{figure}[h]
    \centering
    \includegraphics[scale=0.5]{gmcdp_mcb.pdf}
    \caption{\label{fig:mcb}}
  \end{figure}

%\captionsideleft{\label{fig:mcb}}{\includegraphics[scale=0.33]{gmcdp_mcb.pdf}}

  \noindent The functionality for a power supply could be parameterized
  by the \F{output current}, the \F{output voltages}, and the \F{capacity}.
  The resources could include \R{cost} and \R{mass} (\cref{fig:example-ba}).

  \begin{figure}[h]
    \centering
    \includegraphics[scale=0.33]{gmcdp_battery.pdf}
    \caption{\label{fig:example-ba}}
  \end{figure}

%\captionsideleft{\label{fig:example-ba}}{\includegraphics[scale=0.33]{gmcdp_battery.pdf}}

  Relations such as ${\colF\mbox{current}}\times{\colF\mbox{voltage}}\leq{\colR\mbox{power required}}$
  and ${\colF\mbox{power}}\times{\colF\mbox{endurance}}\leq{\colR\mbox{energy required}}$
  can be modeled by a trivial ``multiplication'' DPI (\cref{fig:current_times_voltage}).

  \begin{figure}[h]
    \centering
    \includegraphics[scale=0.33]{gmcdp_voltage_current.pdf}
    \caption{\label{fig:current_times_voltage}}
  \end{figure}

%\captionsideleft{\label{fig:current_times_voltage}}{\includegraphics[scale=0.33]{gmcdp_voltage_current.pdf}}

  We can connect these DPs to obtain a co-design problem with
  functionality \F{voltage}, \F{current}, \F{endurance} and resources
  \R{mass} and \R{cost}~(\cref{fig:connect}).

  \begin{figure}[h]
    \centering
    \includegraphics[scale=0.29]{gmcdp_MCB_PSU_2.pdf}
    \caption{\label{fig:connect}}
  \end{figure}

%\captionsideleft{\label{fig:connect}}{\includegraphics[scale=0.29]{gmcdp_MCB_PSU_2.pdf}}

  Draw a box around the diagram, and call it ``MCB+PSU'';
  then interconnect it with the ``chassis+motor'' diagram in~\cref{fig:another}.


  \begin{figure}[h]
    \begin{centering}
      \includegraphics[scale=0.33]{gmcdp_mobility_power.pdf}
      \par
    \end{centering}
    \caption{\label{fig:another}}
  \end{figure}

  We can further abstract away the diagram in~\cref{fig:another} as
  a ``mobility+power'' CDPI, as in \cref{fig:shipping}. The formalism
  allows to consider \R{mass} and \R{cost} as independent resources,
  meaning that we wish to obtain the Pareto frontier for the minimal
  resources. Of course, one can always reduce everything to a scalar
  objective. For example, a conversion from mass to cost exists and
  it is called ``shipping''. Depending on the destination, the conversion
  factor is between~$\$0.5/\mbox{lbs}$, using USPS, to~$\$10\mbox{k}/\mbox{lbs}$
  for sending your robot to low Earth orbit.


  \begin{figure}[h]
    \centering{}\includegraphics[scale=0.33]{gmcdp_shipping.pdf}\caption{\label{fig:shipping}}
  \end{figure}

\end{example}

\section{Discussion of related work\label{sec:Discussion-of-related}}

\subsection{Theory of design}

Modern engineering has long since recognized the two ideas of modularity
and hierarchical decomposition, yet there exists no general quantitative
theory of design that is applicable to different domains. Most of
the works in the theory of design literature study abstractions that
are meant to be useful for a human designer, rather than an automated
system. For example, a \emph{function structure }diagram~\cite[p. 32]{pahl07}
decomposes the function of a system in subsystems that exchange energy,
materials, and signals, but it is not a formal representation. From
the point of view of the theory of design, the contribution of this
work is that the \emph{design problem }abstraction developed, where
one takes functionality and resources as the interfaces for the subsystems,
is at the same time (1) mathematically precise; (2)~intuitive to
understand; and (3)~leads to tractable optimization problems.

This work also provides a clear answer to one long-standing issue
in the theory of design: the inter-dependence between subsystems,
(i.e., cycles in the co-design graph). Consider, as an example, Suh's
theory of \emph{axiomatic design~}\cite{suh01}, in which the first
``axiom'' is to keep the design requirements orthogonal (i.e., do
not introduce cycles). This work shows that it is possible to deal
elegantly with recursive constraints.

\subsection{Partial Order Programming}

In ``Partial Order Programming''~\cite{parkerjr89partial} Parker
studies a hierarchy of optimization problems that can be represented
as a set of partial order constraints. The main interest is to study
partial order constraints as the means to define the semantics of
programming languages and for declarative approaches to knowledge
representation.

In Parker's hierarchy, MCDPs are most related to the class of problems
called \emph{continuous monotone partial order program} (CMPOP). CMPOPs
are the least specific class of problems studied by Parker for which
it is possible to obtain existence results and a systematic solution
procedure. MCDPs subsume CMPOPs. A CMPOP is an MCDP where: 1)~All
functionality and resources belong to the same poset~$\posA$ ($\funsp_{v}=\ressp_{v}=\posA$);
2)~Each functionality/resource relation is a simple map, rather than
a multi-valued relation; 3)~There are no dangling functionality edges
in the co-design diagram ($\funsp=\One$).

In a MCDP, each DP is described by a \scottcontinuous map~$\ftor:\funsp\rightarrow\Aressp$
which maps one functionality to a minimal set of resources. By contrast,
in a CMPOP an operator corresponds to a \scottcontinuous map~$\ftor:\funsp\rightarrow\ressp$.
The consequence is that a CMPOP has a unique solution~\cite[Theorem 8]{parkerjr89partial},
while an MCDP can have multiple minimal solutions (or none at all).

\subsection{Abstract interpretation}

The methods used from order theory are the same used in the field
of \emph{abstract interpretation}~\cite{cousot14abstract}. In
that field, the least fixed point semantics arises from problems such
as computing the sets of reachable states. Given a starting state,
one is interested to find a subset of states that is closed under
the dynamics (i.e. a fixed point), and that is the smallest that contains
the given initial state (i.e. a \emph{least} fixed point). Reachability
and other properties lead to considering systems of equation of the
form
\begin{align}
  x_{i} & =\varphi_{i}(x_{1},\,\dots\,,x_{i},\,\dots\,,x_{n}),\quad i=1,\dots,n,\label{eq:ai}
\end{align}
where each value of the index $i$ is for a control point of the program,
and~$\varphi_{i}$ are \scottcontinuous functions on the abstract
lattice that represents the properties of the program. In the simplest
case, each~$x_{i}$ could represent intervals that a variable could
assume at step~$i$. By applying the iterations, one finds which
properties can be inferred to be valid at each step.

We can repeat the same considerations we did for Parker's CMPOPs vs
MCDPs. In particular, in MCDP we deal with multi-valued maps, and
there is more than one solution.

In the field of abstract interpretation much work has been done towards
optimizing the rate of convergence. The order of evaluation in~\eqref{ai}
does not matter. Asynchronous and ``chaotic'' iterations were proposed
early~\cite{cousot77asynchronous} and are still object of investigation~\cite{bourdoncleefficient}.
To speed up convergence, the so called ``widening'' and ``narrowing''
operators are used~\cite{cortesi11widening}. The ideas of chaotic
iteration, widening, narrowing, are not immediately applicable to
MCDPs, but it is a promising research direction.


