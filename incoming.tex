\part{Homework}
%\partfirstb{(short desc)}{placeholder}{(caption)}{long desc}


\chapter{Sets and relations}

We go on assuming that you have already completed the tutorial in \cref{sec:exercise-tutorial}.

\subsection{Properties}

\begin{gradedexercise}[\exname{TestFiniteSetProperties}]
  Given two finite sets, check if they are a subset of the other.
  Implement the following interface:
  \methodsource{FiniteSetProperties}{is_subset}{}
\end{gradedexercise}

Check your results with
\begin{console}
  > make check-TestFiniteSetProperties
\end{console}

\subsection{Union and intersection}


\begin{gradedexercise}[\exname{TestFiniteSetOperations}]
  Given two finite sets, compute the union and intersection.
  \classsource{FiniteSetOperations}{}
\end{gradedexercise}


Check your results with
\begin{console}
  > make check-TestFiniteSetOperations
\end{console}

\subsection{Product and disjoint union}

\AC{Checks not implemented for the next exercises.}
\begin{gradedexercise}
  Given two finite sets, compute the product and disjoint union.

  \classsource{FiniteSetOperations2}{}
\end{gradedexercise}
\begin{gradedexercise}
  Given two finite sets, compute the disjoint union.

\end{gradedexercise}


\section{Finite Relations}

\subsection*{Interface}

A finite relation \classname{FiniteRelation} ...

\classsource{FiniteRelation}{}

\subsection*{Representation}{}

The format is shown in \cref{fig:rel1}.

\datafilefig{rel11code}{rel1.finrel.yaml}{fig:rel1}

\begin{gradedexercise}[Loading finite relations]
  Create a function to load the data.


%
  \classsource{FiniteRelationRepresentation}{}

\end{gradedexercise}


%  \input{10_arrows/10_composition/10_topic1}

\begin{gradedexercise}[Relation properties]

  Check that an endorelation has the properties mentioned in \cref{sec:relations}.

  The
  \classsource{FiniteRelationProperties}{}

\end{gradedexercise}




\begin{gradedexercise}[Opposite]
  Compute the opposite relation.

  \methodsource{FiniteEndorelationOperations}{transitive_closure}{}

\end{gradedexercise}

\begin{gradedexercise}[Endorelation properties]

  Check that an endorelation has the properties mentioned in \cref{sec:endorelations}.

  The interfaces to implement:
  \classsource{FiniteEndorelationProperties}{}

\end{gradedexercise}

\begin{gradedexercise}[Transitive closure]
  Compute the transitive closure (\cref{def:transitive-closure}) of a relation.

  \methodsource{FiniteEndorelationOperations}{transitive_closure}{}

\end{gradedexercise}


\section{Finite Maps}

\subsection*{Interface}

A finite relation \classname{FiniteMap} ...

\classsource{FiniteMap}{}

\subsection*{Representation}

The format is shown in \cref{fig:map1}.
\datafilefig{map1}{map1.map.yaml}{fig:map1}


\begin{gradedexercise}[Representation]
  Create a function to load the data.


%
  \classsource{FiniteMapRepresentation}{}

\end{gradedexercise}

\subsection{Operations}


\begin{gradedexercise}[Composition]
  Implement the composition of finite maps.


%
  \methodsource{FiniteMapOperations}{compose}{}

\end{gradedexercise}


\begin{gradedexercise}[Obtain relation]
  Given a FiniteMap, obtain the relation.


%
  \methodsource{FiniteMapOperations}{as_relation}{}

\end{gradedexercise}


\chapter{Monoids and semigroups}


\section{Equational theories}

\todotext{Word problem or some such}


\chapter{Orders}


\section{Posets}


\begin{figure}
  \includesag{poset-finiteposet}

  \caption{}
  \label{fig:poset-finiteposet}
\end{figure}


\subsection*{Interface}

Here is the interface for posets:

%
\classsource{FinitePoset}{}

\subsection*{Representation}

\datafilefig{poset1}{poset1.poset.yaml}{fig:poset1}

\begin{gradedexercise}[Representation]
  Create a function to load the data.


%
  \classsource{FinitePosetRepresentation}{}

\end{gradedexercise}

\subsection{Properties}


\begin{gradedexercise}
  Compute the width of a poset.
  \methodsource{FinitePosetProperties}{width}{}
\end{gradedexercise}

\begin{gradedexercise}
  Compute the height of a poset.
  \methodsource{FinitePosetProperties}{height}{}
\end{gradedexercise}

\subsection{Operations}


\begin{gradedexercise}
  Given a poset, return the opposite.
  \methodsource{FinitePosetOperations}{opposite}{}
\end{gradedexercise}

\subsection{Properties of subsets}


\begin{gradedexercise}
  Check if a subset is a chain.
  \methodsource{FinitePosetSubsetProperties}{is_chain}{}
\end{gradedexercise}

\begin{gradedexercise}
  Check if a subset is an antichain.
  \methodsource{FinitePosetSubsetProperties}{is_antichain}{}
\end{gradedexercise}

\subsection{Operations on subsets of posets}

\begin{gradedexercise}
  Compute the upper closure of a subset.
  \methodsource{FinitePosetSubsetOperations}{upperclosure}{}

\end{gradedexercise}


\begin{gradedexercise}
  Compute the lower closure of a subset, reducing to
  using the function \funcname{upperclosure} that you
  already defined.
  \methodsource{FinitePosetSubsetOperations}{lowerclosure}{}

\end{gradedexercise}



\begin{gradedexercise}
  Compute the minimal elements of a subset.

  \methodsource{FinitePosetSubsetOperations}{minimal}{}

\end{gradedexercise}


\begin{gradedexercise}
  Compute the maximal elements of a subset, reducing
  to use the function \funcname{minimal} already defined.

  \methodsource{FinitePosetSubsetOperations}{maximal}{}

\end{gradedexercise}


\begin{gradedexercise}
  Compute the infimum/supremum/meet/join of a subset.
  In case one does not exist, return None.

  \methodsource{FinitePosetSubsetOperations}{infimum}{}
  \methodsource{FinitePosetSubsetOperations}{supremum}{}
  \methodsource{FinitePosetSubsetOperations}{meet}{}
  \methodsource{FinitePosetSubsetOperations}{join}{}

\end{gradedexercise}

\subsection{Lower/upper sets}
\begin{gradedexercise}
  Given a set, return the power set, a poset ordered by inclusion.

  \methodsource{FinitePosetConstructors}{powerset}{}
\end{gradedexercise}


\begin{gradedexercise}
  Given a poset, compute the interval poset.

  \methodsource{FinitePosetConstructors}{intervals}{}
\end{gradedexercise}


\begin{gradedexercise}
  Given a poset, compute the other interval poset.

  \methodsource{FinitePosetConstructors}{intervals2}{}
\end{gradedexercise}


\begin{gradedexercise}
  Given a poset, define the poset of upper sets.

  \methodsource{FinitePosetConstructors}{uppersets}{}
\end{gradedexercise}

\begin{gradedexercise}
  Given a poset, define the poset of lower sets.
  \methodsource{FinitePosetConstructors}{lowersets}{}
\end{gradedexercise}


\begin{gradedexercise}
  Given a set, construct the discrete poset.

  \methodsource{FinitePosetConstructors}{discrete}{}
\end{gradedexercise}


\begin{gradedexercise}
  Given two posets, return their product poset.
  \methodsource{FinitePosetOperations}{product}{}
\end{gradedexercise}
\begin{gradedexercise}
  Given two posets, return their disjoint union.

  \methodsource{FinitePosetOperations}{disjoint_union}{}
\end{gradedexercise}


\section{Monoidal posets}


\classsource{FiniteMonoidalPoset}{}

\begin{gradedexercise}
  Given a poset and a monoid with the same carrier set, check that together they define a monoidal poset.

  \methodsource{MonoidalPosetOperations}{is_monoidal_poset}{}
\end{gradedexercise}


\section{Monotone maps}


\classsource{MonotoneMap}{}


\begin{gradedexercise}
  Check if a map is monotone.

  \methodsource{FiniteMonotoneMapProperties}{is_monotone}{}
\end{gradedexercise}


\begin{gradedexercise}
  Check if a map is antitone. Reduce to a call of \funcname{is_antitone}.

  \methodsource{FiniteMonotoneMapProperties}{is_antitone}{}
\end{gradedexercise}


\section{Lattices}


\classsource{MeetSemilattice}{}

\classsource{JoinSemilattice}{}

\classsource{Lattice}{}

Note that in a join/meet semilattice there is always a top/bottom.


\chapter{Categories}


\section{SemiCategories}
\subsection*{Interface}
\classsource{FiniteSemiCategory}{}

\subsection*{Representation}
\datafilefig{cat1}{cat1.semicat.yaml}{fig:cat1}


\section{Categories}
\subsection*{Interface}
Compared to a finite semicategory, the finite category
has also an identity for each object.
\classsource{FiniteCategory}{}

\subsection*{Representation}

The representation is the same as finite category.

\subsection*{Operations}

\begin{gradedexercise}
  Compute the disjoint union of two categories.

  \methodsource{FiniteCategoryOperations}{disjoint_union}{}
\end{gradedexercise}

\begin{gradedexercise}
  Compute the product of two categories.

  \methodsource{FiniteCategoryOperations}{product}{}
\end{gradedexercise}


\subsection*{Constructors}


\begin{gradedexercise}
  Compute the arrow category.

  \methodsource{FiniteCategoryOperations}{arrow}{}
\end{gradedexercise}


\begin{gradedexercise}
  Compute the twisted arrow category.

  \methodsource{FiniteCategoryOperations}{twisted_arrow}{}
\end{gradedexercise}


\chapter{Functors}


\section{Functors}

\subsection*{Interface}
\classsource{FiniteFunctor}{}

\subsection*{Representation}
The format is shown in \cref{fig:set1}.

\datafilefig{fun1}{fun1.functor.yaml}{fig:fun1}



\begin{gradedexercise}
  Create a function to load the data.
%
  \classsource{FiniteFunctorRepresentation}{}
\end{gradedexercise}


\section{Monoidal category}


\chapter{Natural transformations and adjuctions}


\section{Natural transformations}

\subsection*{Interface}
\classsource{FiniteNaturalTransformation}{}

\subsection*{Representation}
The format is shown in \cref{fig:nat1}.

\datafilefig{nat1}{nat1.nat.yaml}{fig:nat1}


\begin{gradedexercise}
  Create a function to load the data.

%
  \classsource{FiniteNaturalTransformationRepresentation}{}
\end{gradedexercise}


\section{Adjunctions}

\subsection*{Interface}
\classsource{FiniteAdjunction}{}

\subsection*{Representation}

The format is shown in \cref{fig:nat1}.

\datafilefig{adj1}{adj1.adjunction.yaml}{fig:adj1}


\begin{gradedexercise}
  Create a function to load the data.

%
  \classsource{FiniteAdjunctionRepresentation}{}
\end{gradedexercise}

\subsection{Operations}
\begin{gradedexercise}
  Given two functors, compute if they are an adjunction.

  \methodsource{FiniteAdjunctionsOperations}{is_adjunction}{}
\end{gradedexercise}

\begin{gradedexercise}
  Given a relation, return the induced adjunction.
  \methodsource{FiniteAdjunctionsOperations}{from_relation}{}
\end{gradedexercise}


\begin{gradedexercise}
  Compose two compatible adjunctions.
  \methodsource{FiniteAdjunctionsOperations}{compose}{}
\end{gradedexercise}


\chapter{Profunctors}


\section{DP}

\label{sec:exercises-DP}

\subsection*{Interface}
\classsource{FiniteDP}{}

\subsection*{Representation}


The format is shown in \cref{fig:dp1}.

\datafilefig{dp1}{dp1.dp.yaml}{fig:dp1}

\begin{gradedexercise}
  Create a function to load DPs.
%
  \classsource{FiniteDP}{}
\end{gradedexercise}

\subsection*{Constructors}


\begin{gradedexercise}
  Generate the companion of a monotone map.
%
  \methodsource{DPConstructors}{companion}{}
\end{gradedexercise}

\begin{gradedexercise}
  Generate the conjoint of a monotone map.
%
  \methodsource{DPConstructors}{conjoint}{}
%
\end{gradedexercise}





\begin{gradedexercise}
  Compose two DPs.
%
  \methodsource{FiniteDPOperations}{series}{}
\end{gradedexercise}

\begin{gradedexercise}
  Compute union of two DPs.
%
  \methodsource{FiniteDPOperations}{union}{}
\end{gradedexercise}

\begin{gradedexercise}
  Compute intersection of two DPs.
%
  \methodsource{FiniteDPOperations}{intersection}{}
\end{gradedexercise}


\section{Profunctors}



\classsource{FiniteProfunctor}{}

\label{sec:exercises-profunctors}

\subsection*{Interface}

\classsource{FiniteProfunctor}{}

\subsection*{Representation}

The format is shown in \cref{fig:prof1}.

\datafilefig{prof1}{prof1.profunctor.yaml}{fig:prof1}



\begin{gradedexercise}
  Create a function to load profunctors.

%
  \classsource{FiniteProfunctorRepresentation}{}

\end{gradedexercise}


\begin{gradedexercise}
  Compute series of two profunctor.
%
  \methodsource{FiniteProfunctorOperations}{series}{}
\end{gradedexercise}


\section{Enriched categories}

\subsection*{Interface}

\classsource{FiniteEnrichedCategory}{}

\subsection*{Representation}


\chapter{Legos}
\label{ch:exercises-legos}


\section{Legos}

\subsection*{Representation}


The format is shown in \cref{fig:parts1}.

\datafilefig{parts1}{parts1.parts.yaml}{fig:parts1}

\subsection{Assemblies}

\begin{gradedexercise}
  Given a set of Lego blocks, find out if they are rigidly connected.
\end{gradedexercise}

\begin{gradedexercise}
  Given a set of Lego blocks, find out if they are stable.
\end{gradedexercise}


\begin{gradedexercise}
  Given a set of Lego blocks, find a stable assembly of them.
\end{gradedexercise}

\begin{gradedexercise}
  Given a set of Lego blocks, find a plan to assembled them using 1 robot hand.
\end{gradedexercise}

\begin{gradedexercise}
  Given a set of Lego blocks, find a plan to assemble them using n robot hands.
\end{gradedexercise}

\subsection{Planning}

\todotext{planning problems with legos}


\chapter{Computation}


\section{Setoids}

This is the \Setoid interface:
%
\classsource{Setoid}{}
%
A \Setoid is an object that can tell use whether other objects belong to it.
The \funcname{contains} function is akin to the indicator function.


\begin{gradedexercise}
  Create the function \funcname{union_setoids}, which, given two setoids, returns another setoid that is the union of the two given setoids.
%
  \methodsource{SetoidOperations}{union_setoids}{}
%
  Hint: The indicator of the union of sets is the OR of the two indicators.
\end{gradedexercise}

\begin{gradedexercise}
  Create the function \funcname{intersection_setoids}, which, given two setoids, returns another setoid that is the intersection of the two given setoids.
%
  \methodsource{SetoidOperations}{intersection_setoids}{}
\end{gradedexercise}


\section{EnumerableSets}

%
An enumerable set is one that can enumerate its elements.
The method \funcname{elements} returns an \emph{iterator} that enumerates the elements.

\begin{gradedexercise}
  Create an Enumerable set given a function that provides the $i$-th element.

  The
%
  \methodsource{EnumerableSetsOperations}{make_set_sequence}{}
\end{gradedexercise}

\begin{gradedexercise}
  Create a function that creates the union of two enumerable sets.

  The
%
  \methodsource{EnumerableSetsOperations}{union_esets}{}
\end{gradedexercise}

\begin{gradedexercise}
  Explain why it is not possible to create a function that, given two enumerable sets,
  creates the \emph{intersection} of the two sets.
\end{gradedexercise}


