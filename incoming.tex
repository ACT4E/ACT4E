\part{Homework}
\partfirstb{(short desc)}{placeholder}{(caption)}{long desc}


\chapter{Instructions}
\chapterfirst{placeholder}{}{}


\section{Introduction}

\subsection{Prerequisites}
\todotext{Pointer to learning Python resources.}
\todotext{Pointer to learning Git/Github resources.}


\section{Set up}

\todotext{Instructions on how to access Github Classroom}


\section{First Python exercise}

\todotext{A simple exercise}


\chapter{Sets and relations}
\chapterfirst{placeholder}{}{}


\section{Finite sets}

\subsection{Interface}
Here is the interface for finite sets:
%
\classsource{FiniteSet}

%

\subsection{Representation}
The format is shown in \cref{fig:set1}.

\datafilefig{set1code}{set1.finset.yaml}{fig:set1}


\begin{exercise}[Loading finite sets]
  Create a function to load the data.
  Interface to implement:
%
  \classsource{FiniteSetRepresentation}

\end{exercise}

\subsection{Properties}

\begin{exercise}
  Given two finite sets, check if they are a subset of the other.
  \methodsource{FiniteSetProperties}{is_subset}
\end{exercise}

\subsection{Composition}

\begin{exercise}
  Given two finite sets, compute the union.

  Interface to implement:
  \methodsource{FiniteSetOperations}{union}
\end{exercise}

\begin{exercise}
  Given two finite sets, compute the intersection.

  Interface to implement:
  \methodsource{FiniteSetOperations}{intersection}
\end{exercise}



\begin{exercise}
  Given two finite sets, compute the product.

  Interface to implement:
  \methodsource{FiniteSetOperations}{product}
\end{exercise}
\begin{exercise}
  Given two finite sets, compute the disjoint union.

  Interface to implement:
  \methodsource{FiniteSetOperations}{disjoint_union}
\end{exercise}


\section{Finite Relations}

\subsection{Interface}

A finite relation \classname{FiniteRelation} ...

\classsource{FiniteRelation}

\subsection{Representation}

The format is shown in \cref{fig:rel1}.

\datafilefig{rel11code}{rel1.finrel.yaml}{fig:rel1}

\begin{exercise}[Loading finite relations]
  Create a function to load the data.

  Interface to implement:
%
  \classsource{FiniteRelationRepresentation}

\end{exercise}


%  \input{10_arrows/10_composition/10_topic1}

\begin{exercise}[Relation properties]

  Check that an endorelation has the properties mentioned in \cref{sec:relations}.

  The interface to implement:
  \classsource{FiniteRelationProperties}

\end{exercise}




\begin{exercise}[Opposite]
  Compute the opposite relation.

  \methodsource{FiniteEndorelationOperations}{transitive_closure}

\end{exercise}

\begin{exercise}[Endorelation properties]

  Check that an endorelation has the properties mentioned in \cref{sec:endorelations}.

  The interfaces to implement:
  \classsource{FiniteEndorelationProperties}

\end{exercise}

\begin{exercise}[Transitive closure]
  Compute the transitive closure (\cref{def:transitive-closure}) of a relation.

  \methodsource{FiniteEndorelationOperations}{transitive_closure}

\end{exercise}


\section{Finite Maps}

\subsection{Interface}

A finite relation \classname{FiniteMap} ...

\classsource{FiniteMap}

\subsection{Representation}

The format is shown in \cref{fig:map1}.
\datafilefig{map1}{map1.map.yaml}{fig:map1}


\begin{exercise}[Representation]
  Create a function to load the data.

  Interface to implement:
%
  \classsource{FiniteMapRepresentation}

\end{exercise}

\subsection{Operations}


\begin{exercise}[Composition]
  Implement the composition of finite maps.

  Interface to implement:
%
  \methodsource{FiniteMapOperations}{compose}

\end{exercise}


\begin{exercise}[Obtain relation]
  Given a FiniteMap, obtain the relation.

  Interface to implement:
%
  \methodsource{FiniteMapOperations}{as_relation}

\end{exercise}


\chapter{Monoids and semigroups}

\chapterfirst{placeholder}{}{}


\section{Semigroups}

\subsection{Interface}


\classsource{FiniteSemigroup}

\subsection{Representation}

The format is shown in \cref{fig:sm1}.
\datafilefig{sm1}{sm1.semigroup.yaml}{fig:sm1}


\begin{exercise}[Representation]
  Create a function to load the data.

  Interface to implement:
%
  \classsource{FiniteSemigroupRepresentation}

\end{exercise}


\section{Monoids}

\subsection{Interface}


\classsource{FiniteMonoid}

\subsection{Representation}

The format is shown in \cref{fig:monoid1}.

\datafilefig{monoid1}{monoid1.monoid.yaml}{fig:monoid1}


\begin{exercise}[Representation]
  Create a function to load the data.

  Interface to implement:
%
  \classsource{FiniteMonoidRepresentation}

\end{exercise}


\section{Equational theories}

\todotext{Word problem or some such}


\chapter{Orders}
\chapterfirst{placeholder}{}{}


\section{Posets}

\subsection{Interface}

Here is the interface for posets:

%
\classsource{FinitePoset}

\subsection{Representation}

\datafilefig{poset1}{poset1.poset.yaml}{fig:poset1}

\begin{exercise}[Representation]
  Create a function to load the data.

  Interface to implement:
%
  \classsource{FinitePosetRepresentation}

\end{exercise}

\subsection{Properties}


\begin{exercise}
  Compute the width of a poset.
  \methodsource{FinitePosetProperties}{width}
\end{exercise}

\begin{exercise}
  Compute the height of a poset.
  \methodsource{FinitePosetProperties}{height}
\end{exercise}

\subsection{Operations}


\begin{exercise}
  Given a poset, return the opposite.
  \methodsource{FinitePosetOperations}{opposite}
\end{exercise}

\subsection{Properties of subsets}


\begin{exercise}
  Check if a subset is a chain.
  \methodsource{FinitePosetSubsetProperties}{is_chain}
\end{exercise}

\begin{exercise}
  Check if a subset is an antichain.
  \methodsource{FinitePosetSubsetProperties}{is_antichain}
\end{exercise}

\subsection{Operations on subsets of posets}

\begin{exercise}
  Compute the upper closure of a subset.
  \methodsource{FinitePosetSubsetOperations}{upperclosure}

\end{exercise}


\begin{exercise}
  Compute the lower closure of a subset, reducing to
  using the function \funcname{upperclosure} that you
  already defined.
  \methodsource{FinitePosetSubsetOperations}{lowerclosure}

\end{exercise}



\begin{exercise}
  Compute the minimal elements of a subset.

  \methodsource{FinitePosetSubsetOperations}{minimal}

\end{exercise}


\begin{exercise}
  Compute the maximal elements of a subset, reducing
  to use the function \funcname{minimal} already defined.

  \methodsource{FinitePosetSubsetOperations}{maximal}

\end{exercise}


\begin{exercise}
  Compute the infimum/supremum/meet/join of a subset.
  In case one does not exist, return None.

  \methodsource{FinitePosetSubsetOperations}{infimum}
  \methodsource{FinitePosetSubsetOperations}{supremum}
  \methodsource{FinitePosetSubsetOperations}{meet}
  \methodsource{FinitePosetSubsetOperations}{join}

\end{exercise}

\subsection{Lower/upper sets}
\begin{exercise}
  Given a set, return the power set, a poset ordered by inclusion.

  \methodsource{FinitePosetConstructors}{powerset}
\end{exercise}

\begin{exercise}
  Given a poset, define the poset of upper sets.

  \methodsource{FinitePosetConstructors}{uppersets}
\end{exercise}

\begin{exercise}
  Given a poset, define the poset of lower sets.
  \methodsource{FinitePosetConstructors}{lowersets}
\end{exercise}


\begin{exercise}
  Given two posets, return their product poset.
  \methodsource{FinitePosetOperations}{product}
\end{exercise}
\begin{exercise}
  Given two posets, return their disjoint union.

  \methodsource{FinitePosetOperations}{disjoint_union}
\end{exercise}


\section{Monotone maps}





\begin{exercise}
  Check if a map is monotone.

  \methodsource{FinitePosetMapProperties}{is_monotone}
\end{exercise}

\begin{exercise}
  Check if a map is antitone. Reduce to a call of \funcname{is_antitone}.

  \methodsource{FinitePosetMapProperties}{is_antitone}
\end{exercise}



\section{Lattices}


\classsource{FiniteMeetSemilattice}

\classsource{FiniteJoinSemilattice}

\classsource{FiniteLattice}

Note that in a join/meet semilattice there is always a top/bottom.


\chapter{Categories}
\chapterfirst{placeholder}{}{}

\section{Categories}

\classsource{FiniteCategory}


\datafilefig{cat1}{cat1.semicat.yaml}{fig:cat1}


\chapter{Functors}
\chapterfirst{placeholder}{}{}


\section{Functors}

\subsection{Interface}
\classsource{FiniteFunctor}

\subsection{Representation}
The format is shown in \cref{fig:set1}.

\datafilefig{fun1}{fun1.functor.yaml}{fig:fun1}


\datafilefig{set1code}{set1.finset.yaml}{fig:set1}

\begin{exercise}
  Create a function to load the data.
  Interface to implement:
%
  \classsource{FiniteFunctorRepresentation}
\end{exercise}


\chapter{Natural transformations and adjuctions}
\chapterfirst{placeholder}{}{}


\section{Natural transformations}

\subsection{Interface}
\classsource{FiniteNaturalTransformation}

\subsection{Representation}
The format is shown in \cref{fig:nat1}.

\datafilefig{nat1}{nat1.nat.yaml}{fig:nat1}


\begin{exercise}
  Create a function to load the data.
  Interface to implement:
%
  \classsource{FiniteNaturalTransformationRepresentation}
\end{exercise}


\section{Adjunctions}

\subsection{Interface}
\classsource{FiniteAdjunction}

\subsection{Representation}

The format is shown in \cref{fig:nat1}.

\datafilefig{adj1}{adj1.adjunction.yaml}{fig:adj1}


\begin{exercise}
  Create a function to load the data.
  Interface to implement:
%
  \classsource{FiniteAdjunctionRepresentation}
\end{exercise}

\subsection{Operations}
\begin{exercise}
  Given two functors, compute if they are an adjunction.

  \methodsource{FiniteAdjunctionsOperations}{is_adjunction}
\end{exercise}

\begin{exercise}
  Given a relation, return the induced adjunction.
  \methodsource{FiniteAdjunctionsOperations}{from_relation}
\end{exercise}


\begin{exercise}
  Compose two compatible adjunctions.
  \methodsource{FiniteAdjunctionsOperations}{compose}
\end{exercise}


\chapter{Profunctors}
\chapterfirst{placeholder}{}{}


\section{DP}\label{sec:exercises-DP}

\datafilefig{dp1}{dp1.dp.yaml}{fig:dp1}


\section{Profunctors}\label{sec:exercises-profunctors}

\datafilefig{prof1}{prof1.profunctor.yaml}{fig:prof1}


\chapter{Legos}
\label{ch:exercises-legos}
\chapterfirst{placeholder}{}{}


\section{Legos}

\subsection{Representation}

\subsection{Assemblies}

\begin{exercise}
  Given a set of Lego blocks, find out if they are rigidly connected.
\end{exercise}

\begin{exercise}
  Given a set of Lego blocks, find out if they are stable.
\end{exercise}

\begin{exercise}
  Given a set of Lego blocks, find a stable assembly of them.
\end{exercise}

\begin{exercise}
  Given a set of Lego blocks, find a plan to assembled them using 1 robot hand.
\end{exercise}

\begin{exercise}
  Given a set of Lego blocks, find a plan to assemble them using n robot hands.
\end{exercise}

\subsection{Planning}

\todotext{planning problems with legos}


\chapter{Computation}
\chapterfirst{placeholder}{}{}


\section{Setoids}

This is the \Setoid interface:
%
\classsource{Setoid}
%
A \Setoid is an object that can tell use whether other objects belong to it.
The \funcname{belong} function is akin to the indicator function.


\begin{exercise}
  Create the function \funcname{union_setoids}, which, given two setoids, returns another setoid that is the union of the two given setoids.
%
  \methodsource{SetoidOperations}{union_setoids}
%
  Hint: The indicator of the union of sets is the OR of the two indicators.
\end{exercise}

\begin{exercise}
  Create the function \funcname{intersection_setoids}, which, given two setoids, returns another setoid that is the intersection of the two given setoids.
%
  \methodsource{SetoidOperations}{intersection_setoids}
\end{exercise}


\section{EnumerableSets}

This is the interface of \classname{EnumerableSet}:
%
\classsource{EnumerableSet}
%
An enumerable set is one that can enumerate its elements.
The method \funcname{elements} returns an \emph{iterator} that enumerates the elements.

\begin{exercise}
  Create an Enumerable set given a function that provides the $i$-th element.

  The interface to implement:
%
  \methodsource{EnumerableSetsOperations}{make_set_sequence}
\end{exercise}

\begin{exercise}
  Create a function that creates the union of two enumerable sets.

  The interface to implement:
%
  \methodsource{EnumerableSetsOperations}{union_esets}
\end{exercise}

\begin{exercise}
  Explain why it is not possible to create a function that, given two enumerable sets,
  creates the \emph{intersection} of the two sets.
\end{exercise}


