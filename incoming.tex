\part{Homework}
\partfirstb{(short desc)}{placeholder}{(caption)}{long desc}


\chapter{Instructions}


\section{Introduction}

\subsection{Prerequisites}
\todotext{Pointer to learning Python resources.}
\todotext{Pointer to learning Git/Github resources.}


\section{Set up}

\todotext{Instructions on how to access Github Classroom}


\section{First Python exercise}

\todotext{A simple exercise}


\chapter{Sets and relations}


\section{Finite sets}

\subsection*{Interface}
Here is the interface for finite sets:
%
\classsource{FiniteSet}

%

\subsection*{Representation}
The format is shown in \cref{fig:set1}.

\datafilefig{set1code}{set1.finset.yaml}{fig:set1}


\begin{exercise}[Loading finite sets]
  Create a function to load the data.

%
  \classsource{FiniteSetRepresentation}

\end{exercise}

\subsection{Properties}

\begin{exercise}
  Given two finite sets, check if they are a subset of the other.
  \methodsource{FiniteSetProperties}{is_subset}
\end{exercise}

\subsection{Composition}

\begin{exercise}
  Given two finite sets, compute the union.


  \methodsource{FiniteSetOperations}{union}
\end{exercise}

\begin{exercise}
  Given two finite sets, compute the intersection.


  \methodsource{FiniteSetOperations}{intersection}
\end{exercise}



\begin{exercise}
  Given two finite sets, compute the product.


  \methodsource{FiniteSetOperations}{product}
\end{exercise}
\begin{exercise}
  Given two finite sets, compute the disjoint union.


  \methodsource{FiniteSetOperations}{disjoint_union}
\end{exercise}


\section{Finite Relations}

\subsection*{Interface}

A finite relation \classname{FiniteRelation} ...

\classsource{FiniteRelation}

\subsection*{Representation}

The format is shown in \cref{fig:rel1}.

\datafilefig{rel11code}{rel1.finrel.yaml}{fig:rel1}

\begin{exercise}[Loading finite relations]
  Create a function to load the data.


%
  \classsource{FiniteRelationRepresentation}

\end{exercise}


%  \input{10_arrows/10_composition/10_topic1}

\begin{exercise}[Relation properties]

  Check that an endorelation has the properties mentioned in \cref{sec:relations}.

  The
  \classsource{FiniteRelationProperties}

\end{exercise}




\begin{exercise}[Opposite]
  Compute the opposite relation.

  \methodsource{FiniteEndorelationOperations}{transitive_closure}

\end{exercise}

\begin{exercise}[Endorelation properties]

  Check that an endorelation has the properties mentioned in \cref{sec:endorelations}.

  The interfaces to implement:
  \classsource{FiniteEndorelationProperties}

\end{exercise}

\begin{exercise}[Transitive closure]
  Compute the transitive closure (\cref{def:transitive-closure}) of a relation.

  \methodsource{FiniteEndorelationOperations}{transitive_closure}

\end{exercise}


\section{Finite Maps}

\subsection*{Interface}

A finite relation \classname{FiniteMap} ...

\classsource{FiniteMap}

\subsection*{Representation}

The format is shown in \cref{fig:map1}.
\datafilefig{map1}{map1.map.yaml}{fig:map1}


\begin{exercise}[Representation]
  Create a function to load the data.


%
  \classsource{FiniteMapRepresentation}

\end{exercise}

\subsection{Operations}


\begin{exercise}[Composition]
  Implement the composition of finite maps.


%
  \methodsource{FiniteMapOperations}{compose}

\end{exercise}


\begin{exercise}[Obtain relation]
  Given a FiniteMap, obtain the relation.


%
  \methodsource{FiniteMapOperations}{as_relation}

\end{exercise}


\chapter{Monoids and semigroups}


\section{Semigroups}

\subsection*{Interface}


\classsource{FiniteSemigroup}

\subsection*{Representation}

The format is shown in \cref{fig:sm1}.
\datafilefig{sm1}{sm1.semigroup.yaml}{fig:sm1}


\begin{exercise}[Representation]
  Create a function to load the data.


  \classsource{FiniteSemigroupRepresentation}

\end{exercise}

\subsection*{Constructors}

\begin{exercise}
  Given a set, construct the free semigroup.

  \methodsource{FiniteSemigroupConstruct}{free}
\end{exercise}


\section{Monoids}

\subsection*{Interface}


\classsource{FiniteMonoid}

\subsection*{Representation}

The format is shown in \cref{fig:monoid1}.

\datafilefig{monoid1}{monoid1.monoid.yaml}{fig:monoid1}


\begin{exercise}[Representation]
  Create a function to load the data.


%
  \classsource{FiniteMonoidRepresentation}

\end{exercise}


\section{Equational theories}

\todotext{Word problem or some such}


\chapter{Orders}


\section{Posets}

\subsection*{Interface}

Here is the interface for posets:

%
\classsource{FinitePoset}

\subsection*{Representation}

\datafilefig{poset1}{poset1.poset.yaml}{fig:poset1}

\begin{exercise}[Representation]
  Create a function to load the data.


%
  \classsource{FinitePosetRepresentation}

\end{exercise}

\subsection{Properties}


\begin{exercise}
  Compute the width of a poset.
  \methodsource{FinitePosetProperties}{width}
\end{exercise}

\begin{exercise}
  Compute the height of a poset.
  \methodsource{FinitePosetProperties}{height}
\end{exercise}

\subsection{Operations}


\begin{exercise}
  Given a poset, return the opposite.
  \methodsource{FinitePosetOperations}{opposite}
\end{exercise}

\subsection{Properties of subsets}


\begin{exercise}
  Check if a subset is a chain.
  \methodsource{FinitePosetSubsetProperties}{is_chain}
\end{exercise}

\begin{exercise}
  Check if a subset is an antichain.
  \methodsource{FinitePosetSubsetProperties}{is_antichain}
\end{exercise}

\subsection{Operations on subsets of posets}

\begin{exercise}
  Compute the upper closure of a subset.
  \methodsource{FinitePosetSubsetOperations}{upperclosure}

\end{exercise}


\begin{exercise}
  Compute the lower closure of a subset, reducing to
  using the function \funcname{upperclosure} that you
  already defined.
  \methodsource{FinitePosetSubsetOperations}{lowerclosure}

\end{exercise}



\begin{exercise}
  Compute the minimal elements of a subset.

  \methodsource{FinitePosetSubsetOperations}{minimal}

\end{exercise}


\begin{exercise}
  Compute the maximal elements of a subset, reducing
  to use the function \funcname{minimal} already defined.

  \methodsource{FinitePosetSubsetOperations}{maximal}

\end{exercise}


\begin{exercise}
  Compute the infimum/supremum/meet/join of a subset.
  In case one does not exist, return None.

  \methodsource{FinitePosetSubsetOperations}{infimum}
  \methodsource{FinitePosetSubsetOperations}{supremum}
  \methodsource{FinitePosetSubsetOperations}{meet}
  \methodsource{FinitePosetSubsetOperations}{join}

\end{exercise}

\subsection{Lower/upper sets}
\begin{exercise}
  Given a set, return the power set, a poset ordered by inclusion.

  \methodsource{FinitePosetConstructors}{powerset}
\end{exercise}


\begin{exercise}
  Given a poset, compute the interval poset.

  \methodsource{FinitePosetConstructors}{intervals}
\end{exercise}


\begin{exercise}
  Given a poset, compute the other interval poset.

  \methodsource{FinitePosetConstructors}{intervals2}
\end{exercise}


\begin{exercise}
  Given a poset, define the poset of upper sets.

  \methodsource{FinitePosetConstructors}{uppersets}
\end{exercise}

\begin{exercise}
  Given a poset, define the poset of lower sets.
  \methodsource{FinitePosetConstructors}{lowersets}
\end{exercise}


\begin{exercise}
  Given a set, construct the discrete poset.

  \methodsource{FinitePosetConstructors}{discrete}
\end{exercise}


\begin{exercise}
  Given two posets, return their product poset.
  \methodsource{FinitePosetOperations}{product}
\end{exercise}
\begin{exercise}
  Given two posets, return their disjoint union.

  \methodsource{FinitePosetOperations}{disjoint_union}
\end{exercise}


\section{Monoidal posets}


\classsource{FiniteMonoidalPoset}

\begin{exercise}
  Given a poset and a monoid with the same carrier set, check that together they define a monoidal poset.

  \methodsource{MonoidalPosetOperations}{is_monoidal_poset}
\end{exercise}


\section{Monotone maps}


\classsource{FiniteMonotoneMap}


\begin{exercise}
  Check if a map is monotone.

  \methodsource{FiniteMonotoneMapProperties}{is_monotone}
\end{exercise}


\begin{exercise}
  Check if a map is antitone. Reduce to a call of \funcname{is_antitone}.

  \methodsource{FiniteMonotoneMapProperties}{is_antitone}
\end{exercise}


\section{Lattices}


\classsource{FiniteMeetSemilattice}

\classsource{FiniteJoinSemilattice}

\classsource{FiniteLattice}

Note that in a join/meet semilattice there is always a top/bottom.


\chapter{Categories}


\section{SemiCategories}
\subsection*{Interface}
\classsource{FiniteSemiCategory}

\subsection*{Representation}
\datafilefig{cat1}{cat1.semicat.yaml}{fig:cat1}


\section{Categories}
\subsection*{Interface}
Compared to a finite semicategory, the finite category
has also an identity for each object.
\classsource{FiniteCategory}

\subsection*{Representation}

The representation is the same as finite category.

\subsection*{Operations}

\begin{exercise}
  Compute the disjoint union of two categories.

  \methodsource{FiniteCategoryOperations}{disjoint_union}
\end{exercise}

\begin{exercise}
  Compute the product of two categories.

  \methodsource{FiniteCategoryOperations}{product}
\end{exercise}


\subsection*{Constructors}


\begin{exercise}
  Compute the arrow category.

  \methodsource{FiniteCategoryOperations}{arrow}
\end{exercise}


\begin{exercise}
  Compute the twisted arrow category.

  \methodsource{FiniteCategoryOperations}{twisted_arrow}
\end{exercise}


\chapter{Functors}


\section{Functors}

\subsection*{Interface}
\classsource{FiniteFunctor}

\subsection*{Representation}
The format is shown in \cref{fig:set1}.

\datafilefig{fun1}{fun1.functor.yaml}{fig:fun1}



\begin{exercise}
  Create a function to load the data.
%
  \classsource{FiniteFunctorRepresentation}
\end{exercise}


\section{Monoidal category}


\chapter{Natural transformations and adjuctions}


\section{Natural transformations}

\subsection*{Interface}
\classsource{FiniteNaturalTransformation}

\subsection*{Representation}
The format is shown in \cref{fig:nat1}.

\datafilefig{nat1}{nat1.nat.yaml}{fig:nat1}


\begin{exercise}
  Create a function to load the data.

%
  \classsource{FiniteNaturalTransformationRepresentation}
\end{exercise}


\section{Adjunctions}

\subsection*{Interface}
\classsource{FiniteAdjunction}

\subsection*{Representation}

The format is shown in \cref{fig:nat1}.

\datafilefig{adj1}{adj1.adjunction.yaml}{fig:adj1}


\begin{exercise}
  Create a function to load the data.

%
  \classsource{FiniteAdjunctionRepresentation}
\end{exercise}

\subsection{Operations}
\begin{exercise}
  Given two functors, compute if they are an adjunction.

  \methodsource{FiniteAdjunctionsOperations}{is_adjunction}
\end{exercise}

\begin{exercise}
  Given a relation, return the induced adjunction.
  \methodsource{FiniteAdjunctionsOperations}{from_relation}
\end{exercise}


\begin{exercise}
  Compose two compatible adjunctions.
  \methodsource{FiniteAdjunctionsOperations}{compose}
\end{exercise}


\chapter{Profunctors}


\section{DP}

\label{sec:exercises-DP}

\subsection*{Interface}
\classsource{FiniteDP}

\subsection*{Representation}


The format is shown in \cref{fig:dp1}.

\datafilefig{dp1}{dp1.dp.yaml}{fig:dp1}

\begin{exercise}
  Create a function to load DPs.
%
  \classsource{FiniteDP}
\end{exercise}

\subsection*{Constructors}


\begin{exercise}
  Generate the companion of a monotone map.
%
  \methodsource{FiniteDPConstructors}{companion}
\end{exercise}

\begin{exercise}
  Generate the conjoint of a monotone map.
%
  \methodsource{FiniteDPConstructors}{conjoint}
%
\end{exercise}





\begin{exercise}
  Compose two DPs.
%
  \methodsource{FiniteDPOperations}{series}
\end{exercise}

\begin{exercise}
  Compute union of two DPs.
%
  \methodsource{FiniteDPOperations}{union}
\end{exercise}

\begin{exercise}
  Compute intersection of two DPs.
%
  \methodsource{FiniteDPOperations}{intersection}
\end{exercise}


\section{Profunctors}



\classsource{FiniteProfunctor}

\label{sec:exercises-profunctors}

\subsection*{Interface}

\classsource{FiniteProfunctor}

\subsection*{Representation}

The format is shown in \cref{fig:prof1}.

\datafilefig{prof1}{prof1.profunctor.yaml}{fig:prof1}



\begin{exercise}
  Create a function to load profunctors.

%
  \classsource{FiniteProfunctorRepresentation}

\end{exercise}


\begin{exercise}
  Compute series of two profunctor.
%
  \methodsource{FiniteProfunctorOperations}{series}
\end{exercise}


\section{Enriched categories}

\subsection*{Interface}

\classsource{FiniteEnrichedCategory}

\subsection*{Representation}


\chapter{Legos}
\label{ch:exercises-legos}


\section{Legos}

\subsection*{Representation}


The format is shown in \cref{fig:parts1}.

\datafilefig{parts1}{parts1.parts.yaml}{fig:parts1}

\subsection{Assemblies}

\begin{exercise}
  Given a set of Lego blocks, find out if they are rigidly connected.
\end{exercise}

\begin{exercise}
  Given a set of Lego blocks, find out if they are stable.
\end{exercise}

\begin{exercise}
  Given a set of Lego blocks, find a stable assembly of them.
\end{exercise}

\begin{exercise}
  Given a set of Lego blocks, find a plan to assembled them using 1 robot hand.
\end{exercise}

\begin{exercise}
  Given a set of Lego blocks, find a plan to assemble them using n robot hands.
\end{exercise}

\subsection{Planning}

\todotext{planning problems with legos}


\chapter{Computation}


\section{Setoids}

This is the \Setoid interface:
%
\classsource{Setoid}
%
A \Setoid is an object that can tell use whether other objects belong to it.
The \funcname{belong} function is akin to the indicator function.


\begin{exercise}
  Create the function \funcname{union_setoids}, which, given two setoids, returns another setoid that is the union of the two given setoids.
%
  \methodsource{SetoidOperations}{union_setoids}
%
  Hint: The indicator of the union of sets is the OR of the two indicators.
\end{exercise}

\begin{exercise}
  Create the function \funcname{intersection_setoids}, which, given two setoids, returns another setoid that is the intersection of the two given setoids.
%
  \methodsource{SetoidOperations}{intersection_setoids}
\end{exercise}


\section{EnumerableSets}

This is the interface of \classname{EnumerableSet}:
%
\classsource{EnumerableSet}
%
An enumerable set is one that can enumerate its elements.
The method \funcname{elements} returns an \emph{iterator} that enumerates the elements.

\begin{exercise}
  Create an Enumerable set given a function that provides the $i$-th element.

  The
%
  \methodsource{EnumerableSetsOperations}{make_set_sequence}
\end{exercise}

\begin{exercise}
  Create a function that creates the union of two enumerable sets.

  The
%
  \methodsource{EnumerableSetsOperations}{union_esets}
\end{exercise}

\begin{exercise}
  Explain why it is not possible to create a function that, given two enumerable sets,
  creates the \emph{intersection} of the two sets.
\end{exercise}


