% !TEX root = chapter-standalone.tex

\section{Semifunctors}

\linkvideo{spring2021-functors:semi-and-fun:semi-fun-def} % Definition of semi-functor

%\linkvideo{spring2021-functors:semi-and-fun} % Semifunctors and functors

\begin{ctdefinition}[Semifunctor]
    \label{def:semifunctor}
    Given \SY{semicategories}~\CatC and~\CatD, a \maindef{semifunctor}~$\funa\colon \CatC\fto \CatD$ from~\CatC to~\CatD is defined by:

    \constit

    \begin{enumerate}
        \item A map
              \begin{equation}
                  \funaob \colon \ObC \to \ObD.
              \end{equation}
        \item For every pair of objects~$\Obja, \Objb\setin \Obof\CatC$ a map
              \begin{equation}
                  \funamor\colon \HomSet{\CatC}{\Obja}{\Objb} \to \HomSet{\CatD}{\funaob(\Obja)}{\funaob(\Objb)}.
              \end{equation}
    \end{enumerate}

    \condit

    \begin{enumerate}
        \item \SYN{semifunctor}{Semifunctor} application to morphisms is compatible with the respective category composition operations:
              \begin{equation}
                  \prfperiod{
                      \mora\colon \Obja \mtoin{\CatC} \Objb
                  }{\quad}{
                      \morb\colon \Objb \mtoin{\CatC} \Objc
                  }{
                      \funamor(\mora \mthenof{\CatC} \morb)=\funamor(\mora) \mthenof{\CatD} \funamor(\morb)
                  }
              \end{equation}
    \end{enumerate}
\end{ctdefinition}

This situation is depicted graphically in \cref{fig:functor_detail}.
%
It is common to overload the notation and use~$\funa$ to mean both~$\funaob$ and~$\funamor$.
The diagram with this overloaded ``synthetic notation'' is in \cref{fig:functor_representation}.

\vfill

\begin{figure*}[h!]
    % \begin{ctdefinitionshade}
    \subfloat[\label{fig:functor_detail}
        Functor diagram] {
        \centering
        \includesag{095_functor_detail}
    }
    \subfloat[\label{fig:functor_representation}Synthetic notation] {
        \centering
        \includesag{095_functor}
    }
    % \end{ctdefinitionshade}
    \caption{
        Commuting diagrams for \SY{semifunctors}, with verbose notation (left) and synthetic notation (right).
    }
\end{figure*}

\vspace{2cm}

\section{Functors}
\label{sec:functors}
\linkvideo{spring2021-functors:semi-and-fun:fun-def} % Definition of functor

For categories, we have the stronger concept of \SY{functor}.
Categories have identities, and \SY{functors} are required to preserve the identities.

\begin{ctdefinition}[Functor]
    \label{def:functor}
    A \maindef{functor} from category~\CatC to a category~\CatD is a \SY{semifunctor}~$\funa\colon \CatC \fto \CatD$
    that satisfies the condition
    \begin{equation}
        \label{eq:functor-condition}
        \funamor(\catidat\Obja)=\catidat{\funaob(\Obja)}
    \end{equation}
    for all objects $\Obja$ in $\CatC$.
\end{ctdefinition}

\begin{example}[Powerset functor]
    \label{ex:powerset_functor}
    We define a \SY{functor}~$\funa\colon \Set \fto \Set$ which maps each set to its power set.
    In other words, $\funaob(\setA) = \powerset \setA$ for any set $\setA$.
    On the level of morphisms, given a function $\mora \colon \setA \mto \setB$, we define
    \begin{equation}\label{eq:powerset-function-def}
        \begin{aligned}
            \funamor(\mora)\colon \powersetof \setA & \to \powersetof \setB \\
            \setC                                   & \mapsto \makeset{\mora(\setCel) \mid \setCel \setin \setC}.
        \end{aligned}
    \end{equation}
    Here is a concrete illustration.
    Consider the two sets~$\setA = \makeset{\sfondue, \sbretzel, \schoco}$ and~$\setB = \makeset{\scheese,\sgrapes,\sapple}$.
    Applying the \SY{functor} to~\setA gives
    \begin{equation}\label{eq:powerset-functor-example-1a}
        \funaob(\setA)
        =
        \makeset{
            \Emptyset,
            \makeset{\sfondue},
            \makeset{\sbretzel},
            \makeset{\schoco},
            \makeset{\sfondue,\sbretzel},
            \makeset{\sfondue,\schoco},
            \makeset{\sbretzel,\schoco},
            \makeset{\sfondue,\sbretzel,\schoco}
        }
    \end{equation}
    and applying it to $\setB$ gives
    \begin{equation}\label{eq:powerset-functor-example-1b}
        \funaob(\setB)
        =
        \makeset{
            \Emptyset,
            \makeset{\scheese},
            \makeset{\sgrapes},
            \makeset{\sapple},
            \makeset{\scheese,\sgrapes},
            \makeset{\scheese,\sapple},
            \makeset{\sgrapes,\sapple},
            \makeset{\scheese,\sgrapes,\sapple}
        }.
    \end{equation}
    Furthermore, consider the map
    %
    \begin{equation}\label{eq:powerset-functor-example-2}
        \begin{aligned}
            \mora \colon \setA & \sto \setB, \\
            \sfondue           & \mapsto \scheese, \\
            \sbretzel          & \mapsto \sgrapes, \\
            \schoco            & \mapsto \sapple.
        \end{aligned}
    \end{equation}
    %
    This would for instance give~$\funamor(\mora)(\makeset{\sfondue,\sbretzel})=\makeset{\mora(\sfondue),\mora(\sbretzel)}=\makeset{\scheese,\sgrapes}$.

    Now let us check that $\funa$ so-defined really is a functor.

    First let us check that it is compatible with composition.
    Consider functions~$\mora\colon \setA\fto \setB$,~$\morb\colon \setB \fto \setC$.
    On the one hand we have
    \begin{equation}\label{eq:powerset-functor-example-3}
        \begin{aligned}
            \funa(\morab)(\setC) & =\makeset{ \morb(\mora(\setCel))\mid \setCel \setin \setC},
        \end{aligned}
    \end{equation}
    and on the other hand
    \begin{equation}\label{eq:powerset-functor-example-4}
        \begin{aligned}
            (\funa(\mora)\mthen \funa(\morb))(\setC)
             & =\makeset{ \mora(\setCel) \mid \setCel \setin \setC}\mthen \funa(\morb) \\
             & =\makeset{g(\setDel)\mid \setDel \setin \makeset{\mora(\setCel)\mid \setCel\setin \setC}} \\
             & =\makeset{ \morb(\mora(\setCel))\mid \setCel \setin \setC}.
        \end{aligned}
    \end{equation}
    Second, let us check that $\funa$ is compatible with identity morphisms.
    We have
    \begin{equation}\label{eq:powerset-functor-example-5}
        \begin{aligned}
            \funa(\catidat\setA)(\setC) & = \makeset{\catidat\setA(\setCel)\mid \setCel \setin \setC} \\
                                        & =\catidat{\funa(\setC)}.
        \end{aligned}
    \end{equation}
\end{example}

\begin{example}
    There is a \SY{functor}
    \begin{equation}\label{eq:list-functor-intro}
        \listfun\colon \Set \fto \Mon
    \end{equation}
    from the \SY{category of sets} to the \SY{category of monoids}, defined as follows.

    Given a set~\setA, the \SY{functor} returns a specific \SY{monoid}
    \begin{equation}\label{eq:list-functor-on-objects}
        \listfun(\setA)\definedas\tupp{\listsof{\setA},\emptylist_\setA, \listconcat}.
    \end{equation}

    Given a map~$\mapa\colon \setA \sto \setB$, we have
    % \begin{equation}
    %     \defmapcomma{
    %         \listfun(\mapa)
    %     }{
    %         \listsof{\setA}
    %     }{
    %         \to
    %     }{
    %         \listsof{\setB}
    %     }{
    %         \makelist{\setAel_1, \ldots, \setAel_n}
    %     }{
    %         \makelist{\mapa(\setAeln{1}), \ldots, \mapa(\setAeln{n})}
    %     }
    % \end{equation}
    \begin{equation}\label{eq:list-functor-on-morphisms}
        \defmapcomma{
            \listfun(\mapa)
        }{
            \listsof{\setA}
        }{
            \to
        }{
            \listsof{\setB}
        }{
            \makegenlist{ \setAel_i }
        }{
            \makegenlist{ \mapa(\setAeln{i}) }
        }
    \end{equation}
    which applies~$\mapa$ entry-wise in the list.
    The empty list in~$\listsof{\setA}$ is mapped to the empty list in~$\listsof{\setB}$.
        {}
    $\listfun$ is a \SY{functor}, because identity functions in $\Set$ are mapped to the corresponding identity morphisms on lists, and
    % \begin{equation}
    %     \begin{aligned}
    %         \listfun(\mapa \mthen \mapb)(\makelist{\setAeln{1},\ldots,\setAeln{n}}) & =\makelist{(\mapa \mthen \mapb)(\setAeln{1}), \ldots, (\mapa \mthen \mapb)(\setAeln{n})} \\
    %                                                                                 & =\listfun(\mapb)(\makelist{\mapa(\setAeln{1}), \ldots, \mapa(\setAeln{n})}) \\
    %                                                                                 & =(\listfun(\mapa)\mthen \listfun(\mapb))(\makelist{\setAeln{1}, \ldots, \setAeln{n}}).
    %     \end{aligned}
    % \end{equation}
    \begin{equation}\label{eq:list-functor-compositionality}
        \begin{aligned}
            \listfun(\mapa \mthen \mapb)(\makegenlist{\setAeln{i}}) & =\makegenlist{ (\mapa \mthen \mapb)(\setAeln{i})} \\
                                                                    & =\makegenlist{  \mapb ( \mapa (\setAeln{i}))} \\
                                                                    & =\listfun(\mapb)(\makegenlist{\mapa(\setAeln{i})}) \\
                                                                    & =(\listfun(\mapa)\mthen \listfun(\mapb))(\makegenlist{\setAeln{i}}).
        \end{aligned}
    \end{equation}
\end{example}

\begin{gradedexercise}[\exname{DifferentiationFunctor}]
    \label{ex:DifferentiationFunctor}

    Consider the category $\pEuc$ from \linkifexists{ex:pointed-euclidean-spaces}, as well as the category $\RVect$ of real vector spaces studied in \linkifexists{ex:category-real-vect}.
    In this exercise we will define a functor $\funa \colon \pEuc \fto \RVect$ corresponding to differentiation and it is your task to check that it is in fact a functor.

    $\funa$ on objects: $\funaob (\tup{\reals^n, \ela}) = \reals^n$.

    $\funa$ on morphisms: given a morphism $\mora \colon \tup{\reals^n, \ela} \mto \tup{\reals^m, \elb}$ in $\pEuc$, the linear map $\funamor(\mora)$ is the derivative
    \begin{equation}
        D \mora \vert_\ela \colon \reals^n \mto \reals^m,
    \end{equation}
    which is typically represented by the Jacobian matrix.

    The intuition for the on-objects part of this functor is that $\tup{\reals^n, \ela}$ is mapped to the tangent space of ``vectors starting at $\ela$'', which is isomorphic to $\reals^n$.
    On the level of morphisms, the differential of a function $\mora$ at $\ela$ maps vectors starting at $\ela$ to vectors starting at $\mora(\ela)$.

\end{gradedexercise}

\solutionof{DifferentiationFunctor}

\begin{gradedexercise}[\exname{FixedPointFunctor}]
    \label{ex:fixed-point-functor}

    We will propose a functor $\funa \colon \EndSet \fto \Set$ from the category $\EndSet$ defined in \linkifexists{ex:endofunctions} to the category of sets and functions.
    Your task is to check if this is a functor.

    On objects: given an object $\tup{\setA, \stylemorph{\varphi}}$ of $\EndSet$, we define $\funaob( \tup{\setA, \stylemorph{\varphi}}) = \Fix(\stylemorph{\varphi})$, where
    \begin{equation}
        \Fix(\stylemorph{\varphi}) = \makeset{\ela \setin \setA \mid \stylemorph{\varphi}(\ela) = \ela}
    \end{equation}
    is the set of fixed points of $\stylemorph{\varphi}$.

    On morphisms: given a morphism $\mora \colon \tup{\setA, \stylemorph{\varphi}} \mto_\EndSet \tup{\setB, \stylemorph{\psi}}$ of $\EndSet$, we define
    \begin{equation}
        \funamor(\mora) = \mora \vert_{\Fix(\stylemorph{\varphi})}.
    \end{equation}
    In other words, we restrict $\mora$ to the subset $\Fix(\stylemorph{\varphi}) \subseteq \setA$.

\end{gradedexercise}

\solutionof{FixedPointFunctor}

A \SY{functor} from a category to itself is called an \maindef{endofunctor}.
The simplest example of an \SY{endofunctor} is the \SY{identity functor}.

\subsection{Identity functor}
\label{sec:identity-functor}

\begin{definition}[Identity (semi)functor]\label{def:identity-semifunctor}
    \SYNDEF{identity semifunctor}
    For any (semi)category \CatC, we can define the \emph{identity (semi)functor}
    \begin{equation}
        \funidC \colon \CatC \fto \CatC,
    \end{equation}
    which maps each object to itself and each morphism to itself.
\end{definition}

\begin{exercise}
    Check that the identity functor is a functor.
\end{exercise}
\begin{solution}
    To show that this is a valid \SY{functor}, we need to show that it preserves identities and composition:
    \begin{itemize}
        \item Given any~$\Obja \setin \ObC$, we have:
              \begin{equation}
                  \begin{aligned}
                      \funid_{\CatC}(\catidat\Obja) & =\catidat\Obja \\
                                                    & =\catidat{\funid_{\CatC}(\Obja)}
                  \end{aligned}
              \end{equation}
              Furthermore, given composable morphisms~$\mora,\morb$ in~\CatC, we have:
              \begin{equation}
                  \begin{aligned}
                      \funid_{\CatC}(\morab) & =\morab \\
                                             & =\funid_{\CatC}(\mora)\mthen \funid_{\CatC} (\morb).
                  \end{aligned}
              \end{equation}
    \end{itemize}
\end{solution}

% To see that this is indeed a \SY{functor}, notice that~$\funidC(\morab)$ is equal to~$\funidC(\mora)\mthen \funidC(\morb)$ because they are both equal to~$\morab$.
% Moreover, identities are preserved because~$\funidC(\catidof\CatC)=\catidof\CatC$.

\todojira{620}{\alphubel: @JL: let's discuss the ``image'' of a \SY{functor} somewhere}
