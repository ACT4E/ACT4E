% !TEX root = chapter-standalone.tex

\section[Free-forgetful adjunction]{Example of a ``Free-Forgetful'' adjunction}
\label{sec:free-forgetful-adjunction-graph-example}

Another ``type'' of \SY{adjunction} that appears frequently can be called a ``Free-Forgetful'' \SY{adjunction}.
Such \SY{adjunctions} are composed of a ``free functor'' and a ``forgetful functor''.
These terms are informal, but the idea is this.
A free \SY{functor}~$\CatC \fto \CatD$ typically takes an object~$\Obja$ of~\CatC and ``freely'' adds some structure to it.
``Free'' means that only those structures and conditions are added that are absolutely necessary to make~$\Obja$ an object of~\CatD, and otherwise the \SY{functor} does not impose any constraints or relations.
Conversely, a ``forgetful functor'' usually starts from an object~$\Objb$ on~\CatD which has some structure, and ``forgets'' some of this structure, which results in us being able to view~$\Objb$ as an object in~\CatC.

For example: any real \SY{vector space} is built from an underlying set, together with extra structure given by operations (vector addition and scalar multiplication).
There is a forgetful \SY{functor} from the category~$\VectR$ of real \SY{vector spaces} to~\Set which maps any \SY{vector space} to its underlying set of vectors.
On the other hand, there is a ``free'' construction going the other way: given a set~\setA, we can build the ``free real \SY{vector space} generated by~\setA''.
To do this, we think of the elements of~\setA as basis vectors, and we build a \SY{vector space} by taking formal finite~\reals-linear combinations of them.

In the following we will consider an example in detail where we ``freely'' generate a category from a directed graph.

Let~\Graph be the category of directed graphs and~\Category the category of (small) categories.
There is a \SY{functor}~$\funa \colon \Graph \fto \Category$ which turns any directed graph~$D = \tup{V,E, s,t}$ into a category whose objects are the vertices~$V$ and whose morphisms are finite directed paths between vertices.
This is called the \emph{free category generated by the graph~$D$} (\cref{sec:catsfromgraphs}).
There is also a \SY{functor}~$\funb \colon \Category \fto \Graph$ which turns a category~\CatC into a graph where the set of vertices is~$\Obof{\CatC}$ and there is a directed edge between vertices for every morphism in \CatC between the corresponding vertices.

Let's first describe this \SY{adjunction} via \cref{def:adj-iso}.
The natural isomorphism
\begin{equation}
    \stylenat{\tau}\colon \HomSet{\Category}{\funa(-)}{-} \nto \HomSet{\Graph}{-}{\funb(-)}
\end{equation}
is the one whose component at~$\tup{D,\CatC}$ is the isomorphism
\begin{equation}
    \tau_{D,\CatC} \colon \HomSet{\Category}{\funa(D)}{\CatC} \nto \HomSet{\Graph}{D}{\funb(\CatC)}
\end{equation}
which assigns to any \SY{functor}~$\funa\colon \funa(D) \fto \CatC$ the morphism of graphs~$D \colon \funb(\CatC)$ given by restricting~$\funa$ to~$D$ and only keeping track of its action on vertices and edges (in other words, we ignore its compositional properties and think of it just as a graph morphism).

Now let's consider this \SY{adjunction} from the perspective of \cref{def:adj-counit}.
The component at~$D$ of the counit is the morphism of graphs
\begin{equation}
    \eta_D \colon D \to  \funb(\funa(D))
\end{equation}
which includes~$D$ into the graph~$\funb(\funa(D))$.
The latter has an edge from the source to the target of every finite path in~$D$.
The paths of length zero are what corresponded to  \SY{identity morphisms} in~$\funa(D)$, and the paths of length one constitute a copy of~$D$ inside~$\funb(\funa(D))$.

What does the unit look like?
Its component at~\CatC is a functor
\begin{equation}
    \stylefunctors{\epsilon}_{\CatC} \colon \funa(\funb(\CatC)) \fto \CatC.
\end{equation}

The category~$\funa(\funb(\CatC))$ is larger than~\CatC: starting with \CatC, the graph~$\funb(\CatC)$ will contain edges for all the morphisms in~\CatC, but it will forget their compositional interlinking.
In particular, for example, it will forget which loops denote  \SY{identity morphisms} (in other words, which morphisms act neutrally) and, more generally, it will forget when different compositions of morphism give the same result.
In~$\funa(\funb(\CatC))$, then, morphism compositions that might have given the same result in~\CatC will now be distinct.
The \SY{functor}~$\stylefunctors{\epsilon}_{\CatC}$ in a sense ``remembers'' those relations that were true in \CatC and it ``implements'' them by ``projecting''~$\funa(\funb(\CatC))$ back to~\CatC.
