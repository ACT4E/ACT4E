% !TEX root = chapter-standalone.tex


\section{Exercise tutorial: Finite sets}\label{sec:exercise-tutorial}


During the exercises, you are going to build in Python a library to build and manipulate most of the concepts in the book.
As a first step, we are going to build together the support for sets.

The exercises will give you the \emph{interface} of an \emph{abstract class} to be generated.

Let's define two interfaces: \Setoid, for a generic set, \EnumerableSet, and \FiniteSet, for a setoid that has a finite set of elements.
They are defined in the package \str{act4e_interfaces} which is in the repository \str{ACT4E/ACT4E-interfaces}.
\Cref{fig:Setoid-inheritance} shows their relation in an UML diagram.

\begin{marginfigure}
  \includesag{setoid-finiteset}

  \caption{UML inheritance diagram}
  \label{fig:Setoid-inheritance}
\end{marginfigure}

This is the interface for \Setoid:

\begin{widepar}
\classsource{Setoid}{min_size=0}
\end{widepar}

The class \Setoid  derives from \classname{ABC}, which means \emph{abstract base class}; it tells the interpreter that some of the methods of the class will have to be implemented by the subclasses.
This is the equivalent of the ``virtual'' methods in C++.
The methods that need to be implemented are marked by a decorator \pystr|@abstractmethod|.
For \Setoid, we ask that the implementer implements the \funcname{contains} function, and they can optionally implement \funcname{equal}.

This is the semantics of the methods:

\begin{compactitem}
  \item The method \funcname{contains} checks if an element is part of this set.
  \item The method \funcname{equal} checks if two elements are the same.
  The default way to do this is to use Python's equality operator (which calls the \pystr|__equal__| method of the class of the first object); later we will see cases in which we might want to choose something different
\end{compactitem}


The code contains also typing annotations.
The symbol \classname{Element}, like the others we will see later, such as \classname{Object} and \classname{Morphism}, are simple aliases to Python's \classname{object} class; which means that they are not specifying the type at all.
However, they are useful for intuition.
The latest versions of Python have supported typing annotations with generics, so we could have chosen to use those and have more accurate typing, however we want these exercises to be accessible to all.


This is the interface for \classname{EnumerableSet}:

\classsource{EnumerableSet}{}

This is the interface for \FiniteSet:

\classsource{FiniteSet}{}

The additional method:
\begin{compactitem}
  \item The method \funcname{elements} returns a Python \classname{Iterator}: this is something that you can iterate.
\end{compactitem}



The class inherits from \Setoid and add some methods:

The additional method:
\begin{compactitem}
  \item The method \funcname{size} returns the size of the set.
\end{compactitem}

You will have to implement the \FiniteSet class as part of the exercise.


\subsection*{Representation}

We have defined file formats for all the structures to be used in the exercises.
These are based on YAML\@.

\margindatafilefig{set1code}{set1.finset.yaml}{fig:set1}

The file format for \FiniteSet is shown in \cref{fig:set1}.



The file represents a dictionary with only one field called \pystr|elements|, which contains a list of elements.
YAML can represent most primitive data format of Python, as well as lists and dictionaries.

\begin{gradedexercise}[\exname{TestFiniteSetRepresentation}]
  \label{ex:setrepr}
  The first exercise is to implement the methods that read and write from this file format.
  You have to implement the following interface, \classname{FiniteSetRepresentation}:

  \classsource{FiniteSetRepresentation}{min_size=0}

  You also have to implement a concrete subclass of \FiniteSet.
\end{gradedexercise}

\subsection{Walk-through for first exercise}

We are going to solve this exercise together.

We assume that you have checked out the repository as explained in the setup section.

Of all the files in the repository, we only need the following for now:
%
%\begin{minted}[autogobble]{console}
%. src/
%.   act4e_solutions/
%.     __init__.py
%. Makefile
%\end{minted}
%

\includesag{dirtree-relevant}


We can start by checking if this is a valid solution. There is a recipe for this in the \files{Makefile}.
Type this:

\begin{console}
  > make check-TestFiniteSetRepresentation
\end{console}

Here \exname{TestFiniteSetRepresentation} is the code name for the exercise. You can check other exercises by changing the name.

This will fail; it will complain saying that it didn't even find any code implementing the exercise.


Create a file called \files{first.py} in the \files|src/act4e_solutions| directory.
This file will contain the implementation of the classes.

For now we are just going to add non-functional code for the classes.

\begin{widepar}
\visualizemodule{act4e_book_examples.empty}{}
\end{widepar}
Now modify \files|__init__.py| to import all the symbols from the \files{first} module.

\begin{minted}{python}
from .first import *
\end{minted}

At this point you can check again by typing:

\begin{console}
  > make check-TestFiniteSetRepresentation
\end{console}

The program will tell you that it found the code supposedly implementing the function,
but that the tests failed. All of our functions returned \pystr{None}.

At this point we need to implement the rest of the code.

For example, this is a valid implementation of \FiniteSet.

\visualizemodule{act4e_book_examples.f1}{}


To read and write data, we use the \pystr{yaml} library.

\visualizemodule{act4e_book_examples.f2}{}

With this code, the tests should pass. Try again to run

\begin{console}
  > make check-TestFiniteSetRepresentation
\end{console}

Note that the types used by the function \funcname{save} of \classname{MyFiniteSetRepresentation} is \FiniteSet,
not \classname{MyFiniteSet}. The method must be able to work for \emph{any} implementation of  \FiniteSet,
not just yours. In fact, the tester will try to call that function with a different implementation.

Note that the implementation above uses this line to get the elements:
\begin{minted}{python}
all_elements = sorted(f.elements())
\end{minted}
This is correct because it is using the method \funcname{elements} that all implementations of  \FiniteSet
need to have. What could be wrong is using code like the following:
\begin{minted}{python}
all_elements = sorted(f._elements)
\end{minted}
This code accesses the attribute \pystr|_elements| of the class \classname{MyFiniteSet}.
It will not work with other implementations. In fact, the tests will fail.

