% !TEX root = chapter-standalone.tex

\section{Moore machines as a semicategory}
\label{sec:moore-semicategorically}

    \begin{marginfigure}
        \centering
        \includesag{10_moore_comp_seq_bis}
        \caption{Composition of Moore machines (second version).}
        \label{fig:comp_moore_2}
    \end{marginfigure}

    We will now make a new definition of Moore machines in such a way that these Moore machines form a semicategory.  For this we use the category $\SetL$ and the auxiliary structures discussed in \cref{sec:SetL}. 

Concretely, we say now that a Moore machine is a tuple
        \begin{equation}
        \label{eq:moore-tuple-improved}
        \tupp{\prin,\prstL,\prout,\prdyn,\prreadout,\prstart},
    \end{equation}
where the state space $\prstL$ is now an object of $\SetL$ (rather than just a set), $\prdyn$ is a function of the type
\begin{equation}
\prdyn \colon \prin \cartprod \tupset(\prstL) \mto \tupset(\prstL),
\end{equation}
$\prreadout$ is a function
\begin{equation}
\prreadout \colon \tupset(\prstL) \mto \prout, 
\end{equation}
and $\prstart \setin \tupset(\prstL)$. 


\subsection{Composing Moore machines}
 
How do our new Moore machines compose? 

Suppose we are given Moore machines 
\begin{equation}
        \label{eq:moore-mora}
        \mora = \tupp{\prin_{\mora},\prstL_{\mora},\prout_{\mora},\prdyn_{\mora},\prreadout_{\mora},\prstart_{\mora}}
    \end{equation}
    %
    and
    %
    \begin{equation}
        \label{eq:moore-morb}
        \morb = \tupp{\prin_{\morb},\prstL_{\morb},\prout_{\morb},\prdyn_{\morb},\prreadout_{\morb},\prstart_{\morb}},
    \end{equation}
    such that~$\prout_{\mora} = \prin_{\morb}$.
We define their composition to be
\begin{equation}
\mora \mthen \morb = \tupp{\prin_{\mora \mthen \morb},\prstL_{\mora \mthen \morb},\prout_{\mora \mthen \morb},\prdyn_{\mora \mthen \morb},\prreadout_{\mora \mthen \morb},\prstart_{\mora \mthen \morb}}
\end{equation}
where
    %
    \begin{equation}
        \label{eq:moore-comp-naive-1}
        \begin{aligned}
            \prin_{\mora\mthen\morb}    & \definedas \prin_{\mora}, \\
            \prstL_{\mora\mthen\morb}    & \definedas \prstL_{\mora} \listconcat  \prstL_{\morb}, \\
             \prout_{\mora\mthen\morb}   & \definedas \prout_{\morb} \\
            \prstart_{\mora\mthen\morb} & \definedas \cohm_{\prstL_{\mora}, \prstL_{\morb}}( \tupp{\prstart_{\mora}, \prstart_{\morb}}),
        \end{aligned}
    \end{equation}
and $\prdyn_{\mora \mthen \morb}$ and $\prreadout_{\mora \mthen \morb}$ are defined as follows.    
 
For readability, set $\cohm_{{\mora}, {\morb}} \definedas \cohm_{\prstL_{\mora}, \prstL_{\morb}}$. 
We define $\prdyn_{\mora \mthen \morb}$ to be the composite

 \begin{widepar}
    \equationsag{commutative_moore}{eq:commutative_moore}
 \end{widepar}
 
 where
    %
    \begin{equation}
    \label{eq:moore-comp-good-2}
    \defmapperiodset{
        \mord_{\mora\mthen\morb}
        }{
        \prin_{\mora} \cartprod (\tupset(\prstL_\mora)\cartprod \tupset(\prstL_\morb))
        }{
        \tupset(\prstL_\mora)\cartprod \tupset(\prstL_\morb)
        }{
        \tup{u,\tup{x_{\mora},{x_{\morb}}}}
        }{
        \tup
        {
            \prdyn_{\mora} (u, x_{\mora}),
            {
                    \prdyn_{\morb}(\prreadout_{\mora}(x_{\mora}), x_{\morb})
                }}
        }
    \end{equation}

   \
   
   \
   
And we define $\prreadout_{\mora \mthen \morb}$ as the composite 
   
\equationsag{commutative_moore_ro}{eq:commutative_moore_ro}

where
    \begin{equation}
        \label{eq:moore-comp-good-3}
        \defmapperiodset{
        \more_{\mora\mthen\morb}
        }{
        \tupset(\prstL_\mora)\cartprod \tupset(\prstL_\morb)
        }{
        \prout_{\morb}
        }{
        \tup{{x_{\mora}}, {x_{\morb}}}
        }{
        \prreadout_{\morb}(x_{\morb})
        }
    \end{equation}
    
    
  \subsection{Composition is associative}
  
  We show now that the above-defined composition does in fact obey the associative law. 
  Let three composable Moore machines $\mora$, $\morb$, and $\morc$ be given. We check that each of the six entries in the definition \cref{eq:moore-tuple-improved} coincide for  $(\mora \mthen \morb) \mthen \morc$ and $\mora \mthen (\morb \mthen \morc)$. 
  
First off, we clearly have 
\begin{equation}
\prin_{(\mora \mthen \morb)\mthen \morc}  = \prin_{\mora} =\prin_{\mora \mthen (\morb \mthen \morc)}
\end{equation}
and 
\begin{equation}
\prout_{(\mora \mthen \morb)\mthen \morc}  =\prout_\morc = \prout_{\mora \mthen (\morb \mthen \morc)}.
\end{equation}
Furthermore, 
\begin{equation}
\prstL_{(\mora \mthen \morb)\mthen \morc} =  (\prstL_{\mora} \listconcat \prstL_{\morb}) \listconcat  \prstL_{\morc}  =  \prstL_{\mora} \listconcat (\prstL_{\morb} \listconcat  \prstL_{\morc}) =\prstL_{\mora \mthen (\morb \mthen \morc)}
\end{equation}
since concatenation of lists is associative. 

Next we check that 
\begin{equation}
\prstart_{(\mora \mthen \morb)\mthen \morc}  =\prstart_{\mora \mthen (\morb \mthen \morc)}.
\end{equation}
One the one hand
\begin{align*}
\prstart_{(\mora \mthen \morb)\mthen \morc} &= \cohm_{\mora \mthen \morb, \morc}( \tupp{\prstart_{\mora \mthen \morb}, \prstart_{\morc}}) \\
& = \cohm_{\mora \mthen \morb, \morc}( \tupp{ \cohm_{\mora, \morb}( \tupp{\prstart_{\mora}, \prstart_{\morb}}), \prstart_{\morc}})
\end{align*}
while on the other hand 
\begin{align*}
\prstart_{\mora \mthen (\morb \mthen \morc)} &= \cohm_{\mora,\morb \mthen \morc}( \tupp{\prstart_{\mora}, \prstart_{\morb \mthen \morc}}) \\
& = \cohm_{\mora,\morb \mthen \morc}( \tupp{\prstart_{\mora}, \cohm_{\morb, \morc}( \tupp{\prstart_{\morb}, \prstart_{\morc}})}).
\end{align*}


\todotext{CONTINUE WRITING HERE}
\
  
  \
  
    %
    With this definition we can define the semicategory~\Moore of Moore machines.
    %
    \begin{definition}[\Moore]
        \label{def:Moore}
        The \emph{semicategory of Moore machines} \Moore is given by:
        \begin{enumerate}
            \item \emph{Objects:} objects of \Set.
            \item \emph{Morphisms:}
                  A morphism is a tuple
                  \begin{equation}
                      \mora = \tupp{\prin_{\mora},\prstL_{\mora},\prout_{\mora},\prdyn_{\mora},\prreadout_{\mora},\prstart_{\mora}},
                  \end{equation}
                  where:
                  \begin{itemize}
                      \item $\prstL_{\mora}$ is object of \SetL;
                      \item $\prin_{\mora}$ and~$\prout_{\mora}$ are sets (objects of \Set);
                      \item $ \prdyn_{\mora} \colon \prin_{\mora}\cartprod \tupset(\prstL_\mora) \mtoin\Set  \tupset(\prstL_\mora)$;
                      \item $ \prreadout_{\mora} \colon \tupset(\prstL_{\mora})  \mtoin\Set \prout_{\mora}$.
                  \end{itemize}
            \item \emph{Composition:}
                  Composition is given by \cref{eq:moore-comp-good-1,eq:moore-comp-good-2,eq:moore-comp-good-3}.
        \end{enumerate}
    \end{definition}
    %
 

    We first check associativity for the dynamics.
    First, we represent the situation graphically via a commutative diagram:
    %
    \equationsag{commutative_moore_assoc_1}{eq:commutative_moore_assoc_1}
    where
    \begin{widepar}
        \begin{equation*}
            \label{eq:assoc_moore_1}
            \begin{aligned}
                \prdyn'_{(\mora\mthen\morb)\mthen \morc}\colon \prin_{\mora}\cartprod ((\tupset(\prstL_{\mora}) \cartprod \tupset(\prstL_{\morb}))\cartprod \tupset(\prstL_{\morc})) & \to (\tupset(\prstL_{\mora}) \cartprod \tupset(\prstL_{\morb}))\cartprod \tupset(\prstL_{\morc}) \\
                \tup{u, \tup{\tup{x_{\mora},x_{\morb}},x_\morc}}                                                                                                                     & \mapsto \tup{\prdyn'_{\mora \mthen \morb}(u,\tup{x_\mora, x_\morb}),\prdyn'_{\morc}(\prreadout_{\mora \mthen \morb}(\tup{x_\mora,x_\morb}),x_\morc)} \\
                                                                                                                                                                                     & =\tup{\prdyn'_\mora(u,x_\mora), \prdyn'_\morb(\prreadout_\mora(x_\mora),x_\morb), \prdyn'_\morc(\prreadout_\morb(x_\morb),x_\morc)}.
            \end{aligned}
        \end{equation*}
    \end{widepar}
    %
    On the other hand, one has:
    \equationsag{commutative_moore_assoc_2}{eq:commutative_moore_assoc_2}
    %
    where
    \begin{widepar}
        \begin{equation*}
            \label{eq:assoc_moore_2}
            \begin{aligned}
                \prdyn'_{\mora\mthen(\morb\mthen \morc)}\colon \prin_{\mora}\cartprod (\tupset(\prstL_{\mora}) \cartprod (\tupset(\prstL_{\morb})\cartprod \tupset(\prstL_{\morc}))) & \to \tupset(\prstL_{\mora}) \cartprod (\tupset(\prstL_{\morb})\cartprod \tupset(\prstL_{\morc})) \\
                \tup{u, \tup{x_{\mora},\tup{x_{\morb},x_\morc}}}                                                                                                                     & \mapsto \tup{\prdyn'_{\mora}(u,x_\mora),\prdyn'_{\morb\mthen \morc}(\prreadout_{\mora}({x_\mora}),\tup{x_\morb,x_\morc})} \\
                                                                                                                                                                                     & =\tup{\prdyn'_\mora(u,x_\mora), \prdyn'_\morb(\prreadout_\mora(x_\mora),x_\morb), \prdyn'_\morc(\prreadout_\morb(x_\morb),x_\morc)}.
            \end{aligned}
        \end{equation*}
    \end{widepar}
    %
    \todo{do diagrams for readout}
    Finally, one can check associativity of the readout:
    \begin{equation*}
        \label{eq:assoc_moore_3}
        \defmapcommaset{
        \prreadout'_{(\mora \mthen \morb)\mthen \morc}}
        {(\tupset(\prstL_{\mora}) \cartprod \tupset(\prstL_{\morb}))\cartprod \tupset(\prstL_{\morc})}
        {\prout_\morc}
        {\tup{\tup{x_\mora,x_\morb},x_\morc}}
        { \prreadout_\morc(x_\morc)}
    \end{equation*}
    and
    \begin{equation*}
        \label{eq:assoc_moore_4}
        \defmapperiodset{
        \prreadout'_{\mora \mthen (\morb\mthen \morc)}
        }{
        \tupset(\prstL_{\mora}) \cartprod (\tupset(\prstL_{\morb})\cartprod \tupset(\prstL_{\morc}))
        }{
        \prout_\morc
        }{
        \tup{x_\mora,\tup{x_\morb,x_\morc}}
        }{
        \prreadout_\morc(x_\morc)
        }
    \end{equation*}
