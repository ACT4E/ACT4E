% !TEX root = chapter-standalone.tex

\section{Moore machines, $\Cat{Set*}$ version}
\label{sec:moore-semicategorically}

\begin{marginfigure}
    \centering
    \includesag{10_moore_comp_seq_bis}
    \caption{Composition of Moore machines (second version).}
    \label{fig:comp_moore_2}
\end{marginfigure}

We will now make a new definition of Moore machines in such a way that these Moore machines form a semicategory.
For this we use the category~$\SetL$ and the auxiliary structures discussed in \cref{sec:SetL}.

\begin{definition}[Moore machine, 2nd definition]
    \label{def:moore_machine}
    A Moore machine is a tuple
    \begin{equation}
        \label{eq:moore-tuple-improved}
        \tupp{\prin,\prstL,\prout,\prdyn,\prreadout,\prstart},
    \end{equation}
    where the state space $\prstL$ is now an object of $\SetL$ (rather than just a set), $\prdyn$ is a function of the type
    \begin{equation}
        \prdyn \colon \prin \cartprod \tupset(\prstL) \mto \tupset(\prstL),
    \end{equation}
    $\prreadout$ is a function
    \begin{equation}
        \prreadout \colon \tupset(\prstL) \mto \prout,
    \end{equation}
    and $\prstart \setin \tupset(\prstL)$.
\end{definition}

\subsection{Composing Moore machines}
\label{sec:composing-moore-machines}

How do our new Moore machines compose?

Suppose we are given Moore machines
\begin{equation}
    \label{eq:moore-mora-new}
    \mora = \tupp{\prin_{\mora},\prstL_{\mora},\prout_{\mora},\prdyn_{\mora},\prreadout_{\mora},\prstart_{\mora}}
\end{equation}
%
and
%
\begin{equation}
    \label{eq:moore-morb-new}
    \morb = \tupp{\prin_{\morb},\prstL_{\morb},\prout_{\morb},\prdyn_{\morb},\prreadout_{\morb},\prstart_{\morb}},
\end{equation}
such that~$\prout_{\mora} = \prin_{\morb}$.
We define their composition to be
\begin{equation}
    \label{eq:moore-morab-comp}
    \mora \mthen \morb = \tupp{\prin_{\mora \mthen \morb},\prstL_{\mora \mthen \morb},\prout_{\mora \mthen \morb},\prdyn_{\mora \mthen \morb},\prreadout_{\mora \mthen \morb},\prstart_{\mora \mthen \morb}}
\end{equation}
where
%
\begin{equation}
    \label{eq:moore-comp-naive-new}
    \begin{aligned}
        \prin_{\mora\mthen\morb}    & \definedas \prin_{\mora}, \\
        \prstL_{\mora\mthen\morb}   & \definedas \prstL_{\mora} \listconcat  \prstL_{\morb}, \\
        \prout_{\mora\mthen\morb}   & \definedas \prout_{\morb}, \\
        \prstart_{\mora\mthen\morb} & \definedas \cohm_{\prstL_{\mora}, \prstL_{\morb}}( \tupp{\prstart_{\mora}, \prstart_{\morb}}),
    \end{aligned}
\end{equation}
and $\prdyn_{\mora \mthen \morb}$ and $\prreadout_{\mora \mthen \morb}$ are defined as follows.

For readability, set~$\cohm_{{\mora}, {\morb}} \definedas \cohm_{\prstL_{\mora}, \prstL_{\morb}}$.
We define~$\prdyn_{\mora \mthen \morb}$ to be the composite

\begin{widepar}
    \equationsag{commutative_moore}{eq:commutative_moore}
\end{widepar}

where
%
\begin{equation}
    \label{eq:moore-comp-good-2}
    \defmapperiodset{
    \prdyn'_{\mora\mthen\morb}
    }{
    \prin_{\mora} \cartprod (\tupset(\prstL_\mora)\cartprod \tupset(\prstL_\morb))
    }{
    \tupset(\prstL_\mora)\cartprod \tupset(\prstL_\morb)
    }{
    \tup{u,\tup{x_{\mora},{x_{\morb}}}}
    }{
    \tup
    {
        \prdyn_{\mora} (u, x_{\mora}),
        {
                \prdyn_{\morb}(\prreadout_{\mora}(x_{\mora}), x_{\morb})
            }}
    }
\end{equation}

And we define~$\prreadout_{\mora \mthen \morb}$ as the composite
%
\equationsag{commutative_moore_ro}{eq:commutative_moore_ro}
%
where $\pi_2$ denotes the projection onto the second component of the cartesian product.

%where
%    \begin{equation}
%        \label{eq:moore-comp-good-3}
%        \defmapperiodset{
%        \prreadout'_{\mora\mthen\morb}
%        }{
%        \tupset(\prstL_\mora)\cartprod \tupset(\prstL_\morb)
%        }{
%        \prout_{\morb}
%        }{
%        \tup{{x_{\mora}}, {x_{\morb}}}
%        }{
%        \prreadout_{\morb}(x_{\morb})
%        }
%    \end{equation}

\subsection{Composition is associative}

We show now that the above-defined composition does in fact obey the associative law.
Let three composable Moore machines~$\mora$,~$\morb$, and~$\morc$ be given.
We check that each of the six entries in the definition \cref{eq:moore-tuple-improved} coincide for~$(\mora \mthen \morb) \mthen \morc$ and~$\mora \mthen (\morb \mthen \morc)$.

First off, we clearly have
\begin{equation*}
    \prin_{(\mora \mthen \morb)\mthen \morc}  = \prin_{\mora} =\prin_{\mora \mthen (\morb \mthen \morc)}
\end{equation*}
and
\begin{equation*}
    \prout_{(\mora \mthen \morb)\mthen \morc}  =\prout_\morc = \prout_{\mora \mthen (\morb \mthen \morc)}.
\end{equation*}
Furthermore,
\begin{equation*}
    \prstL_{(\mora \mthen \morb)\mthen \morc} =  (\prstL_{\mora} \listconcat \prstL_{\morb}) \listconcat  \prstL_{\morc}  =  \prstL_{\mora} \listconcat (\prstL_{\morb} \listconcat  \prstL_{\morc}) =\prstL_{\mora \mthen (\morb \mthen \morc)}
\end{equation*}
since concatenation of lists is associative.

Next we check that
\begin{equation*}
    \prstart_{(\mora \mthen \morb)\mthen \morc}  =\prstart_{\mora \mthen (\morb \mthen \morc)}.
\end{equation*}
On the one hand
\begin{align*}
    \prstart_{(\mora \mthen \morb)\mthen \morc} & = \cohm_{\mora \mthen \morb, \morc}( \tupp{\prstart_{\mora \mthen \morb}, \prstart_{\morc}}) \\
                                                & = \cohm_{\mora \mthen \morb, \morc}( \tupp{ \cohm_{\mora, \morb}( \tupp{\prstart_{\mora}, \prstart_{\morb}}), \prstart_{\morc}})
\end{align*}
while on the other hand
\begin{align*}
    \prstart_{\mora \mthen (\morb \mthen \morc)} & = \cohm_{\mora,\morb \mthen \morc}( \tupp{\prstart_{\mora}, \prstart_{\morb \mthen \morc}}) \\
                                                 & = \cohm_{\mora,\morb \mthen \morc}( \tupp{\prstart_{\mora}, \cohm_{\morb, \morc}( \tupp{\prstart_{\morb}, \prstart_{\morc}})}).
\end{align*}
It follows from \cref{lem:coh-isos-compatible} that these are equal.

We turn now to showing that~$\prdyn_{\mora \mthen \morb, \morc} = \prdyn_{\mora, \morb \mthen \morc}$.

On the one hand, we have the following commutative diagram
\begin{widepar}
    \equationsag{commutative_moore_assoc_1}{eq:commutative_moore_assoc_1}
\end{widepar}
where
\begin{widepar}
    \begin{equation*}
        \label{eq:assoc_moore_1}
        \begin{aligned}
            \prdyn''_{(\mora\mthen\morb)\mthen \morc}\colon \prin_{\mora}\cartprod ((\tupset(\prstL_{\mora}) \cartprod \tupset(\prstL_{\morb}))\cartprod \tupset(\prstL_{\morc})) & \to (\tupset(\prstL_{\mora}) \cartprod \tupset(\prstL_{\morb}))\cartprod \tupset(\prstL_{\morc}) \\
            \tup{u, \tup{\tup{x_{\mora},x_{\morb}},x_\morc}}                                                                                                                      & \mapsto \tup{\prdyn'_{\mora \mthen \morb}(u,\tup{x_\mora, x_\morb}),\prdyn_{\morc}(\prreadout_{\mora \mthen \morb}(\tup{x_\mora,x_\morb}),x_\morc)} \\                                                                                                                                                                & =\tup{ \tup{ \prdyn_\mora(u,x_\mora), \prdyn_\morb(\prreadout_\mora(x_\mora),x_\morb) }, \prdyn_\morc(\prreadout_\morb(x_\morb),x_\morc)}.
        \end{aligned}
    \end{equation*}
\end{widepar}
%
On the other hand, we have the commutative diagram
\begin{widepar}
    \equationsag{commutative_moore_assoc_2}{eq:commutative_moore_assoc_2}
\end{widepar}
where
\begin{widepar}
    \begin{equation*}
        \label{eq:assoc_moore_2}
        \begin{aligned}
            \prdyn''_{\mora\mthen(\morb\mthen \morc)}\colon \prin_{\mora}\cartprod (\tupset(\prstL_{\mora}) \cartprod (\tupset(\prstL_{\morb})\cartprod \tupset(\prstL_{\morc}))) & \to \tupset(\prstL_{\mora}) \cartprod (\tupset(\prstL_{\morb})\cartprod \tupset(\prstL_{\morc})) \\
            \tup{u, \tup{x_{\mora},\tup{x_{\morb},x_\morc}}}                                                                                                                      & \mapsto \tup{\prdyn_{\mora}(u,x_\mora),\prdyn'_{\morb\mthen \morc}(\prreadout_{\mora}({x_\mora}),\tup{x_\morb,x_\morc})} \\
                                                                                                                                                                                  & =\tup{\prdyn_\mora(u,x_\mora), \tup{\prdyn_\morb(\prreadout_\mora(x_\mora),x_\morb), \prdyn_\morc(\prreadout_\morb(x_\morb),x_\morc)}}.
        \end{aligned}
    \end{equation*}
\end{widepar}
%
Observe that~$\prdyn''_{(\mora \mthen \morb) \mthen \morc} =  (\catid_{\prin_{\mora}} \funcprod \alpha) \mthen \prdyn_{\mora \mthen (\morb \mthen \morc)} \mthen (\catid_{\prin_{\mora}} \funcprod \alpha)^{-1}$.
Substituting this equation into \cref{eq:commutative_moore_assoc_2} and applying \cref{lem:coh-isos-compatible} we find that
%
\begin{widepar}
    \equationsag{commutative_moore_assoc_3}{eq:commutative_moore_assoc_3}
\end{widepar}
%
is commutative.
Comparing this diagram with \cref{eq:commutative_moore_assoc_1} (and using that in both diagrams, the vertical composites are isomorphisms), we conclude that
\begin{equation*}
    \prdyn_{\mora \mthen \morb, \morc} = \prdyn_{\mora, \morb \mthen \morc},
\end{equation*}
as was to be shown.

Finally, we need to consider the readout functions.
We leave it as an exercise to show that~$\prreadout_{\mora \mthen \morb, \morc} = \prreadout_{\mora, \morb \mthen \morc}$.

\begin{exercise}[Readout is associative]
    Show that~$\prreadout_{\mora \mthen \morb, \morc} = \prreadout_{\mora, \morb \mthen \morc}$
\end{exercise}
\begin{solution}
    \todo{Write solution.}
\end{solution}

\todotext{\bernina: - spell this out so that it is no longer left as an exercise}

%    We have
%    \begin{equation*}
%        \label{eq:assoc_moore_3}
%        \defmapcommaset{
%        \prreadout'_{(\mora \mthen \morb)\mthen \morc}}
%        {(\tupset(\prstL_{\mora}) \cartprod \tupset(\prstL_{\morb}))\cartprod \tupset(\prstL_{\morc})}
%        {\prout_\morc}
%        {\tup{\tup{x_\mora,x_\morb},x_\morc}}
%        { \prreadout_\morc(x_\morc)}
%    \end{equation*}
%    and
%    \begin{equation*}
%        \label{eq:assoc_moore_4}
%        \defmapperiodset{
%        \prreadout'_{\mora \mthen (\morb\mthen \morc)}
%        }{
%        \tupset(\prstL_{\mora}) \cartprod (\tupset(\prstL_{\morb})\cartprod \tupset(\prstL_{\morc}))
%        }{
%        \prout_\morc
%        }{
%        \tup{x_\mora,\tup{x_\morb,x_\morc}}
%        }{
%        \prreadout_{\morb \mthen \morc}(x_\morc) = \prreadout_{\morc}(x_\morc)
%        }
%    \end{equation*}
%

In summary, now we have the following semicategory \Moore of Moore machines.
%
\begin{definition}[\Moore]
    \label{def:Moore}
    The \emph{semicategory of Moore machines} \Moore is given by:
    \begin{enumerate}
        \item \emph{Objects:} objects of \Set.
        \item \emph{Morphisms:}
              A morphism is a tuple
              \begin{equation*}
                  \mora = \tupp{\prin_{\mora},\prstL_{\mora},\prout_{\mora},\prdyn_{\mora},\prreadout_{\mora},\prstart_{\mora}},
              \end{equation*}
              where
              \begin{itemize}
                  \item $\prstL_{\mora}$ is object of \SetL;
                  \item $\prin_{\mora}$ and~$\prout_{\mora}$ are sets (objects of \Set);
                  \item $ \prdyn_{\mora} \colon \prin_{\mora}\cartprod \tupset(\prstL_\mora) \mtoin\Set  \tupset(\prstL_\mora)$;
                  \item $ \prreadout_{\mora} \colon \tupset(\prstL_{\mora})  \mtoin\Set \prout_{\mora}$.
              \end{itemize}
        \item \emph{Composition:}
              as in \cref{sec:composing-moore-machines}.
    \end{enumerate}
\end{definition}
%

