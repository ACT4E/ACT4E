% !TEX root = chapter-standalone.tex

\section{Moore machines, first version}
\label{sec:moore-machines}

%\linkvideo{spring2021-actions:semi-actions:processes} % Signals and processes

\linkvideo{spring2021-actions:semi-actions:processes:moore} % Moore machines

In the following we consider \textbf{Moore machines}\footnote{They are named after Edward F.
    Moore.
}, which are a type of basic model for describing certain dynamical systems.
Its characteristic features are:
\begin{itemize}
    \item a \textbf{state space} which describes all possible states that the system can possibly be in;
    \item an \textbf{input space} and an \textbf{output space};
    \item a \textbf{dynamics} which describes how, given an input, the system's state changes according to that input;
    \item a \textbf{read-out} which relates the current state of the system to the output space.
\end{itemize}
%
We are in particular interested in the ways that such a machine can transform a sequence of inputs into a sequence of outputs.

\subsection{A first mathematical model}

Our first version for formalizing the idea of a \SY{Moore machine} looks as follows.
We model the input space, state space, and output space as sets~$\prin$,~$\prst$, and~$\prout$ respectively, and we model the dynamics and read-out as functions
\begin{equation}
    \label{eq:moore-1}
    \begin{cases}
        \prdyn \colon \prin \cartprod \prst \sto \prst, \\
        \prreadout \colon \prst \sto \prout.
    \end{cases}
\end{equation}

%    As introduced in \cref{sec:actions}, we can apply currying to~$\prdyn$, to obtain a map from inputs to endomorphisms on the states:
%    %
%    \begin{equation}
%        \label{eq:moore-1-endo}
%        \begin{cases}
%            \prdyn \colon \prin \sto \Endof \prst, \\
%            \prreadout \colon \prst \sto \prout.
%        \end{cases}
%    \end{equation}
%    %

We will also choose an element~$\prstart \setin \prst$ of the state space as an initial state; we will use this when specifying how a \SY{Moore machine} acts on sequences of inputs.

Thus, in total, a \SY{Moore machine} is specified by a tuple of the following type:
\begin{equation}
    \label{eq:moore-tuple}
    \tupp{\prin,\prst,\prout,\prdyn,\prreadout,\prstart}.
\end{equation}

\todotext{\alphubel: @Gioele: Provide a simple example here to illustrate}

\subsection{Moore machines acting on sequences}

Given a \SY{Moore machine}~$\mora = \tup{\prin, \prout, \prst, \prdyn, \prreadout, \prstart}$, the following is a standard way to think of it as acting on a sequence of inputs, transforming it into a sequence of outputs.

Given an infinite sequence of inputs~$\prineln{0}, \prineln{1}, \prineln{2}, \ldots $, we use the following recipe
\begin{equation}
    \label{eq:Moore-action-recursion}
    \begin{cases}
        \prsteln{k+1} = \prdyn(\prineln{k}, \prsteln{k}) \\
        \prouteln{k\phantom{+1}}   = \prreadout(\prsteln{k}),
    \end{cases}
\end{equation}
to produce an infinite sequence~$\prouteln{0}, \prouteln{1}, \prouteln{2}, \ldots$ of outputs.
For the very first step, when~$k = 0$, we need the initial state~$\prsteln{0} = \prstart$ in order to compute~$\prsteln{1} = \prdyn(\prineln{0}, \prsteln{0})$ and~$\prouteln{0} = \prreadout(\prsteln{0})$.

\todotext{\alphubel: @JL: Continue the simple example above to illustrate}

An infinite sequence~$\prineln{0}, \prineln{1}, \prineln{2}, \ldots$ of elements of~$\prin$ can be also thought as a function~$\prinel \colon \natnumbers \to \prin$ with~$\prinel(0) = \prineln{0}, \prinel(1) = \prineln{2}, \prinel(2) = \prineln{3}, \ldots$ \etc
To denote an infinite sequence of elements of $\prin$ we use the two notations $\prin^{\natnumbers}$ and $\streamsof\prin$:
\begin{equation}
    \streamsof \setA \definedas  (\natnumbers \to \setA) = \setA^{\natnumbers}.
    % leave like this
\end{equation}

For a fixed \SY{Moore machine}~$\mora$, the recipe \cref{eq:Moore-action-recursion} defines a function~$\act_\mora$ which maps any given sequence~$\prinel$ of elements of~$\prin$ to a corresponding sequence~$\proutel = \act_\mora(\prinel)$ of elements of~$\prout$.
In other words, from~$\tup{\prin, \prout, \prst, \prdyn, \prreadout, \prstart}$ and \cref{eq:Moore-action-recursion} we obtain
\begin{equation}
    \act_\mora \colon \streamsof\prin  \to \streamsof\prout.
\end{equation}
We think of this function~$\act_\mora$ as describing the external behavior of the \SY{Moore machine}~$\mora$, because it encodes what is externally observable in terms of how the \SY{Moore machine} is used to relate inputs to outputs.

% \begin{remark}
%     As an aside, we note that in concrete applications it might be the case that we do not actually know a precise model of a Moore machine in terms of the data \cref{eq:moore-tuple}, but we can still observe what it does when we feed it inputs.
%     And in some cases this external behavior is all we really care about.
% \end{remark}
% \todotext{Is the remark above needed or relevant?}

\subsection{Composing Moore machines}

Let us consider composing \SY{Moore machines} serially by letting the output of one machine be the input of the next.
We'd like the result to again be a \SY{Moore machine}.

\begin{marginfigure}
    \centering
    \includesag{10_moore_comp_seq}
    \caption{Composition of \SY{Moore machines} (first version).}
    \label{fig:comp_moore_1}
\end{marginfigure}

In other words, given Moore machines
%
\begin{equation}
    \label{eq:moore-mora}
    \mora = \tupp{\prin_{\mora},\prst_{\mora},\prout_{\mora},\prdyn_{\mora},\prreadout_{\mora},\prstart_{\mora}}
\end{equation}
%
and
%
\begin{equation}
    \label{eq:moore-morb}
    \morb = \tupp{\prin_{\morb},\prst_{\morb},\prout_{\morb},\prdyn_{\morb},\prreadout_{\morb},\prstart_{\morb}},
\end{equation}
with~$\prout_{\mora} = \prin_{\morb}$, we'd like to define their composition as a Moore machine
\begin{equation}
    \label{eq:moore-morab-comp}
    \morab = \tupp{\prin_{\morab},\prst_{\morab},\prout_{\morab},\prdyn_{\morab},\prreadout_{\morab},\prstart_{\morab}}.
\end{equation}
The situation is illustrated in \cref{fig:comp_moore_1}.

Here is one way to do it: we set
%
\begin{equation}
    \label{eq:moore-comp-naive-1}
    \begin{aligned}
        \prin_{\morab}    & \definedas \prin_{\mora}, \\
        \prst_{\morab}    & \definedas \prst_{\mora} \cartprod \prst_{\morb}, \\
        \prout_{\morab}   & \definedas \prout_{\morb}, \\
        \prstart_{\morab} & \definedas \tupp{\prstart_{\mora}, \prstart_{\morb}},
    \end{aligned}
\end{equation}
%
we define the composite dynamics to be
%
\begin{equation}
    \label{eq:moore-comp-naive-2}
    \defmapcommaset{
        \prdyn_{\morab}
    }{
        \prin_{\mora} \cartprod (\prst_{\mora} \cartprod \prst_{\morb})
    }{
        (\prst_{\mora} \cartprod \prst_{\morb})
    }{
        \tupp{\prinel, \tupp{\prsteln{\mora}, \prsteln{\morb}}}
    }{
        \tupp{ \prdyn_{\mora} (\prinel, \prsteln{\mora}), \prdyn_{\morb}(\prreadout_{\mora}(\prsteln{\mora}), \prsteln{\morb})}
    }
\end{equation}
%
and we define the composite readout to be
%
\begin{equation}
    \label{eq:moore-comp-naive-3}
    \defmapperiodset{
        \prreadout_{\morab}
    }{
        (\prst_{\mora} \cartprod \prst_{\morb})
    }{
        \prout_{\morb}
    }{
        \tupp{\prsteln{\mora}, \prsteln{\morb}}
    }{
        \prreadout_{\morb}(\prsteln{\morb})
    }
\end{equation}
%

This formalization works very nicely -- it models composition using the output of one machine as the input of the next, and result of composition is again a \SY{Moore machine}.

However, there is one aspect which we wish were different: this composition operation is not \SY{associative}.
It \emph{almost} is, but not quite.
We explain why below.

The reason we wish it \emph{were} \SY{associative} is that \SY{Moore machines} would then form a \SY{semicategory}, and we could integrate them nicely into the mathematics we have been developing thus far.

The culprit for associativity failing is the \SY{cartesian product} that we use to define the state space $\prst_{\mora} \cartprod \prst_{\morb}$ of a composite \SY{Moore machine} $\morab$.
Consider three composable systems~$\mora$,~$\morb$, and~$\morc$.
If we compose them in the two ways~$(\morab) \mthen \morc$ and~$\mora \mthen (\morb \mthen \morc)$, then their respective state spaces are~$(\prst_{\mora} \cartprod \prst_{\morb}) \cartprod \prst_{\morc}$ and~$\prst_{\mora} \cartprod (\prst_{\morb} \cartprod \prst_{\morc})$.
These sets are \emph{isomorphic}, but they are not equal on the nose, and hence also the \SY{Moore machines} $\morab$ and $\mora \mthen (\morb \mthen \morc)$ are very close to being equal, but are not quite.

To see why
\begin{equation}
    \label{eq:assoc-fails1}
    (\prst_{\mora} \cartprod \prst_{\morb}) \cartprod \prst_{\morc} \neq \prst_{\mora} \cartprod (\prst_{\morb} \cartprod \prst_{\morc}),
\end{equation}
recall that the elements of~$(\prst_{\mora} \cartprod \prst_{\morb}) \cartprod \prst_{\morc}$ are nested tuples of the form
\begin{equation}
    \tupp{ \tupp{\prsteln{\mora}, \prsteln{\morb}}, \prsteln{\morc} }
\end{equation}
while the elements of~$\prst_{\mora} \cartprod (\prst_{\morb} \cartprod \prst_{\morc})$ are nested tuples of the form
\begin{equation}
    \tupp{\prsteln{\mora}, \tupp{\prsteln{\morb}, \prsteln{\morc}} }.
\end{equation}

An isomorphism between the two sets is given by the following function
\begin{equation}
    \label{eq:assoc-fails2}
    \begin{aligned}
        (\prst_{\mora} \cartprod \prst_{\morb})
        \cartprod \prst_{\morc}                                           & \to \prst_{\mora} \cartprod (\prst_{\morb} \cartprod \prst_{\morc}) \\
        \tupp{ \tupp{\prsteln{\mora}, \prsteln{\morb}}, \prsteln{\morc} } & \mapsto \tupp{\prsteln{\mora}, \tupp{\prsteln{\morb}, \prsteln{\morc}} }
    \end{aligned}
\end{equation}
which simply re-brackets the tuples.

In the next section we will introduce a technical construction for defining a product similar to the \SY{cartesian product}, but which is \SY{associative} on the nose - not just ``up to an isomorphism''.
This construction will allow us to make a new, modified formalization of \SY{Moore machines} which form a bona fide \SY{semicategory}, and it will prove useful in other respects further down the road.

\begin{forslides}
    \begin{equation}
        \label{eq:moore-assoc-a}
        \mora \mthen (\morb \mthen \morc)
    \end{equation}
    %
    \begin{equation}
        \label{eq:moore-assoc-b}
        (\mora \mthen \morb) \mthen \morc
    \end{equation}
\end{forslides}