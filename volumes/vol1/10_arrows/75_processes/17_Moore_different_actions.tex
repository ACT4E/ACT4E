% !TEX root = chapter-standalone.tex

\section{Different actions of Moore machines}
\label{sec:different-actions-of-moore-machines}

Moore machines need not necessarily act in the standard way given in \cref{def:moore-standard-action-on-sequences}.
In this section, we illustrate other actions of \SY{Moore machines}.

\subsection{Changing how morphisms act}

Recall that, given a \SY{Moore machine}~$\mora = \tup{\prinL,\prstL,\proutL,\prdyn,\prreadout,\prstart}$, the standard action defined a function
\begin{equation}
    \streamsof{\prinL}  \sto \streamsof{\proutL}
\end{equation}
via solving the recursion equations
\begin{equation}
    \label{eq:moore-recursion-once-again}
    \begin{cases}
        \prsteln{k+1} = \prdyn_\mora(\prineln{k} \tupconcat \prsteln{k}) \\
        \prouteln{k}   = \prreadout_\mora(\prsteln{k}).
    \end{cases}
\end{equation}
%
One way define other actions is by changing \cref{eq:moore-recursion-once-again} to some other recipe.
It is necessary then to check that the resulting action really satisfies the condition of \cref{def:semicategory-action}.

For example, consider the recursion equations
\begin{equation}
    \label{eq:moore-new-recursion-equations}
    \begin{cases}
        \prsteln{k+1} = \prdyn_\mora(\prineln{k} \tupconcat \prsteln{k})                                                           \\
        \tilde{\prstel}_{\styleelements{k+1}} = \prdyn_\mora(\prinel_{\styleelements{k}} \tupconcat \prstel_{\styleelements{k+1}}) \\
        \prouteln{k}   = \prreadout_\mora(\tilde{\prstel}_{\styleelements{k}}).
    \end{cases}
\end{equation}
Given~$\mora = \tup{\prinL,\prstL,\proutL,\prdyn,\prreadout,\prstart}$ we can use these to define an action of~$\mora$ by interpreting the variables~$\prsteln{k}$ and $\tilde{\prstel}_\styleelements{k}$ (for all~$k \setin \natnumbers$) both as denoting elements of~$\prstL$, and setting~$\prsteln{0} = \tilde{\prstel}_\styleelements{0} = \prstart$.
The rest is analogous to how we defined the standard action:
given a sequence~$\prinel = \prineln{0}, \prineln{1}, \prineln{2}, \ldots$ we can iteratively compute from it sequences~$\prstel = \prsteln{0}, \prsteln{1}, \prsteln{2}, \ldots$ and~$\tilde \prstel = \tilde{\prstel}_\styleelements{0}, \tilde{\prstel}_\styleelements{1}, \tilde{\prstel}_\styleelements{2}, \ldots$, and then the output sequence~$\proutel = \prouteln{0}, \prouteln{1}, \prouteln{2}, \ldots$ is defined by~$\prouteln{k}   = \prreadout_\mora(\tilde{\prstel}_{\styleelements{k}})$.

\begin{example}
    \label{exa:moore-non-standard-action-on-sequences}
    Consider the same \SY{Moore machine}~$\mora$ as in \cref{exa:moore-standard-action}, but now consider the action that uses \cref{eq:moore-new-recursion-equations}, instead of the standard action.
    If we give the same input sequence as we did in \cref{exa:moore-standard-action}, what does the corresponding output sequence look like now?

    We calculate the first five entries of the output sequence.
    First, recall that~$\prinL = \prstL = \proutL = \cObj{\natnumbers}$ and
    \begin{equation}
        \defmapset{
            \prdyn_\mora
        }{
            \prinL \cprod \prstL
        }{
            \prstL
        }{
            \tup{m} \tupconcat \tup{n}
        }{
            \tup{m + n}
        }
    \end{equation}
    and
    \begin{equation}
        \defmapset{
            \prreadout_\mora
        }{
            \prstL
        }{
            \proutL
        }{
            \tup{n}
        }{
            \tup{n+1}
        }
    \end{equation}
    and~$\prstart = \tup{0}$.

    The input sequence has the form~$\prinel = \tup{1}, \tup{2}, \tup{3}, \tup{4}, \tup{5}, \ldots$.
    We first compute the first five entries of the sequences of states~$\prsolel = \prsoleln{0}, \prsoleln{1}, \prsoleln{2}, \ldots$ and~$\tilde{\prsolel} = \tilde{\prsolel}_\styleelements{0}, \tilde{\prsolel}_\styleelements{1}, \tilde{\prsolel}_\styleelements{2}, \ldots$ that solve \cref{eq:moore-new-recursion-equations}:
    \begin{align}\label{eq:moore-action-example-calc-1}
        \prsoleln{0} & = \prstart = \tup{0}, \\
        \prsoleln{1} & = \tup{1 + 0} = \tup{1}, \\
        \prsoleln{2} & = \tup{2 + 1} = \tup{3}, \\
        \prsoleln{3} & = \tup{3 + 3} = \tup{6}, \\
        \prsoleln{4} & = \tup{4 + 6} = \tup{10}
    \end{align}
    and
    \begin{align}\label{eq:moore-action-example-calc-2}
        \tilde{\prsolel}_\styleelements{0} & = \prstart = \tup{0}, \\
        \tilde{\prsolel}_\styleelements{1} & = \tup{1 + 1} = \tup{2}, \\
        \tilde{\prsolel}_\styleelements{2} & = \tup{3 + 2} = \tup{5}, \\
        \tilde{\prsolel}_\styleelements{3} & = \tup{6 + 3} = \tup{9}, \\
        \tilde{\prsolel}_\styleelements{4} & = \tup{10 + 4} = \tup{14}.
    \end{align}
    Applying~$\prreadout_\mora$ to the entries the sequence~$\tilde \prstel$, the first five entries of the output sequence are:
    \begin{align}\label{eq:moore-action-example-calc-3}
        \prouteln{0} & = \tup{0 + 1} = \tup{1}, \\
        \prouteln{1} & = \tup{2 + 1} = \tup{3}, \\
        \prouteln{2} & = \tup{5 + 1} = \tup{6}, \\
        \prouteln{3} & = \tup{9 + 1} = \tup{10}, \\
        \prouteln{4} & = \tup{14 + 1} = \tup{15}.
    \end{align}
\end{example}

\todotextjira{739}{\alphubel: @JL: Insert exercises here.}

\begin{lemma}\label{lem:moore-new-recursion-equations}
    The recursion equations \cref{eq:moore-new-recursion-equations} do indeed define a \SY{semicategory action} of \SY{Moore machines} in the sense of \cref{def:semicategory-action}.
\end{lemma}

\todotextjira{739}{\alphubel: Make a graded exercise which is to prove the above lemma.}

\subsection{Changing the signal spaces}

The action defined above using \cref{eq:moore-new-recursion-equations} differs from the standard action of \cref{sec:Moore-acting-on-sequences} in terms of how morphisms act; it defines a different map
\begin{equation}
    \Mor_\Moore \sto \Mor_\Set.
\end{equation}
However, the on the level of objects, the action stayed the same:
\begin{equation}
    \begin{aligned}
        \Obof{\Moore} & \sto \Obof{\Set} \\
        \prinL        & \mapsto \streamsof\prinL
    \end{aligned}
\end{equation}

Here we define an action which is different at the level of objects.
Namely, we now make a different choice for a map
\begin{equation}
    \funobspace{\act} \colon \Obof{\Moore} \sto \Obof{\Set}.
\end{equation}
Instead of mapping any object~$\Obja$ to the set of signals of the type~$\streamsof\Obja$, which are sequences of elements of~$\Obja$, our new action maps~$\Obja$ to the set~$\listsof\Obja$ of lists of elements of~$\Obja$.
In other words, we model \SY{Moore machines} now as taking finite lists as inputs, rather than infinite sequences.

On the level of morphisms, we will keep the recipe of the original standard action of \SY{Moore machines}.

\begin{definition}
    \label{def:moore-standard-action-on-lists}
    We define the standard action of \SY{Moore machines} on lists as follows.
    The action on object is
    \begin{equation}
        \defmapperiod{\funobspace{\act}}
        {\Obof{\Moore}}
        {\sto}
        {\Obof{\Set}}
        {\prinL}
        {\listsof{\prinL}}
    \end{equation}
    On the level of morphisms, the functions
    \begin{equation}
        \funmorspace{\act} \colon  \HomSet{\Moore}{\prinL}{\proutL} \sto \HomSet{\Set}{ \listsof{\prinL}}{\listsof{\proutL}}
    \end{equation}
    are defined via the recursion equations
    \begin{equation}
        \begin{cases}
            \prsteln{k+1} = \prdyn_\mora(\prineln{k} \tupconcat \prsteln{k}) \\
            \prouteln{k}   = \prreadout_\mora(\prsteln{k})
        \end{cases}
    \end{equation}
    analogously as for the standard action on sequences.
    The only special cases are when the empty list~$\maketypedlist{\ }{\prinL}$ is the input: then we set
    \begin{equation}
        \funmorspace{\act}(\mora)(\maketypedlist{\ }{\prinL}) = \maketypedlist{ \prreadout_\mora(\prstart_\mora) }{\proutL}
    \end{equation}
    for any \SY{Moore machine}~$\mora = \tup{\prinL,\prstL,\proutL,\prdyn,\prreadout,\prstart}$.
\end{definition}

\begin{example}
    \label{exa:moore-non-standard-action-on-lists}
    Consider the same \SY{Moore machine}~$\mora$ as in \cref{exa:moore-standard-action} and \cref{exa:moore-non-standard-action-on-sequences}, namely with~$\prinL = \prstL = \proutL = \cObj{\natnumbers}$
    and
    \begin{equation}
        \defmapset{
            \prdyn_\mora
        }{
            \prinL \cprod \prstL
        }{
            \prstL
        }{
            \tup{m} \tupconcat \tup{n}
        }{
            \tup{m + n}
        }
    \end{equation}
    and
    \begin{equation}
        \defmapset{
            \prreadout_\mora
        }{
            \prstL
        }{
            \proutL
        }{
            \tup{n}
        }{
            \tup{n+1}
        }
    \end{equation}
    and~$\prstart = \tup{0}$.

    If we take the list
    \begin{equation}
        \maketypedlist{\tup{1}, \tup{2}, \tup{3}, \tup{4}, \tup{5}}{\prinL}
    \end{equation}
    as input, then the corresponding output is
    \begin{equation}
        \maketypedlist{\tup{0}, \tup{2}, \tup{3}, \tup{6}, \tup{10}}{\proutL},
    \end{equation}
    analogous to \cref{exa:moore-standard-action}.

    If we take~$\maketypedlist{\ }{\prinL}$ as input, then the output is~$\maketypedlist{\tup{0}}{\proutL}$.
\end{example}

\todotext{\bernina: Include another example?}

\begin{lemma}\label{lem:moore-standard-action-on-lists}
    \cref{def:moore-standard-action-on-lists} defines a \SY{semicategory action}.
\end{lemma}

\todotext{\alphubel: @JL: Make a graded exercise which asks for a proof of this lemma.}
