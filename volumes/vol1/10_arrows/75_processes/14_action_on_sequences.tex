% !TEX root = chapter-standalone.tex

\section{Action on sequences}


Given a Moore machine $\mora = \tup{\prinL_\mora,\prstL_\mora,\proutL_\mora,\prdyn_\mora,\prreadout_\mora,\prstart_\mora}$
we saw that we can use it to transform a sequence of inputs $u_0, u_1, u_2, \dots$ into a sequence of outputs $y_0, y_1, y_2, \dots$ using the following recipe
\begin{equation}
    \label{eq:Moore-action-recursion-again}
    \begin{cases}
        x_{k+1} = \prdyn_\mora(u_k, x_k) \\
        y_{k}   = \prreadout_\mora(x_{k}).
    \end{cases}
\end{equation}

Rephrased mathematically, this means that \cref{eq:Moore-action-recursion-again}, together with $\mora$, defines a function $$ \act_{\mora} \colon {\prinL_\mora}^\natnumbers \to {\proutL_\mora}^\natnumbers$$ which takes any sequence  of elements of $\prinL_\mora$ and maps it to a corresponding sequence  of elements of $\proutL_\mora$.  


\begin{remark}
\label{re:moore-action-two-steps}
One way to think about the function $\act_{\mora}$ is to imagine it being calculated in two steps. 
\begin{enumerate}
\item Given a sequence $u = u_0, u_1, u_2, \dots$, there is a unique solution $s = s_0, s_1, s_2, \dots$ of the recursion $x_{k+1} = \prdyn_\mora(u_k, x_k)$ with $s_0 = \prstart_\mora$. (Clearly, this solution can be computed iteratively.) 
\item Given the solution $s$, the sequence $y = \act_{\mora}(u)$ is simply $y = s \then \prreadout_\mora$. 
\end{enumerate}
\end{remark}

\subsection{Compositionality}

\begin{proposition}
The action of Moore machines on signal sequences is compatible with Moore machine composition in the sense that
\begin{equation}
\label{eq:moore-action-compositional}
\act_{\mora \mthen \morb} = \act_\mora \mthen \act_\morb
\end{equation}
for any composable Moore machines $\mora$ and $\morb$. 
\end{proposition}

\begin{proof}
Suppose we have Moore machines 
\begin{equation}
    \label{eq:moore-mora-3rd}
    \mora = \tupp{\prinL_{\mora},\prstL_{\mora},\proutL_{\mora},\prdyn_{\mora},\prreadout_{\mora},\prstart_{\mora}}
\end{equation}
%
and
%
\begin{equation}
    \label{eq:moore-morb-3rd}
    \morb = \tupp{\prinL_{\morb},\prstL_{\morb},\proutL_{\morb},\prdyn_{\morb},\prreadout_{\morb},\prstart_{\morb}},
\end{equation}
with $\proutL_\mora = \prinL_\morb$. 

We'll first calculate the right-hand side of \cref{eq:moore-action-compositional}, following the procedure of \cref{re:moore-action-two-steps}. 

Given a sequence $u \in {\prinL_{\mora}}^\natnumbers$, to calculate $\act_\mora(u)$ we first map $u$ to the unique solution $r_u \in {\prstL_{\mora}}^\natnumbers$ of the recursion
\begin{equation}
        x_{k+1} = \prdyn_\mora(u_k, x_k)  \qquad \qquad k \in \natnumbers
\end{equation}
such that $r_u(0) = \prstart_{\mora}$. Then $\act_\mora(u) = r_u \then \prreadout_\mora$, an element of ${\proutL_{\mora}}^\natnumbers = {\prinL_{\morb}}^\natnumbers$.

Next, to calculate $(\act_\mora \mthen \act_\morb)(u)$, we first map $\act_\mora(u)$ to the unique solution $s_{\act_\mora(u)} \in {\prstL_{\morb}}^\natnumbers$ of the recursion 
\begin{equation}
        x_{k+1} = \prdyn_\morb(\act_\mora(u)_k, x_k)  \qquad \qquad k \in \natnumbers
\end{equation}
such that $s_{\act_\mora(u)}(0) = \prstart_{\morb}$, and then we have
\begin{equation}
\label{eq:Moore-act-composition-1}
(\act_\mora \mthen \act_\morb)(u) = s_{\act_\mora(u)} \then \prreadout_g.
\end{equation}

Now let's calculate the left-hand side of \cref{eq:moore-action-compositional}. Given $u \in {\prinL_{\mora}}^\natnumbers$, we map it to the unique solution $q_u \in {\prstL_{\mora \mthen \morb}}^\natnumbers = ({\prstL_{\mora} \listconcat \prstL_{\morb}})^\natnumbers$ of the recursion 
\begin{equation}
\label{eq:moore-composite-recursion-equation}
        x_{k+1} = \prdyn_{\mora \mthen \morb}(u_k, x_k)  \qquad \qquad k \in \natnumbers
\end{equation}
with $q_u(0) = \prstart_{\mora} \listconcat \prstart_{\morb}$. Using the definition of $\prdyn_{\mora \mthen \morb}$ and the fact that we can write any $x_k \in \prstL_{\mora} \listconcat \prstL_{\morb}$ as 
$$x_k = x^\mora_k \listconcat x^\morb_k \qquad \qquad \qquad \text{ with } x^\mora_k \in \prstL_{\mora}, x^\morb_k \in \prstL_{\morb},$$ 
we can rewrite \cref{eq:moore-composite-recursion-equation} as
\begin{equation}
        x^\mora_{k+1} \listconcat x^\morb_{k+1} = \prdyn_{\mora}(u_k, x^\mora_k) \listconcat \prdyn_{\morb}(\prreadout_\mora(x^\mora_k), x^\morb_k)  \qquad \qquad k \in \natnumbers.
\end{equation}
Now observe that the sequence $r_u(k) \listconcat s_{\act_\mora(u)}(k)$ solves this recursion: by definition $r_u$ solves of the recursion
\begin{equation}
        x_{k+1} = \prdyn_\mora(u_k, x_k)  \qquad \qquad k \in \natnumbers,
\end{equation}
and, recalling that $\act_\mora(u)_k = \prreadout_\mora(r_u(k))$, we see that $s_{\act_\mora(u)}$ solves the recursion  
\begin{equation}
        x_{k+1} = \prdyn_\morb(\prreadout_\mora(r_u(k)), x_k)  \qquad \qquad k \in \natnumbers.
\end{equation}
Since $r_u(0) \listconcat s_{\act_\mora(u)}(0) = \prstart_{\mora} \listconcat \prstart_{\morb}$, this implies that the unique solution $q_u$ above is precisely $q_u(k) = r_u(k) \listconcat s_{\act_\mora(u)}(k)$. 

Finally, we have
\begin{equation}
\act_{\mora \mthen \morb}(u) = q_u \then \prreadout_{\mora \mthen \morb}.
\end{equation}
Evaluating at any $k \in \natnumbers$ we find 
\begin{align}
(q_u \then \prreadout_{\mora \mthen \morb})(k) &= \prreadout_{\mora \mthen \morb}(q_u(k)) \\
& = \prreadout_{\mora \mthen \morb}(r_u(k) \listconcat s_{\act_\mora(u)}(k)) \\
&= \prreadout_{\morb}(s_{\act_\mora(u)}(k)) \\
& = (s_{\act_\mora(u)} \then \prreadout_{\morb})(k).
\end{align}
Comparing with \cref{eq:Moore-act-composition-1}, we conclude that 
\begin{equation}
\act_{\mora \mthen \morb}(u) = (\act_\mora \mthen \act_\morb)(u). 
\end{equation}
\end{proof}

\

\

\

\todotext{J: Idea: maybe we can model ODE solvers such as the Euler method, etc, as Moore machines and their actions?? could be a cool class of examples}

\

\

\


\todotext{J: below is older material, not sure if worth keeping?}


Let's now look at how machines like the above act on sequences.

For now we only have defined semi-group, monoid, and group actions, and have not talked yet about (semi)category actions.
Let's consider the set of machines systems with~$\prin = \prout = \prgen$; this is the homset~$\HomSet\Moore\prgen\prgen$.


\

\begin{equation}
    \begin{cases}
        x_{k+1} = \prdyn(u_k, x_k) \\
        y_{k}   = \prreadout(x_{k}).
    \end{cases}
\end{equation}

\


Given a finite input sequence~$u\colon \natnumbers \to \prgen$ of length~$n$, the output is an instantaneous transformation of the state:
%
\begin{equation}
    \label{eq:actions-on-sequences-y}
    \begin{aligned}
        y_0   & = \prreadout(\tupset(x_0)), \\
        y_1   & = \prreadout(\tupset(x_1)), \\
        y_2   & = \prreadout(\tupset(x_2)), \\
        \dots & = \dots \\
        y_{k} & = \prreadout(\tupset(x_{k-1})).
    \end{aligned}
\end{equation}
%
The state is computed recursively as follows:
\begin{equation}
    \label{eq:actions-on-sequences-x}
    \begin{aligned}
        x_0   & = \prdyn(u_0, \prstart), \\
        x_1   & = \prdyn(u_1, x_0), \\
        x_2   & = \prdyn(u_2, x_1), \\
        \dots & = \dots \\
        x_{k} & = \prdyn(u_{k}, x_{k-1}).
    \end{aligned}
\end{equation}
%
Therefore, given a machine~$\mora \colon \prgen \mtoin{\Moore} \prgen$ we have defined a map from $\natnumbers \to \prgen$ to itself.
Let's call it $\act$.
It is defined as a map of the form
%
\begin{equation}
    \label{eq:actions-on-sequences-1}
    \act_{\mora}\colon  (\natnumbers \to \prgen)  \sto  (\natnumbers \to \prgen),
\end{equation}
%
or, more formally,
%
\begin{equation}
    \label{eq:actions-on-sequences-2}
    \act: \HomSet\Moore\prgen\prgen \sto \Endof {\natnumbers \to \prgen}.
\end{equation}
%
Note that both~$\HomSet\Moore\prgen\prgen$ and $\Endof {\natnumbers \to \prgen}$ are semigroups.
Could it be that~$\act$ is a semigroup morphism?
And, consequently, is~$\act$ a covariant semigroup action or a contravariant semigroup action?

Let's check the condition for it being a morphism (\cref{eq:sgrp-mor-comp}):
%
\begin{align}
    \act ( \mora \mthenof{\Moore} \morb) & \mathrel{\stackrel{?
    }{=} } \act ( \mora) \mthenof{\Endof  {\natnumbers \to \prgen}} \act(\morb) \label{eq:actions-on-sequences-left} \\
    \act ( \morb \mthenof{\Moore} \mora) & \mathrel{\stackrel{?}{=}}  \act ( \mora) \mthenof{\Endof  {\natnumbers \to \prgen}} \act(\morb) \label{eq:actions-on-sequences-right}
\end{align}

We can check this graphically.
First, one has
%
\begin{equation*}
    \prfperiod{\prftree{\includesag{moore_right_s_f}}{\includesag{moore_right_s_f_conn}}}{\prftree{\includesag{moore_right_b}}{\includesag{moore_right_b_space}}}{\includesag{moore_right_comp_1}}
\end{equation*}
%
Second, one has
%
\begin{equation*}
    \prfperiod{\prftree{\includesag{moore_right_s}}{\includesag{moore_right_s_space}}}{\prftree{\includesag{moore_right_1}}{\includesag{moore_right_2}}}{\includesag{moore_right_5}}
\end{equation*}
%
Therefore, we have a \emph{covariant} semigroup action.

\begin{publictodo}
    The rest of the section is missing.
\end{publictodo}
