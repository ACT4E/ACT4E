% !TEX root = chapter-standalone.tex

\section{More machines}
\label{sec:more-machines}

We can define many different types of machines.

\linkvideo{spring2021-actions:semi-actions:processes:more} % More machines
A Moore machine outputs 1 element at each time step; what if a machine was able to output more than one or zero output?
We'll call these \emph{More} machines.

We define their dynamics and readout to be of the form
%
\begin{equation}
    \label{eq:more-signature}
    \begin{cases}
        \prdyn \colon  \prinL \cprod \prstL \sto \prstL, \\
        \prreadout \colon \prstL  \sto \listsof \proutL,
    \end{cases}
\end{equation}
%
where the output set is not just~$\proutL$ but~$\listsof \proutL$, the set of finite list of elements of $\proutL$.
In other words, for a given state, the machine can produce zero or more outputs in the form of a list.

We'll specify Moore machines as a tuple $\tupp{\prinL,\prstL,\proutL,\prdyn,\prreadout,\prstart}$, like we did for Moore machines.

\subsection{Composition}

Given More machines $\mora = \tupp{\prinL_\mora,\prstL_\mora,\proutL_\mora,\prdyn_\mora,\prreadout_\mora,\prstart_\mora}$ and $\morb = \tupp{\prinL_\morb,\prstL_\morb,\proutL_\morb,\prdyn_\morb,\prreadout_\morb,\prstart_\morb}$ with $\prreadout_\mora = \prinL_\morb$, their composition is the More machine with
\begin{equation}
    \label{eq:more-comp-good-1}
    \begin{aligned}
        \prinL_{\mora\mthen\morb}            & = \prinL_{\mora}, \\
        \prstL_{\mora\mthen\morb}            & = \prstL_{\mora} \cprod  \prstL_{\morb}, \\
        \prstart_{\mora\mthen\morb}          & = \prstart_{\mora} \tupconcat \prstart_{\morb}, \\
        \listsof{\proutL_{\mora\mthen\morb}} & = \listsof{\proutL_{\morb}}.
    \end{aligned}
\end{equation}
%
The dynamics of the composite $\mora \mthen \morb$ is
%
\begin{widepar}
\begin{equation}
    \label{eq:more-comp-good-2}
    \defmapperiodset{
        \prdyn_{\mora\mthen\morb}
    }{
        \prinL_{\mora} \cprod \prstL_{\mora} \cprod \prstL_{\morb}
    }{
        \prstL_{\mora} \cprod \prstL_{\morb}
    }{
        u \tupconcat x_{\mora} \tupconcat x_{\morb}
    }{
        \prdyn_{\mora} (u, x_{\mora}) \tupconcat \prdyn_{\morb}(\tupentry{y_\mora}{n} \tupconcat \prdyn_{\morb}(\tupentry{y_\mora}{n-1}  \tupconcat \dots \prdyn_{\morb}(\tupentry{y_\mora}{1} \tupconcat x_{\morb} )\dots))
    }
\end{equation}
where $y_\mora = \prreadout_{\mora}(x_{\mora}) \in \listsof{\proutL_{\mora}}$ and $n$ is its length. 
\end{widepar}
%
%
The readout of $\mora \mthen \morb$ is
%
\begin{equation}
    \label{eq:more-comp-good-3}
    \defmapperiodset{
        \prreadout_{\mora\mthen\morb}
    }{
       \prstL_{\mora} \cprod \prstL_{\morb}
    }{
        \listsof{\proutL_{\morb}}
    }{
        x_{\mora} \tupconcat x_{\morb}
    }{
        \prreadout_{\morb}(x_{\morb})
    }
\end{equation}

\begin{definition}[\More]
    \label{def:More}
    The \emph{semicategory of More machines} \More is given by:
    \begin{enumerate}
        \item \emph{Objects:} objects of \cCat{\Set}.
        \item \emph{Morphisms:}
              A morphism is a tuple
              \begin{equation}
                  \mora = \tupp{\prinL_{\mora},\prstL_{\mora}, \proutL_{\mora},\prdyn_{\mora},\prreadout_{\mora},\prstart_{\mora}},
              \end{equation}
              where:
              \begin{itemize}
                  \item $\prinL_{\mora},\prstL_{\mora}, \proutL_{\mora}$ are objects of $\cCat{\Set}$;
                  \item $\prstart_{\mora} \in \prstL_{\mora}$;
                  \item $ \prdyn_{\mora} \colon \prinL_{\mora} \cprod \prstL_{\mora} \mto \prstL_{\mora}$;
                  \item $ \prreadout_{\mora} \colon \prstL_{\mora}  \mto \listsof{\proutL_{\mora}}$.
              \end{itemize}
        \item \emph{Composition of morphisms:}
              Composition is given by \cref{eq:more-comp-good-2,eq:more-comp-good-3}.
    \end{enumerate}
\end{definition}


\todotext{the examples below need to be be upated/edited}

\begin{example}[Duplicator]
    We consider the example of a More machine~$\duplicator$, which we call \emph{duplicator}.
    Practically, this machine takes an input, and duplicates it.
    The machine is written as
    \begin{equation*}
        \tupp{\prin_{\duplicator},\prst_{\duplicator},\listsof{\prout_{\duplicator}},\prdyn_{\duplicator},\prreadout_{\duplicator},\prstart_{\duplicator}},
    \end{equation*}
    where~$\prin_{\duplicator}=\prst_{\duplicator}=\prout_\duplicator$, and
    \begin{equation*}
        \defmapcomma{\prdyn_\duplicator}
        {\Tupcat{\prin_\duplicator}{\prst_\duplicator}}
        {\sto}
        {\prst_\duplicator}
        {\tupcat{u}{x_\duplicator}}
        {\tupca{u}}
    \end{equation*}
    %
    \begin{equation*}
        \defmapcomma{\prreadout_\duplicator}
        {\prst_\duplicator}
        {\sto}
        {\listsof{\prout_\duplicator}}
        {x_\duplicator}
        {\tupcat{x_\duplicator}{x_\duplicator}}
    \end{equation*}
    and~$\prstart=\tupca{}$.
\end{example}

\begin{example}[Discarder]
    We consider the example of a More machine~$\discarder$, which we call \emph{discarder}.
    Practically, this machine discards every other input.
    The machine is written as:
    \begin{equation*}
        \tupp{\prin_{\discarder},\prst_{\discarder},\listsof{\prout_{\discarder}},\prdyn_{\discarder},\prreadout_{\discarder},\prstart_{\discarder}},
    \end{equation*}
    where~$\prst_{\discarder}=\Tupcat{\{0,1\}}{\prin_\discarder}$, and
    \begin{equation*}
        \defmapcomma{\prdyn_\discarder}
        {\Tupcat{\prin_\discarder}{\prst_\discarder}}
        {\sto}
        {\prst_\discarder}
        {\tupcat{u}{x_\discarder}}
        {\tupcat{(1-x_\discarder)}{u}}
    \end{equation*}
    %
    \begin{equation*}
        \defmapcomma{\prreadout_\discarder}
        {\prst_\discarder}
        {\sto}
        {\listsof{\prout_\discarder}}
        {\tupcat{x_{1,\discarder}}{x_{2,\discarder}}}
        {
            \begin{cases}
                \tupca{x_{2,\discarder}}, & x_\discarder\neq 0, \\
                \tupca{},                 & \text{ else}.
            \end{cases}
        }
    \end{equation*}
    and~$\prstart=0$.
\end{example}

\begin{example}[Terminator]
    Consider a More machine~$\terminator$, which we call \emph{terminator}.
    Practically, this machine terminates any input, outputting an empty list.
    The machine is written as
    \begin{equation*}
        \tupp{\prin_{\terminator},\prst_{\terminator},\listsof{\prout_{\terminator}},\prdyn_{\terminator},\prreadout_{\terminator},\prstart_{\terminator}},
    \end{equation*}
    where:
    \begin{equation*}
        \defmapcomma{\prdyn_\terminator}
        {\Tupcat{\prin_\terminator}{\prst_\terminator}}
        {\sto}
        {\prst_\terminator}
        {\tupcat{u}{x_\terminator}}
        {\tupca{x_\terminator}}
    \end{equation*}
    %
    \begin{equation*}
        \defmapcomma{\prreadout_\terminator}
        {\prst_\terminator}
        {\sto}
        {\listsof{\prout_\terminator}}
        {\prst_\terminator}
        {
            \tupca{}
        }
    \end{equation*}
    and any~$\prstart_\terminator$.
\end{example}

\todojira{589}{Example of More: Composition of duplicator and discarder gives identity}

