% !TEX root = chapter-standalone.tex

\section{More machines}
\label{sec:more-machines}

We can define many different types of machines.

\linkvideo{spring2021-actions:semi-actions:processes:more} % More machines
A Moore machine outputs 1 element at each time step; what if a machine was able to output more than one or zero output?
We'll call these \emph{More} machines.

We define their dynamics and readout to be of the form
%
\begin{equation}
    \label{eq:more-signature}
    \begin{cases}
        \prdyn \colon  \prinL \listconcat \prstL \sto \prstL, \\
        \prreadout \colon \prstL  \sto \listsof \proutL,
    \end{cases}
\end{equation}
%
where the output set is not just~$\proutL$ but~$\listsof \proutL$, the sets finite list of elements of $\proutL$.
In other words, for a given state, the machine can produce zero or more outputs in the form of a list.

We'll specify Moore machines as a tuple $\tupp{\prinL,\prstL,\proutL,\prdyn,\prreadout,\prstart}$, like we did for Moore machines.

\subsection{Composition}

Given More machines $\mora = \tupp{\prinL_\mora,\prstL_\mora,\proutL_\mora,\prdyn_\mora,\prreadout_\mora,\prstart_\mora}$ and $\morb = \tupp{\prinL_\morb,\prstL_\morb,\proutL_\morb,\prdyn_\morb,\prreadout_\morb,\prstart_\morb}$ with .
.. , their composition is the More machine with
\begin{equation}
    \label{eq:more-comp-good-1}
    \begin{aligned}
        \prinL_{\mora\mthen\morb}            & = \prinL_{\mora}, \\
        \prstL_{\mora\mthen\morb}            & = \prstL_{\mora} \listconcat  \prstL_{\morb}, \\
        \prstart_{\mora\mthen\morb}          & = \prstart_{\mora} \listconcat \prstart_{\morb}, \\
        \listsof{\proutL_{\mora\mthen\morb}} & = \listsof{\proutL_{\morb}}.
    \end{aligned}
\end{equation}
%
The dynamics of the composite $\mora \mthen \morb$ is.
..
\todotext{how is this defined? the below does not seem correct}
%
\begin{equation}
    \label{eq:more-comp-good-2}
    \defmapperiodset{
        \prdyn_{\mora\mthen\morb}
    }{
        \Tupcatt {\prin_{\mora}}  {\prst_{\mora}} {\prst_{\morb}}
    }{
        \Tupcat {\prst_{\mora}} {\prst_{\morb}}
    }{
        \tupcatt u {x_{\mora}} {x_{\morb}}
    }{
        \tupcat %
        {%
            \prdyn_{\mora} (u, x_{\mora})
        }{%
            \prdyn_{\morb}(\prreadout_{\mora}(\tupset(x_{\mora})), x_{\morb})
        }
    }
\end{equation}
%
%
The readout of the composition is
\todotext{how is this defined?
    the below does not seem correct}
%
\begin{equation}
    \label{eq:more-comp-good-3}
    \defmapperiodset{
        \prreadout_{\mora\mthen\morb}
    }{
        \Tupcat {\prst_{\mora}} {\prst_{\morb}}
    }{
        \listsof{\prout_{\morb}}
    }{
        \tupcat {x_{\mora}} {x_{\morb}}
    }{
        \prreadout_{\morb}(\tupset(x_{\morb}))
    }
\end{equation}

\begin{definition}[\More]
    \label{def:More}
    The \emph{semicategory of More machines} \More is given by:
    \begin{enumerate}
        \item \emph{Objects:} objects of \Set.
        \item \emph{Morphisms:}
              A morphism is a tuple
              \begin{equation}
                  \mora = \tupp{\prin_{\mora},\prst_{\mora},\listsof{\prout_{\mora}},\prdyn_{\mora},\prreadout_{\mora},\prstart_{\mora}},
              \end{equation}
              where:
              \begin{itemize}
                  \item $\prst_{\mora}$ is an object of \SetL;
                  \item $\prin_{\mora}$ and~$\listsof{\prout_{\mora}}$ are sets (objects of \Set);
                  \item $ \prdyn_{\mora} \colon \prin_{\mora} \mtoin\Set \Endof{\prst_{\mora}}$;
                  \item $ \prreadout_{\mora} \colon \tupset(\prst_{\mora})  \mtoin\Set \listsof{\prout_{\mora}}$.
              \end{itemize}
        \item \emph{Composition of morphisms:}
              Composition is given by \cref{eq:more-comp-good-1,eq:more-comp-good-2,eq:more-comp-good-3}.
    \end{enumerate}
\end{definition}

\begin{example}[Duplicator]
    We consider the example of a More machine~$\duplicator$, which we call \emph{duplicator}.
    Practically, this machine takes an input, and duplicates it.
    The machine is written as
    \begin{equation*}
        \tupp{\prin_{\duplicator},\prst_{\duplicator},\listsof{\prout_{\duplicator}},\prdyn_{\duplicator},\prreadout_{\duplicator},\prstart_{\duplicator}},
    \end{equation*}
    where~$\prin_{\duplicator}=\prst_{\duplicator}=\prout_\duplicator$, and
    \begin{equation*}
        \defmapcomma{\prdyn_\duplicator}
        {\Tupcat{\prin_\duplicator}{\prst_\duplicator}}
        {\sto}
        {\prst_\duplicator}
        {\tupcat{u}{x_\duplicator}}
        {\tupca{u}}
    \end{equation*}
    %
    \begin{equation*}
        \defmapcomma{\prreadout_\duplicator}
        {\prst_\duplicator}
        {\sto}
        {\listsof{\prout_\duplicator}}
        {x_\duplicator}
        {\tupcat{x_\duplicator}{x_\duplicator}}
    \end{equation*}
    and~$\prstart=\tupca{}$.
\end{example}

\begin{example}[Discarder]
    We consider the example of a More machine~$\discarder$, which we call \emph{discarder}.
    Practically, this machine discards every other input.
    The machine is written as:
    \begin{equation*}
        \tupp{\prin_{\discarder},\prst_{\discarder},\listsof{\prout_{\discarder}},\prdyn_{\discarder},\prreadout_{\discarder},\prstart_{\discarder}},
    \end{equation*}
    where~$\prst_{\discarder}=\Tupcat{\{0,1\}}{\prin_\discarder}$, and
    \begin{equation*}
        \defmapcomma{\prdyn_\discarder}
        {\Tupcat{\prin_\discarder}{\prst_\discarder}}
        {\sto}
        {\prst_\discarder}
        {\tupcat{u}{x_\discarder}}
        {\tupcat{(1-x_\discarder)}{u}}
    \end{equation*}
    %
    \begin{equation*}
        \defmapcomma{\prreadout_\discarder}
        {\prst_\discarder}
        {\sto}
        {\listsof{\prout_\discarder}}
        {\tupcat{x_{1,\discarder}}{x_{2,\discarder}}}
        {
            \begin{cases}
                \tupca{x_{2,\discarder}}, & x_\discarder\neq 0, \\
                \tupca{},                 & \text{ else}.
            \end{cases}
        }
    \end{equation*}
    and~$\prstart=0$.
\end{example}

\begin{example}[Terminator]
    Consider a More machine~$\terminator$, which we call \emph{terminator}.
    Practically, this machine terminates any input, outputting an empty list.
    The machine is written as
    \begin{equation*}
        \tupp{\prin_{\terminator},\prst_{\terminator},\listsof{\prout_{\terminator}},\prdyn_{\terminator},\prreadout_{\terminator},\prstart_{\terminator}},
    \end{equation*}
    where:
    \begin{equation*}
        \defmapcomma{\prdyn_\terminator}
        {\Tupcat{\prin_\terminator}{\prst_\terminator}}
        {\sto}
        {\prst_\terminator}
        {\tupcat{u}{x_\terminator}}
        {\tupca{x_\terminator}}
    \end{equation*}
    %
    \begin{equation*}
        \defmapcomma{\prreadout_\terminator}
        {\prst_\terminator}
        {\sto}
        {\listsof{\prout_\terminator}}
        {\prst_\terminator}
        {
            \tupca{}
        }
    \end{equation*}
    and any~$\prstart_\terminator$.
\end{example}

\todojira{589}{Example of More: Composition of duplicator and discarder gives identity}

