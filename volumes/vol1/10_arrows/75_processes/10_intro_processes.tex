% !TEX root = chapter-standalone.tex

\section{Moore machines}
\label{sec:moore-machines}

\todojira{673}{Restructure the chapter as disccused}
%\linkvideo{spring2021-actions:semi-actions:processes} % Signals and processes
\devel{
    \linkvideo{spring2021-actions:semi-actions:processes:moore} % Moore machines
    We now look at processes, especially dynamical systems, and see them as (semi)\-categories that act on sequences.

    We have already seen linear discrete time systems.

    We can generalize them by allowing non-linear functions.
    We call these \textbf{Moore} machines, and describe them as:
    %
    \begin{equation}
        \label{eq:moore-1}
        \begin{cases}
            \prdyn \colon \prin \cartprod \prst \sto \prst, \\
            \prreadout \colon \prst \sto \prout,
        \end{cases}
    \end{equation}
    %
    where~$\prin$ represents inputs,~$\prst$ states,~$\prout$ outputs,~$\prdyn$ the dynamics, and~$\prreadout$ the readout.
    As introduced in \cref{sec:actions}, we can apply currying to~$\prdyn$, to obtain a map from inputs to endomorphisms on the states:
    %
    \begin{equation}
        \label{eq:moore-1-endo}
        \begin{cases}
            \prdyn \colon \prin \sto \Endof \prst, \\
            \prreadout \colon \prst \sto \prout.
        \end{cases}
    \end{equation}
    %

    We also need to have an~$\prstart \in \prst$ to act as the initial state.

    Suppose we have two morphisms
    %
    \begin{equation}
        \label{eq:moore-mora}
        \mora = \tupp{\prin_{\mora},\prst_{\mora},\prout_{\mora},\prdyn_{\mora},\prreadout_{\mora},\prstart_{\mora}}
    \end{equation}
    %
    and
    %
    \begin{equation}
        \label{eq:moore-morb}
        \morb = \tupp{\prin_{\morb},\prst_{\morb},\prout_{\morb},\prdyn_{\morb},\prreadout_{\morb},\prstart_{\morb}},
    \end{equation}
    such that~$\prout_{\mora} = \prin_{\morb}$.

    The composition of these two systems should have a joint state that is the product of the states.

    \begin{marginfigure}
        \centering
        \includesag{10_moore_comp_seq}
        \caption{Composition of Moore machines (first version).}
        \label{fig:comp_moore_1}
    \end{marginfigure}

    Here is one way to do it.
    We specify the spaces:
    %
    \begin{equation}
        \label{eq:moore-comp-naive-1}
        \begin{aligned}
            \prin_{\mora\mthen\morb}    & = \prin_{\mora}, \\
            \prst_{\mora\mthen\morb}    & = \prst_{\mora} \cartprod \prst_{\morb}, \\
            \prstart_{\mora\mthen\morb} & = \tupp{\prstart_{\mora}, \prstart_{\morb}}, \\
            \prout_{\mora\mthen\morb}   & = \prout_{\morb}.
        \end{aligned}
    \end{equation}
    %
    Furthermore, we specify the dynamics
    %
    \begin{equation}
        \label{eq:moore-comp-naive-2}
        \defmapset{
            \prdyn_{\mora\mthen\morb}
        }{
            \prin_{\mora} \cartprod (\prst_{\mora} \cartprod \prst_{\morb})
        }{
            (\prst_{\mora} \cartprod \prst_{\morb})
        }{
            \tupp{u, \tupp{x_{\mora}, x_{\morb}}}
        }{
            \tupp{ \prdyn_{\mora} (u, x_{\mora}), \prdyn_{\morb}(\prreadout_{\mora}(x_{\mora}), x_{\morb})}
        }
    \end{equation}
    %
    and the ``readout'':
    %
    \begin{equation}
        \label{eq:moore-comp-naive-3}
        \defmapperiodset{
            \prreadout_{\mora\mthen\morb}
        }{
            (\prst_{\mora} \cartprod \prst_{\morb})
        }{
            \prout_{\morb}
        }{
            \tupp{x_{\mora}, x_{\morb}}
        }{
            \prreadout_{\morb}(x_{\morb})
        }
    \end{equation}
    %
    We represent the composition graphically as in \cref{fig:comp_moore_1}.

    However, if we define these using the Cartesian product~$\prst_{\mora} \cartprod \prst_{\morb}$, we cannot compose the systems in an associative way.
    When we have three systems, composing in the two ways would bring to~$(\prst_{\mora} \cartprod \prst_{\morb}) \cartprod \prst_{\morc}$ and~$\prst_{\mora} \cartprod (\prst_{\morb} \cartprod \prst_{\morc})$, which are \emph{isomorphic} sets but not equal:
    %
    \begin{equation}
        \label{eq:assoc-fails1}
        (\prst_{\mora} \cartprod \prst_{\morb}) \cartprod \prst_{\morc} \neq \prst_{\mora} \cartprod (\prst_{\morb} \cartprod \prst_{\morc})
    \end{equation}
    %
    Elements of these sets are of the form~$\tup{\tup{a,b},c}$ and~$\tup{a, \tup{b,c}}$.
    %
    You can clearly spot the isomorphism:
    %
    \begin{equation}
        \label{eq:assoc-fails2}
        (\prst_{\mora} \cartprod \prst_{\morb}) \cartprod \prst_{\morc} \simeq \prst_{\mora} \cartprod (\prst_{\morb} \cartprod \prst_{\morc}).
    \end{equation}
    %

    \begin{marginfigure}
        \centering
        \includesag{10_moore_comp_seq_bis}
        \caption{Composition of Moore machines (second version).}
        \label{fig:comp_moore_2}
    \end{marginfigure}

    We can avoid lengthy book-keeping by using a slightly different construction (\cref{fig:comp_moore_2}) using the \SetL category (\cref{sec:SetL}) and the functor~$\tupset$ introduced in \cref{sec:funsetstarset}.
    %
    The idea is to just use lists of sets rather than the cartesian product.
    In other words,~$\prstL_\mora, \prstL_\morb\in \Ob_{\SetL}$.
    So the joint state is going to be~
    \begin{equation}
        \label{eq:moore-comp-good-joint}
        \prstL_{\mora} \listconcat   \prstL_{\morb}
    \end{equation}
    rather than~$\prst_{\mora} \cartprod \prst_{\morb}$.

    The joint system has as states:
    \begin{equation}
        \label{eq:moore-comp-good-1}
        \begin{aligned}
            \prin_{\mora\mthen\morb}    & = \prin_{\mora}, \\
            \prstL_{\mora\mthen\morb}   & = \prstL_{\mora}\listconcat  \prstL_{\morb}, \\
            \prstart_{\mora\mthen\morb} & = \tup{\prstart_{\mora},\prstart_{\morb}}, \\
            \prout_{\mora\mthen\morb}   & = \prout_{\morb}.
        \end{aligned}
    \end{equation}
    %
    We can now use the \emph{coherence morphism} introduced in \cref{sec:SetL}, to compactly define the dynamics and the readout maps as morphisms in \Set.
    We represent the machinery through the following commutative diagrams:

    \equationsag{commutative_moore}{eq:commutative_moore}

    \equationsag{commutative_moore_ro}{eq:commutative_moore_ro}

    where
    %
    \begin{equation}
        \label{eq:moore-comp-good-2}
        \defmapcommaset{
        \prdyn'_{\mora\mthen\morb}
        }{
        \prin_{\mora} \cartprod (\tupset(\prstL_\mora)\cartprod \tupset(\prstL_\morb))
        }{
        \tupset(\prstL_\mora)\cartprod \tupset(\prstL_\morb)
        }{
        \tup{u,{x_{\mora}},{x_{\morb}}}
        }{
        \tup %
        {%
            \prdyn_{\mora} (u, x_{\mora}),
            {%
                    \prdyn_{\morb}(\prreadout_{\mora}(x_{\mora}), x_{\morb})
                }}
        }
    \end{equation}
    %
    %
    and
    %
    \begin{equation}
        \label{eq:moore-comp-good-3}
        \defmapperiodset{
        \prreadout'_{\mora\mthen\morb}
        }{
        \tupset(\prstL_\mora)\cartprod \tupset(\prstL_\morb)
        }{
        \prout_{\morb}
        }{
        \tup{{x_{\mora}}, {x_{\morb}}}
        }{
        \prreadout_{\morb}(x_{\morb})
        }
    \end{equation}
    %
    With this definition we can define the semicategory~\Moore of Moore machines.
    %
    \begin{definition}[\Moore]
        \label{def:Moore}
        The \emph{semicategory of Moore machines} \Moore is given by:
        \begin{enumerate}
            \item \emph{Objects:} objects of \Set.
            \item \emph{Morphisms:}
                  A morphism is a tuple
                  \begin{equation}
                      \mora = \tupp{\prin_{\mora},\prstL_{\mora},\prout_{\mora},\prdyn_{\mora},\prreadout_{\mora},\prstart_{\mora}},
                  \end{equation}
                  where:
                  \begin{itemize}
                      \item $\prstL_{\mora}$ is object of \SetL;
                      \item $\prin_{\mora}$ and~$\prout_{\mora}$ are sets (objects of \Set);
                      \item $ \prdyn_{\mora} \colon \prin_{\mora}\cartprod \tupset(\prstL_\mora) \mtoin\Set  \tupset(\prstL_\mora)$;
                      \item $ \prreadout_{\mora} \colon \tupset(\prstL_{\mora})  \mtoin\Set \prout_{\mora}$.
                  \end{itemize}
            \item \emph{Composition:}
                  Composition is given by \cref{eq:moore-comp-good-1,eq:moore-comp-good-2,eq:moore-comp-good-3}.
        \end{enumerate}
    \end{definition}
    %
    We can show that \Moore is indeed a semicategory.
    Given valid, composable machines~$\mora$,~$\morb$,~$\morc$, we can specify the spaces and initial conditions:
    \begin{equation*}
        \label{eq:moore_assoc_spaces}
        \begin{aligned}
            \prin_{(\mora \mthen \morb)\mthen \morc}    & =\prin_{\mora \mthen (\morb \mthen \morc)}=\prin_{\mora}, \\
            \prstL_{(\mora \mthen \morb)\mthen \morc}   & =\prstL_{\mora \mthen (\morb \mthen \morc)}=  \prstL_{\mora} \listconcat \prstL_{\morb} \listconcat  \prstL_{\morc} \\
            \prstart_{(\mora \mthen \morb)\mthen \morc} & =\prstart_{\mora \mthen (\morb \mthen \morc)}=\tup{\prstart_\mora,\prstart_\morb,\prstart_\morc} \\
            \prout_{(\mora \mthen \morb)\mthen \morc}   & =\prout_{\mora \mthen (\morb \mthen \morc)}=\prout_\morc
        \end{aligned}
    \end{equation*}

    We first check associativity for the dynamics.
    First, we represent the situation graphically via a commutative diagram:
    %
    \equationsag{commutative_moore_assoc_1}{eq:commutative_moore_assoc_1}
    where
    \begin{widepar}
        \begin{equation*}
            \label{eq:assoc_moore_1}
            \begin{aligned}
                \prdyn'_{(\mora\mthen\morb)\mthen \morc}\colon \prin_{\mora}\cartprod ((\tupset(\prstL_{\mora}) \cartprod \tupset(\prstL_{\morb}))\cartprod \tupset(\prstL_{\morc})) & \to (\tupset(\prstL_{\mora}) \cartprod \tupset(\prstL_{\morb}))\cartprod \tupset(\prstL_{\morc}) \\
                \tup{u, \tup{\tup{x_{\mora},x_{\morb}},x_\morc}}                                                                                                                     & \mapsto \tup{\prdyn'_{\mora \mthen \morb}(u,\tup{x_\mora, x_\morb}),\prdyn'_{\morc}(\prreadout_{\mora \mthen \morb}(\tup{x_\mora,x_\morb}),x_\morc)} \\
                                                                                                                                                                                     & =\tup{\prdyn'_\mora(u,x_\mora), \prdyn'_\morb(\prreadout_\mora(x_\mora),x_\morb), \prdyn'_\morc(\prreadout_\morb(x_\morb),x_\morc)}.
            \end{aligned}
        \end{equation*}
    \end{widepar}
    %
    On the other hand, one has:
    \equationsag{commutative_moore_assoc_2}{eq:commutative_moore_assoc_2}
    %
    where
    \begin{widepar}
        \begin{equation*}
            \label{eq:assoc_moore_2}
            \begin{aligned}
                \prdyn'_{\mora\mthen(\morb\mthen \morc)}\colon \prin_{\mora}\cartprod (\tupset(\prstL_{\mora}) \cartprod (\tupset(\prstL_{\morb})\cartprod \tupset(\prstL_{\morc}))) & \to \tupset(\prstL_{\mora}) \cartprod (\tupset(\prstL_{\morb})\cartprod \tupset(\prstL_{\morc})) \\
                \tup{u, \tup{x_{\mora},\tup{x_{\morb},x_\morc}}}                                                                                                                     & \mapsto \tup{\prdyn'_{\mora}(u,x_\mora),\prdyn'_{\morb\mthen \morc}(\prreadout_{\mora}({x_\mora}),\tup{x_\morb,x_\morc})} \\
                                                                                                                                                                                     & =\tup{\prdyn'_\mora(u,x_\mora), \prdyn'_\morb(\prreadout_\mora(x_\mora),x_\morb), \prdyn'_\morc(\prreadout_\morb(x_\morb),x_\morc)}.
            \end{aligned}
        \end{equation*}
    \end{widepar}
    %
    \todo{do diagrams for readout}
    Finally, one can check associativity of the readout:
    \begin{equation*}
        \label{eq:assoc_moore_3}
        \defmapcommaset{
        \prreadout'_{(\mora \mthen \morb)\mthen \morc}}
        {(\tupset(\prstL_{\mora}) \cartprod \tupset(\prstL_{\morb}))\cartprod \tupset(\prstL_{\morc})}
        {\prout_\morc}
        {\tup{\tup{x_\mora,x_\morb},x_\morc}}
        { \prreadout_\morc(x_\morc)}
    \end{equation*}
    and
    \begin{equation*}
        \label{eq:assoc_moore_4}
        \defmapperiodset{
        \prreadout'_{\mora \mthen (\morb\mthen \morc)}
        }{
        \tupset(\prstL_{\mora}) \cartprod (\tupset(\prstL_{\morb})\cartprod \tupset(\prstL_{\morc}))
        }{
        \prout_\morc
        }{
        \tup{x_\mora,\tup{x_\morb,x_\morc}}
        }{
        \prreadout_\morc(x_\morc)
        }
    \end{equation*}

    \section{Action on sequences}

    Let's now look at how machines like the above act on sequences.

    For now we only have defined semi-group, monoid, and group actions, and have not talked yet about (semi)category actions.
    Let's consider the set of machines systems with~$\prin = \prout = \prgen$; this is the homset~$\HomSet\Moore\prgen\prgen$.

    Given a finite input sequence~$u\colon \natnumbers \to \prgen$ of length~$n$, the output is an instantaneous transformation of the state:
    %
    \begin{equation}
        \label{eq:actions-on-sequences-y}
        \begin{aligned}
            y_0   & = \prreadout(\tupset(x_0)), \\
            y_1   & = \prreadout(\tupset(x_1)), \\
            y_2   & = \prreadout(\tupset(x_2)), \\
            \dots & = \dots \\
            y_{k} & = \prreadout(\tupset(x_{k-1})).
        \end{aligned}
    \end{equation}
    %
    The state is computed recursively as follows:
    \begin{equation}
        \label{eq:actions-on-sequences-x}
        \begin{aligned}
            x_0   & = \prdyn(u_0, \prstart), \\
            x_1   & = \prdyn(u_1, x_0), \\
            x_2   & = \prdyn(u_2, x_1), \\
            \dots & = \dots \\
            x_{k} & = \prdyn(u_{k}, x_{k-1}).
        \end{aligned}
    \end{equation}
    %
    Therefore, given a machine~$\mora \colon \prgen \mtoin{\Moore} \prgen$ we have defined a map from $\natnumbers \to \prgen$ to itself.
    Let's call it $\act$.
    It is defined as a map of the form
    %
    \begin{equation}
        \label{eq:actions-on-sequences-1}
        \act_{\mora}\colon  (\natnumbers \to \prgen)  \sto  (\natnumbers \to \prgen),
    \end{equation}
    %
    or, more formally,
    %
    \begin{equation}
        \label{eq:actions-on-sequences-2}
        \act: \HomSet\Moore\prgen\prgen \sto \Endof {\natnumbers \to \prgen}.
    \end{equation}
    %
    Note that both~$\HomSet\Moore\prgen\prgen$ and $\Endof {\natnumbers \to \prgen}$ are semigroups.
    Could it be that~$\act$ is a semigroup morphism?
    And, consequently, is~$\act$ a covariant semigroup action or a contravariant semigroup action?

    Let's check the condition for it being a morphism (\cref{eq:sgrp-mor-comp}):
    %
    \begin{align}
        \act ( \mora \mthenof{\Moore} \morb) & \mathrel{\stackrel{?
        }{=} } \act ( \mora) \mthenof{\Endof  {\natnumbers \to \prgen}} \act(\morb) \label{eq:actions-on-sequences-left} \\
        \act ( \morb \mthenof{\Moore} \mora) & \mathrel{\stackrel{?}{=}}  \act ( \mora) \mthenof{\Endof  {\natnumbers \to \prgen}} \act(\morb) \label{eq:actions-on-sequences-right}
    \end{align}

    We can check this graphically.
    First, one has
    %
    \begin{equation*}
        \prfperiod{\prftree{\includesag{moore_right_s_f}}{\includesag{moore_right_s_f_conn}}}{\prftree{\includesag{moore_right_b}}{\includesag{moore_right_b_space}}}{\includesag{moore_right_comp_1}}
    \end{equation*}
    %
    Second, one has
    %
    \begin{equation*}
        \prfperiod{\prftree{\includesag{moore_right_s}}{\includesag{moore_right_s_space}}}{\prftree{\includesag{moore_right_1}}{\includesag{moore_right_2}}}{\includesag{moore_right_5}}
    \end{equation*}
    %
    Therefore, we have a \emph{covariant} semigroup action.

    \begin{publictodo}
        The rest of the section is missing.
    \end{publictodo}

    \section{More machines}
    \label{sec:more-machines}

    We can define many different types of machines.

    \linkvideo{spring2021-actions:semi-actions:processes:more} % More machines
    A Moore machine outputs 1 element at each time step; what if the machine was able to output more than one or zero output?

    The signature of this machine would be this:
    %
    \begin{equation}
        \label{eq:more-signature}
        \begin{cases}
            \prdyn \colon  \prin \sto \Endof \prst, \\
            \prreadout \colon \tupset(\prst) \sto \seqsof \prout,
        \end{cases}
    \end{equation}
    %
    where the output is not just~$\prout$ but~$\seqsof \prout$: the machine can produce zero or more outputs.
    We call these \emph{More} machines.

    The composition of two More machines is a More machine with:
    \begin{equation}
        \label{eq:more-comp-good-1}
        \begin{aligned}
            \prin_{\mora\mthen\morb}           & = \prin_{\mora}, \\
            \prst_{\mora\mthen\morb}           & = \Tupcat {\prst_{\mora}}  {\prst_{\morb}}, \\
            \prstart_{\mora\mthen\morb}        & = \tupcat{\prstart_{\mora}}{\prstart_{\morb}}, \\
            \seqsof{\prout_{\mora\mthen\morb}} & = \seqsof{\prout_{\morb}}.
        \end{aligned}
    \end{equation}
    %
    We then write the dynamics
    %
    \begin{equation}
        \label{eq:more-comp-good-2}
        \defmapperiodset{
            \prdyn_{\mora\mthen\morb}
        }{
            \Tupcatt {\prin_{\mora}}  {\prst_{\mora}} {\prst_{\morb}}
        }{
            \Tupcat {\prst_{\mora}} {\prst_{\morb}}
        }{
            \tupcatt u {x_{\mora}} {x_{\morb}}
        }{
            \tupcat %
            {%
                \prdyn_{\mora} (u, x_{\mora})
            }{%
                \prdyn_{\morb}(\prreadout_{\mora}(\tupset(x_{\mora})), x_{\morb})
            }
        }
    \end{equation}
    %
    %
    and the readout
    %
    \begin{equation}
        \label{eq:more-comp-good-3}
        \defmapperiodset{
            \prreadout_{\mora\mthen\morb}
        }{
            \Tupcat {\prst_{\mora}} {\prst_{\morb}}
        }{
            \seqsof{\prout_{\morb}}
        }{
            \tupcat {x_{\mora}} {x_{\morb}}
        }{
            \prreadout_{\morb}(\tupset(x_{\morb}))
        }
    \end{equation}

    \begin{definition}[\More]
        \label{def:More}
        The \emph{semicategory of More machines} \More is given by:
        \begin{enumerate}
            \item \emph{Objects:} objects of \Set.
            \item \emph{Morphisms:}
                  A morphism is a tuple
                  \begin{equation}
                      \mora = \tupp{\prin_{\mora},\prst_{\mora},\seqsof{\prout_{\mora}},\prdyn_{\mora},\prreadout_{\mora},\prstart_{\mora}},
                  \end{equation}
                  where:
                  \begin{itemize}
                      \item $\prst_{\mora}$ is an object of \SetL;
                      \item $\prin_{\mora}$ and~$\seqsof{\prout_{\mora}}$ are sets (objects of \Set);
                      \item $ \prdyn_{\mora} \colon \prin_{\mora} \mtoin\Set \Endof{\prst_{\mora}}$;
                      \item $ \prreadout_{\mora} \colon \tupset(\prst_{\mora})  \mtoin\Set \seqsof{\prout_{\mora}}$.
                  \end{itemize}
            \item \emph{Composition of morphisms:}
                  Composition is given by \cref{eq:more-comp-good-1,eq:more-comp-good-2,eq:more-comp-good-3}.
        \end{enumerate}
    \end{definition}

    \devel{
        \begin{example}[Duplicator]
            We consider the example of a More machine~$\duplicator$, which we call \emph{duplicator}.
            Practically, this machine takes an input, and duplicates it.
            The machine is written as
            \begin{equation*}
                \tupp{\prin_{\duplicator},\prst_{\duplicator},\seqsof{\prout_{\duplicator}},\prdyn_{\duplicator},\prreadout_{\duplicator},\prstart_{\duplicator}},
            \end{equation*}
            where~$\prin_{\duplicator}=\prst_{\duplicator}=\prout_\duplicator$, and
            \begin{equation*}
                \defmapcomma{\prdyn_\duplicator}
                {\Tupcat{\prin_\duplicator}{\prst_\duplicator}}
                {\sto}
                {\prst_\duplicator}
                {\tupcat{u}{x_\duplicator}}
                {\tupca{u}}
            \end{equation*}
            %
            \begin{equation*}
                \defmapcomma{\prreadout_\duplicator}
                {\prst_\duplicator}
                {\sto}
                {\seqsof{\prout_\duplicator}}
                {x_\duplicator}
                {\tupcat{x_\duplicator}{x_\duplicator}}
            \end{equation*}
            and~$\prstart=\tupca{}$.
        \end{example}

        \begin{example}[Discarder]
            We consider the example of a More machine~$\discarder$, which we call \emph{discarder}.
            Practically, this machine discards every other input.
            The machine is written as:
            \begin{equation*}
                \tupp{\prin_{\discarder},\prst_{\discarder},\seqsof{\prout_{\discarder}},\prdyn_{\discarder},\prreadout_{\discarder},\prstart_{\discarder}},
            \end{equation*}
            where~$\prst_{\discarder}=\Tupcat{\{0,1\}}{\prin_\discarder}$, and
            \begin{equation*}
                \defmapcomma{\prdyn_\discarder}
                {\Tupcat{\prin_\discarder}{\prst_\discarder}}
                {\sto}
                {\prst_\discarder}
                {\tupcat{u}{x_\discarder}}
                {\tupcat{(1-x_\discarder)}{u}}
            \end{equation*}
            %
            \begin{equation*}
                \defmapcomma{\prreadout_\discarder}
                {\prst_\discarder}
                {\sto}
                {\seqsof{\prout_\discarder}}
                {\tupcat{x_{1,\discarder}}{x_{2,\discarder}}}
                {
                    \begin{cases}
                        \tupca{x_{2,\discarder}}, & x_\discarder\neq 0, \\
                        \tupca{},                 & \text{ else}.
                    \end{cases}
                }
            \end{equation*}
            and~$\prstart=0$.
        \end{example}

        \begin{example}[Terminator]
            Consider a More machine~$\terminator$, which we call \emph{terminator}.
            Practically, this machine terminates any input, outputting an empty list.
            The machine is written as
            \begin{equation*}
                \tupp{\prin_{\terminator},\prst_{\terminator},\seqsof{\prout_{\terminator}},\prdyn_{\terminator},\prreadout_{\terminator},\prstart_{\terminator}},
            \end{equation*}
            where:
            \begin{equation*}
                \defmapcomma{\prdyn_\terminator}
                {\Tupcat{\prin_\terminator}{\prst_\terminator}}
                {\sto}
                {\prst_\terminator}
                {\tupcat{u}{x_\terminator}}
                {\tupca{x_\terminator}}
            \end{equation*}
            %
            \begin{equation*}
                \defmapcomma{\prreadout_\terminator}
                {\prst_\terminator}
                {\sto}
                {\seqsof{\prout_\terminator}}
                {\prst_\terminator}
                {
                    \tupca{}
                }
            \end{equation*}
            and any~$\prstart_\terminator$.
        \end{example}
    }

    \todojira{589}{Example of More: Composition of duplicator and discarder gives identity}}
