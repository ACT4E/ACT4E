% !TEX root = chapter-standalone.tex


\section{Moore machines}
\label{sec:moore-machines}
%\linkvideo{spring2021-actions:semi-actions:processes} % Signals and processes

\linkvideo{spring2021-actions:semi-actions:processes:moore} % Moore machines
We now look at processes, especially dynamical systems, and see them as categories that act on sequences.

We have already seen linear discrete time systems.
We can generalize them by allowing non-linear functions, so to have the definition as follows.
We call these \textbf{Moore} machines, and describe them as:
%
\begin{equation}
    \label{eq:moore-1}
    \begin{cases}
        \prdyn \colon \prin \cartprod \prst \sto \prst \\
        \prreadout \colon \prst \sto \prout,
    \end{cases}
\end{equation}
%
where~$\prin$ represents inputs,~$\prst$ states,~$\prout$ outputs,~$\prdyn$ the dynamics, and~$\prreadout$ the readout.
As introduced in \cref{sec:actions}, we can apply currying to~$\prdyn$, to obtain a map from inputs to endomorphisms on the states:
%
\begin{equation}
    \label{eq:moore-1-endo}
    \begin{cases}
        \prdyn \colon \prin \sto \Endof \prst \\
        \prreadout \colon \prst \sto \prout
    \end{cases}
\end{equation}
%
\showslides{
    \begin{forslides}
        \includesag{10_moore_1}\\
        \includesag{10_moore_comp_seq}
        \begin{equation}
            \label{eq:cond_moore_comp}
            \prout_{\mora} \subseteq \prin_{\morb}
        \end{equation}
        \includesag{10_moore_comp_seq_bis}
    \end{forslides}
}

We also need to have an~$\prstart \in \prst$ to act as the initial state.

Suppose we have two morphisms
%
\begin{equation}
    \label{eq:moore-mora}
    \mora = \tupp{\prin_{\mora},\prst_{\mora},\prout_{\mora},\prdyn_{\mora},\prreadout_{\mora},\prstart_{\mora}}
\end{equation}
%
and
%
\begin{equation}
    \label{eq:moore-morb}
    \morb = \tupp{\prin_{\morb},\prst_{\morb},\prout_{\morb},\prdyn_{\morb},\prreadout_{\morb},\prstart_{\morb}},
\end{equation}
such that~$\prout_{\mora} \subseteq \prin_{\morb}$.
The composition of these two systems should have a joint state that is the product of the states.

\begin{marginfigure}
    \centering
    \includesag{10_moore_comp_seq}
    \todographics{@Gioele: make diagram more compact to fit}
    \caption{Composition of Moore machines (first version).}
    \label{fig:comp_moore_1}
\end{marginfigure}


Here is one way to do it.
We specify the spaces:
%
\begin{equation}
    \label{eq:moore-comp-naive-1}
    \begin{aligned}
        \prin_{\mora\mthen\morb} &= \prin_{\mora}   \\
        \prst_{\mora\mthen\morb} &= \prst_{\mora} \cartprod \prst_{\morb} \\
        \prstart_{\mora\mthen\morb} &= \tupp{\prstart_{\mora}, \prstart_{\morb}} \\
        \prout_{\mora\mthen\morb} &= \prout_{\morb}
    \end{aligned}
\end{equation}
%
Furthermore, we specify the dynamics
%
\begin{equation}
    \label{eq:moore-comp-naive-2}
    \definemap{
        \prdyn_{\mora\mthen\morb}
    }{
        \prin_{\mora} \cartprod (\prst_{\mora} \cartprod \prst_{\morb})
    }{
        (\prst_{\mora} \cartprod \prst_{\morb})
    }{
        \tupp{u, \tupp{x_{\mora}, x_{\morb}}}
    }{
        \tupp{ \prdyn_{\mora} (u, x_{\mora}), \prdyn_{\morb}(\prreadout_{\mora}(x_{\mora}), x_{\morb})}
    }
\end{equation}
%
and the ``readout'':
%
\begin{equation}
    \label{eq:moore-comp-naive-3}
    \definemap{
        \prreadout_{\mora\mthen\morb}
    }{
        (\prst_{\mora} \cartprod \prst_{\morb})
    }{
        \prout_{\morb}
    }{
        \tupp{x_{\mora}, x_{\morb}}
    }{
        \prreadout_{\morb}(x_{\morb})
    }
\end{equation}
%
We represent the composition graphically as in \cref{fig:comp_moore_1}.

However, if we define these using the Cartesian product~$\prst_{\mora} \cartprod \prst_{\morb}$, we cannot compose the systems in an associative way.
When we have three systems, composing in the two ways would bring to~$(\prst_{\mora} \cartprod \prst_{\morb}) \cartprod \prst_{\morc}$ and~$\prst_{\mora} \cartprod (\prst_{\morb} \cartprod \prst_{\morc})$, which are \emph{isomorphic} sets but not equal.
%
\begin{equation}
    \label{eq:assoc-fails1}
    (\prst_{\mora} \cartprod \prst_{\morb}) \cartprod \prst_{\morc} \neq \prst_{\mora} \cartprod (\prst_{\morb} \cartprod \prst_{\morc})
\end{equation}
Elements of these sets are of the form~$\tup{\tup{a,b},c}$ and~$\tup{a, \tup{b,c}}$.
%
You can clearly spot the isomorphism:
%
\begin{equation}
    \label{eq:assoc-fails2}
    (\prst_{\mora} \cartprod \prst_{\morb}) \cartprod \prst_{\morc} \simeq \prst_{\mora} \cartprod (\prst_{\morb} \cartprod \prst_{\morc}).
\end{equation}
%

\begin{marginfigure}
    \centering
    \includesag{10_moore_comp_seq_bis}
    \todographics{@Gioele: make diagram more compact to fit}
    \caption{Composition of Moore machines (second version).}
    \label{fig:comp_moore_2}
\end{marginfigure}

We can avoid lengthy book-keeping by using a slightly different construction (\cref{fig:comp_moore_2}) using the \SetStar category (\cref{sec:SetStar}).
%
The idea is to just use lists of sets rather than the cross-product.
So the joint state is going to be
\begin{equation}
    \label{eq:moore-comp-good-joint}
    \prst_{\mora} \setconcat \prst_{\morb}
\end{equation}
rather than~$\prst_{\mora} \cartprod \prst_{\morb}$.

The joint system has as states:
\begin{equation}
    \label{eq:moore-comp-good-1}
    \begin{aligned}
        \prin_{\mora\mthen\morb} &= \prin_{\mora},   \\
        \prst_{\mora\mthen\morb} &= \prst_{\mora} \setconcat \prst_{\morb}, \\
        \prstart_{\mora\mthen\morb} &= \tupcat{\prstart_{\mora}}{\prstart_{\morb}}, \\
        \prout_{\mora\mthen\morb} &= \prout_{\morb}.
    \end{aligned}
\end{equation}
%
We then write the dynamics
%
\begin{equation}
    \label{eq:moore-comp-good-2}
    \definemap{
        \prdyn_{\mora\mthen\morb}
    }{
        (\prin_{\mora}  \setconcat \prst_{\mora} \setconcat \prst_{\morb})
    }{
        (\prst_{\mora} \setconcat \prst_{\morb}),
    }{
        \tupp{u, \tupcat{x_{\mora}}{x_{\morb}}}
    }{
        \tupcat{ \prdyn_{\mora} (u, x_{\mora})}{\prdyn_{\morb}(\prreadout_{\mora}(x_{\mora}), x_{\morb})}.
    }
\end{equation}
%
%
and the readout
%
\begin{equation}
    \label{eq:moore-comp-good-3}
    \definemap{
        \prreadout_{\mora\mthen\morb}
    }{
        (\prst_{\mora} \setconcat \prst_{\morb})
    }{
        \prout_{\morb}
    }{
        \tupcat{x_{\mora}}{x_{\morb}}
    }{
        \prreadout_{\morb}(x_{\morb})
    }
\end{equation}
%
With this definition we can define the semi-category~\Moore of Moore machines.

\begin{definition}[\Moore]
    \label{def:Moore}
    The \emph{semi-category of Moore machines} \Moore is given by:
    \begin{enumerate}
        \item \emph{Objects:} objects of \SetStar.
        \item \emph{Morphisms:} A morphism is a tuple
        \begin{equation}
            \mora = \tupp{\prin_{\mora},\prst_{\mora},\prout_{\mora},\prdyn_{\mora},\prreadout_{\mora},\prstart_{\mora}},
        \end{equation}
        where:
        \begin{itemize}
            \item $\prin$,~$\prst$,~$\prout$ are objects of \SetStar.
            \item $ \prdyn \colon \prin \mto_\SetStar  \Endof \prst$;
            \item $ \prreadout \colon \prst  \mto_\SetStar \prout$.
        \end{itemize}
        \item \emph{Composition of morphisms:} Composition is given by:
        \begin{equation}
            \begin{aligned}
                \prin_{\mora\mthen\morb} &= \prst_{\mora}   \\
                \prst_{\mora\mthen\morb} &= \prst_{\mora} \setconcat \prst_{\morb} \\
                \prstart_{\mora\mthen\morb} &= \tupcat{\prstart_{\mora}}{\prstart_{\morb}} \\
                \prout_{\mora\mthen\morb} &= \prout_{\morb},
            \end{aligned}
        \end{equation}
        with
        \begin{widepar}
            \begin{equation}
                \label{eq:moore_dyn_comp}
                \definemap{
                    \prdyn_{\mora\mthen\morb}
                }{
                    (\prin_{\mora} \setconcat \prst_{\mora} \setconcat \prst_{\morb})
                }{
                    (\prst_{\mora} \setconcat \prst_{\morb})
                }{
                    \tup{u, \tupcat{x_{\mora}}{x_{\morb}}}
                }{
                    \tupcat{ \prdyn_{\mora} (u, x_{\mora})}{\prdyn_{\morb}(\prreadout_{\mora}(x_{\mora}), x_{\morb})},
                }
            \end{equation}
        \end{widepar}
        and
        \begin{equation}
            \definemap{
                \prreadout_{\mora\mthen\morb}
            }{
                (\prst_{\mora} \setconcat \prst_{\morb})
            }{
                \prout_{\morb}
            }{
                \tupcat{x_{\mora}}{x_{\morb}}
            }{
                \prreadout_{\morb}(x_{\morb})
            }
        \end{equation}
    \end{enumerate}
\end{definition}

\begin{exercise}
    Show that indeed \Moore is a semi-category.
\end{exercise}
\begin{solution}
    Given valid, composable machines~$\mora$,~$\morb$,~$\morc$, we can specify the spaces and initial conditions:
    \begin{equation*}
        \label{eq:moore_assoc_spaces}
        \begin{aligned}
            \prin_{(\mora \mthen \morb)\mthen \morc}&=\prin_{\mora \mthen (\morb \mthen \morc)}=\prin_{\mora},\\
            \prst_{(\mora \mthen \morb)\mthen \morc}&=\prst_{\mora \mthen (\morb \mthen \morc)}=\prst_{\mora} \setconcat \prst_{\morb} \setconcat \prst_{\morc}\\
            \prstart_{(\mora \mthen \morb)\mthen \morc}&=\prstart_{\mora \mthen (\morb \mthen \morc)}=\tupcatt{\prstart_\mora}{\prstart_\morb}{\prstart_\morc}\\
            \prout_{(\mora \mthen \morb)\mthen \morc}&=\prout_{\mora \mthen (\morb \mthen \morc)}=\prout_\morc
        \end{aligned}
    \end{equation*}
    Starting from \cref{eq:moore_dyn_comp} one can now check associativity of the dynamics:
    \begin{equation*}
        \label{eq:assoc_moore_1}
        \begin{aligned}
            \prdyn_{(\mora\mthen\morb)\mthen \morc}\colon \prin_{\mora} \cartprod ((\prst_{\mora} \setconcat \prst_{\morb})\setconcat \prst_{\morc})&\to (\prst_{\mora} \setconcat \prst_{\morb})\setconcat \prst_{\morc}\\
            \tup{u, \tupcatt{x_{\mora}}{x_{\morb}}{x_\morc}}&\mapsto \tupcat{\prdyn_{\mora \mthen \morb}(u,\tupcat{x_\mora}{x_\morb})}{\prdyn_{\morc}(\prreadout_{\mora \mthen \morb}(\tupcat{x_\mora}{x_\morb}),x_\morc)}\\
            &=\tupcatt{\prdyn_\mora(u,x_\mora)}{\prdyn_\morb(\prreadout(x_\mora),x_\morb)}{\prdyn_\morc(\prreadout_\morb(x_\morb),x_\morc)}.
        \end{aligned}
    \end{equation*}
    On the other hand, one has:
    \begin{equation*}
        \label{eq:assoc_moore_2}
        \begin{aligned}
            \prdyn_{\mora\mthen(\morb\mthen \morc)}\colon \prin_{\mora} \cartprod (\prst_{\mora} \setconcat (\prst_{\morb}\setconcat \prst_{\morc}))&\to \prst_{\mora} \setconcat (\prst_{\morb}\setconcat \prst_{\morc})\\
            \tup{u, \tupcatt{x_{\mora}}{x_{\morb}}{x_\morc}}&\mapsto \tupcat{\prdyn_{\mora}(u,x_\mora)}{\prdyn_{\morb\mthen \morc}(\prreadout_{\mora}(x_\mora),\tupcat{x_\morb}{x_\morc})}\\
            &=\tupcatt{\prdyn_\mora(u,x_\mora)}{\prdyn_\morb(\prreadout(x_\mora),x_\morb)}{\prdyn_\morc(\prreadout_\morb(x_\morb),x_\morc)}.
        \end{aligned}
    \end{equation*}
    Finally, one can check associativity of the readout:
    \begin{equation*}
        \label{eq:assoc_moore_3}
        \begin{aligned}
            \prreadout_{(\mora \mthen \morb)\mthen \morc}\colon (\prst_\mora \setconcat \prst_\morb)\setconcat \prst_\morc &\to \prout_\morc\\
            \tupcatt{x_\mora}{x_\morb}{x_\morc} &\mapsto \prreadout_\morc(x_\morc),
        \end{aligned}
    \end{equation*}
    and
    \begin{equation*}
        \label{eq:assoc_moore_4}
        \begin{aligned}
            \prreadout_{\mora \mthen (\morb\mthen \morc)}\colon \prst_\mora \setconcat (\prst_\morb\setconcat \prst_\morc) &\to \prout_\morc\\
            \tupcatt{x_\mora}{x_\morb}{x_\morc} &\mapsto \prreadout_\morc(x_\morc).
        \end{aligned}
    \end{equation*}
\end{solution}


\section{Action on sequences}

Let's now look at how machines like the above acts on sequences.

For now we only have defined semi-group, monoid, and group actions, and have not talked yet about (semi)category actions.
Let's consider the set of machines systems with~$\prin = \prout = \prgen$, which is the homset~$\HomSet\Moore\prgen\prgen$.

Given a finite input sequence~$u\colon \natnumbers \to \prgen$ of length~$n$, the output is an instantaneous transformation of the state:
%
\begin{equation}
    \label{eq:actions-on-sequences-y}
    \begin{aligned}
        y_0 &= \prreadout(x_0) \\
        y_1 &= \prreadout(x_1) \\
        y_2 &= \prreadout(x_2) \\
        \dots &= \dots  \\
        y_{k} &= \prreadout(x_{k-1})
    \end{aligned}
\end{equation}
%
The state is computed recursively as follows:
\begin{equation}
    \label{eq:actions-on-sequences-x}
    \begin{aligned}
        x_0 &= \prdyn(u_0, \prstart) \\
        x_1 &= \prdyn(u_1, x_0) \\
        x_2 &= \prdyn(u_2, x_1) \\
        \dots &= \dots \\
        x_{k} &= \prdyn(u_{k}, x_{k-1})
    \end{aligned}
\end{equation}
%
Therefore, given a machine~$\mora \colon \prgen \to_{\Moore} \prgen$ we have defined a map from $\natnumbers \to \prgen$ to itself.
Let's call it $\act$.
It is defined as a map of the form
%
\begin{equation}
    \label{eq:actions-on-sequences-1}
    \act_{\mora}\colon  (\natnumbers \to \prgen)  \sto  (\natnumbers \to \prgen),
\end{equation}
%
or, more formally,
%
\begin{equation}
    \label{eq:actions-on-sequences-2}
    \act: \HomSet\Moore\prgen\prgen \sto \Endof {\natnumbers \to \prgen}.
\end{equation}
%
Note that both~$\HomSet\Moore\prgen\prgen$ and $\Endof {\natnumbers \to \prgen}$ are semigroups.
Could it be that~$\act$ is a semigroup morphism? And, consequently, is~$\act$ a covariant semigroup action or a contravariant action?

Let's check the condition for it being a morphism (\cref{eq:sgrp-mor-comp}):
%
\begin{align}
    \act ( \mora \mthen_{\Moore} \morb) &\stackrel{?}{=}  \act ( \mora) \mthen_{\Endof  {\natnumbers \to \prgen}} \act(\morb) \label{eq:actions-on-sequences-left} \\
    \act ( \morb \mthen_{\Moore} \mora) &\stackrel{?}{=}  \act ( \mora) \mthen_{\Endof  {\natnumbers \to \prgen}} \act(\morb) \label{eq:actions-on-sequences-right}
\end{align}
\begin{publictodo}
    Rest of the section is missing.
\end{publictodo}

\todographicsjira{57}{@Gioele: check graphically}


\section{More machines}



We can define many different types of machines.

\linkvideo{spring2021-actions:semi-actions:processes:more} % More machines
A Moore machine outputs 1 element at each time step; what if the machine was able to output more than one or zero output?

The signature of this machine would be this:
%
\begin{equation}
    \label{eq:more-signature}
    \begin{cases}
        \prdyn \colon \seqsof\prin \sto \Endof \prst \\
        \prreadout \colon \prst \sto \seqsof \prout
    \end{cases}
\end{equation}
%
where the output is not just~$\prout$ but~$\seqsof \prout$: the machine can produce zero or more outputs.
We call these \emph{More} machines.

\begin{exercise}
    Define the semi-category~\More of More machines.
\end{exercise}
\begin{solution}
    \begin{publictodo}
        Solution not available yet.
    \end{publictodo}
    \todotextjira{60}{@Gioele: write solution / definition of More Machines.
    Actually maybe remove as an exercise and make it part of the text.}
\end{solution}


