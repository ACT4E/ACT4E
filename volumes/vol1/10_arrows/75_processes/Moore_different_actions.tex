% !TEX root = chapter-standalone.tex

\section{Different actions of Moore machines}
\label{sec:different-actions-of-moore-machines}


Moore machines need not necessarily act in the standard way given in \cref{def:moore-standard-action-on-sequences}. In this section, we illustrate other actions of Moore machines. 

\subsection{Changing how morphisms act}

Recall that, given a Moore machine $\mora = \tup{\prinL,\prstL,\proutL,\prdyn,\prreadout,\prstart}$, the standard action defined a function 
\begin{equation}
{\prinL}^\natnumbers \to {\proutL}^\natnumbers
\end{equation}
via solving the recursion equations 
\begin{equation}
\label{eq:moore-recursion-once-again}
    \begin{cases}
        x_{k+1} = \prdyn_\mora(u_k \tupconcat x_k) \\
        y_{k}   = \prreadout_\mora(x_{k}).
    \end{cases}
\end{equation}

One way define other actions is by changing \cref{eq:moore-recursion-once-again} to some other recipe. It is necessary then to check that the resulting action really satisfies the condition of \cref{def:semicategory-action}. 

For example, consider the recursion equations
\begin{equation}
\label{eq:moore-new-recursion-equations}
    \begin{cases}
        x_{k+1} = \prdyn_\mora(u_k \tupconcat x_k) \\
        \tilde x_{k+1} = \prdyn_\mora(x_{k+1} \tupconcat \tilde x_k) \\
        y_{k}   = \prreadout_\mora(\tilde x_{k}).
    \end{cases}
\end{equation}
Given  $\mora = \tup{\prinL,\prstL,\proutL,\prdyn,\prreadout,\prstart}$ we can use these to define an action of $\mora$ by interpreting the variables $x_k$ and $\tilde x_k$ (for all $k \in \natnumbers$) both as denoting elements of $\prstL$, and setting $x_0 = \tilde x_0 = \prstart$. The rest is analogous to how we defined the standard action: given a sequence $u = u_0, u_1, u_2, \dots$ we can iteratively compute from it sequences $x = x_0, x_1, x_2, \dots $ and $\tilde x = \tilde x_0, \tilde x_1, \tilde x_2, \dots$, and then the output sequence $y = y_0, y_1, y_2, \dots $ is defined by $y_{k}   = \prreadout_\mora(\tilde x_{k})$


\begin{example}
\label{exa:moore-non-standard-action-on-sequences}
Let's consider the same Moore machine $\mora$ as in \cref{exa:moore-standard-action}, but now let's consider the action that uses \cref{eq:moore-new-recursion-equations}, instead of the standard action. If we give the same input sequence as we did in \cref{exa:moore-standard-action}, what does the corresponding output sequence look like now?

Let's calculate the first five entries of the output sequence. 

First, recall that $\prinL = \prstL = \proutL = \cObj{\natnumbers}$
and 
\begin{equation}
\defmapset{
\prdyn_\mora
}{
\prinL \cprod \prstL
}{
\prstL
}{
\tup{m} \tupconcat \tup{n}
}{
\tup{m + n}
}
\end{equation}
and 
\begin{equation}
\defmapset{
\prreadout_\mora
}{
\prstL
}{
\proutL
}{
\tup{n}
}{
\tup{n+1}
}
\end{equation}
and $\prstart = \tup{0}$. 

The input sequence has the form $u = \tup{1}, \tup{2}, \tup{3}, \tup{4}, \tup{5}, \dots$. We first compute the first five entries of the sequences of states $x = x_0, x_1, x_2, \dots$ and $x = x_0, x_1, x_2, \dots$ that solve \cref{eq:moore-new-recursion-equations}:
\begin{align*}
x_0 &= \prstart = \tup{0}, \\
x_1 &= \tup{1 + 0} = \tup{1}, \\
x_2 &= \tup{2 + 1} = \tup{3}, \\
x_3 &= \tup{3 + 3} = \tup{6}, \\
x_4 &= \tup{4 + 6} = \tup{10}
\end{align*}
and
\begin{align*}
\tilde x_0 &= \prstart = \tup{0}, \\
\tilde x_1 &= \tup{1 + 0} = \tup{1}, \\
\tilde x_2 &= \tup{3 + 1} = \tup{4}, \\
\tilde x_3 &= \tup{6 + 4} = \tup{10}, \\
\tilde x_4 &= \tup{10 + 10} = \tup{20}.
\end{align*}
Applying $\prreadout_\mora$ to the entries the sequence $\tilde x$, the first five entries of the output sequence are:
\begin{align*}
y_0 &= \tup{0 + 1} = \tup{1}, \\
y_1 &= \tup{1 + 1} = \tup{2}, \\
y_2 &= \tup{4 + 1} = \tup{5}, \\
y_3 &= \tup{10 + 1} = \tup{11} \\
u_4 &= \tup{20 + 1} = \tup{21}.
\end{align*}
\end{example}


\todotext{insert exercises here}


\begin{lemma}
The recursion equations \cref{eq:moore-new-recursion-equations} do indeed define a semicategory action of Moore machines in the sense of \cref{def:semicategory-action}. 
\end{lemma}

\todotext{make a graded exercise which is to prove the above lemma}


\subsection{Changing the signal spaces}


The action defined above using \cref{eq:moore-new-recursion-equations} differs from the standard action of \cref{sec:Moore-acting-on-sequences} in terms of how morphisms act; it defines a different map
\begin{equation}
\Mor_\Moore \to \Mor_\Set.
\end{equation}
However, the on the level of objects, the action stayed the same: 
\begin{equation}
 \Ob_{\Moore} \to \Ob_{\Set}, \prinL \mapsto \prinL^\natnumbers.
\end{equation}

Here we'll define an action which is different at the level of objects. Namely, we now make a different choice for a map
\begin{equation}
\funob{\act} \colon \Ob_{\Moore} \to \Ob_{\Set}.
\end{equation}
Instead of mapping any object $\Obja$ to the set of signals of the type $\Obja^\natnumbers$, which are sequences of elements of $\Obja$, our new action maps $\Obja$ to the set $\listsof{\Obja}$ of lists of elements of $\Obja$. In other words, we model Moore machines now as taking finite lists as inputs, rather than infinite sequences. 

On the level of morphisms, we will keep the recipe of the original standard action of Moore machines.

\begin{definition}
\label{def:moore-standard-action-on-lists}
We define the standard action of Moore machines on lists by 
\begin{equation}
\funob{\act} \colon \Ob_{\Moore} \to \Ob_{\Set}, \prinL \mapsto \listsof{\prinL}
\end{equation}
on the level of objects, and on the level of morphisms, the functions 
\begin{equation}
\funmor{\act} \colon  \HomSet{\Moore}{\prinL}{\proutL} \to \HomSet{\Set}{ \listsof{\prinL}}{\listsof{\proutL}}
\end{equation}
are defined via the recursion equations
\begin{equation}
\label{eq:moore-recursion-once-again}
    \begin{cases}
        x_{k+1} = \prdyn_\mora(u_k \tupconcat x_k) \\
        y_{k}   = \prreadout_\mora(x_{k})
    \end{cases}
\end{equation}
analogously as for the standard action on sequences. The only special cases are when the empty list $\maketypedlist{\ }{\prinL}$ is the input: then we set 
$$
\funmor{\act}(\mora)(\maketypedlist{\ }{\prinL}) = \maketypedlist{ \prreadout_\mora(\prstart_\mora) }{\proutL}
$$
for any Moore machine $\mora = \tup{\prinL,\prstL,\proutL,\prdyn,\prreadout,\prstart}$.
\end{definition}

\begin{example}
\label{exa:moore-non-standard-action-on-lists}
Let's consider the same Moore machine $\mora$ as in \cref{exa:moore-standard-action} and \cref{exa:moore-non-standard-action-on-sequences}, namely with $\prinL = \prstL = \proutL = \cObj{\natnumbers}$
and 
\begin{equation}
\defmapset{
\prdyn_\mora
}{
\prinL \cprod \prstL
}{
\prstL
}{
\tup{m} \tupconcat \tup{n}
}{
\tup{m + n}
}
\end{equation}
and 
\begin{equation}
\defmapset{
\prreadout_\mora
}{
\prstL
}{
\proutL
}{
\tup{n}
}{
\tup{n+1}
}
\end{equation}
and $\prstart = \tup{0}$. 

If we take the list 
$$
\maketypedlist{\tup{1}, \tup{2}, \tup{3}, \tup{4}, \tup{5}}{\prinL}
$$
as input, then the corresponding output is 
$$
\maketypedlist{\tup{0}, \tup{2}, \tup{3}, \tup{6}, \tup{10}}{\proutL},
$$
analogous to \cref{exa:moore-standard-action}. 

If we take $\maketypedlist{\ }{\prinL}$ as input, then the output is $\maketypedlist{\tup{0}}{\proutL}$.
\end{example}


\todotext{include another example?}

\begin{lemma}
\cref{def:moore-standard-action-on-lists} defines a semicategory action. 
\end{lemma}

\todotext{make a graded exercise which asks for a proof of this lemma}




