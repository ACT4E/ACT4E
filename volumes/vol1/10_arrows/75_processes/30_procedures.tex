% !TEX root = chapter-standalone.tex


\section{\statusdraft{Procedures}}

\todotext{Difference between functions and procedures. Model resources.}

\todotext{We don't introduce type theory, say we are in FinSet.}

\subsection{Modeling execution time}

\todotext{A procedure is a pair of function and of a non-negative integer. }

\subsection{Modeling data size}

An object is a function $A \to \natnumbers $. This is the size function.


A morphism from $X: A \to \natnumbers $ to $Y: B \to \natnumbers$ is a pair of morphisms
$f: A \to B$ and $g: \natnumbers \to \natnumbers$.

\todotext{To finish. Define composition and identities the obvious way. Prove associativity. Nice pics.}

\subsection{Modeling data-size-dependent running times}

Same object as before.


A morphism from $X\colon A \to \natnumbers $ to $Y\colon B \to \natnumbers$ is a tuple $f, g, h$ of morphisms
$f\colon A \to B$, $g\colon \natnumbers \to \natnumbers$, $h\colon \natnumbers \to \reals$. The function $h$ measures
how much time it takes to compute the result given a certain size of the input.

Given the two morphisms $m_1 = \tup{f_1, g_1, h_1}$ and $m_2 = \tup{f_2, g_2, h_2}$, the composite
$m_{12} = \tup{f_{12}, g_{12}, h_{12}}$ is given by
%
\begin{eqnarray}
  f_{12} =& f_1 \then f_2 \\
  g_{12} =& g_1 \then g_2 \\
\end{eqnarray}
%
\begin{eqnarray}
  h_{12} : \natnumbers & \to \reals \\
  n & \mapsto h_1(n) + h_2( g_1 (n))
\end{eqnarray}
\todotext{To finish. Define composition and identities the obvious way.}
