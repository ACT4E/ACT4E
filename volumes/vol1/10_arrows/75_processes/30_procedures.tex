% !TEX root = chapter-standalone.tex


\section{Procedures}
\begin{publictodo}
    We are going to define procedures: functions that have associated resources usage.
\end{publictodo}

%\linkvideo{spring2021-actions:semi-actions:processes} % Signals and processes

\devel{

    \todotextjira{61}{@Andrea: Difference between functions and procedures. Model resources. We don't introduce type theory, say we are in FinSet.}

    \subsection{Modeling execution time}

    \todotextjira{62}{@Andrea: A procedure is a pair of function and of a non-negative integer. }

    \subsection{Modeling data size}

    An object is a function~$A \to \natnumbers $. This is the size function.

    A morphism from~$X\colon A \to \natnumbers$ to~$Y\colon B \to \natnumbers$ is a pair of morphisms~$f\colon A \to B$ and~$g\colon \natnumbers \to \natnumbers$.

    \todotextjira{63}{@Andrea: To finish. Define composition and identities the obvious way. Prove associativity. Nice pics.}

    \subsection{Modeling data-size-dependent running times}

    The objects are the same as before.

    A morphism from~$X\colon A \to \natnumbers$ to~$Y\colon B \to \natnumbers$ is a tuple~$\tup{f, g, h}$ of morphisms~$f\colon A \to B$,~$g\colon \natnumbers \to \natnumbers$, and~$h\colon \natnumbers \to \reals$.
    The function~$h$ measures how much time it takes to compute the result given a certain size of the input.

    Given the two morphisms~$m_1 = \tup{f_1, g_1, h_1}$ and~$m_2 = \tup{f_2, g_2, h_2}$, the composite~$m_{12} = \tup{f_{12}, g_{12}, h_{12}}$ is given by

    \begin{eqnarray}
        f_{12} =& f_1 \then f_2 \\
        g_{12} =& g_1 \then g_2 \\
    \end{eqnarray}
%
    \begin{eqnarray}
        h_{12} \colon \natnumbers & \to \reals \\
        n & \mapsto h_1(n) + h_2( g_1 (n))
    \end{eqnarray}
    \todotextjira{64}{@Andrea: To finish. Define composition and identities the obvious way.}
}
