% !TEX root = chapter-standalone.tex

\section{More machines}
\label{sec:more-machines}

\linkvideo{spring2021-actions:semi-actions:processes:more} % More machines
A Moore machine outputs 1 element at each step; what if a machine was able to output more than one or zero output?
We will call these \emph{More} machines.

We define their dynamics and readout to be of the form
%
\begin{equation}
    \label{eq:more-signature}
    \begin{cases}
        \prdyn \colon  \prinL \cprod \prstL \sto \prstL, \\
        \prreadout \colon \prstL  \sto \listsof \proutL,
    \end{cases}
\end{equation}
%
where the output set is not just~$\proutL$ but~$\listsof \proutL$, the set of finite list of elements of $\proutL$.
In other words, for a given state, the machine can produce zero or more outputs in the form of a list.

We'll specify Moore machines as a tuple~$\tupp{\prinL,\prstL,\proutL,\prdyn,\prreadout,\prstart}$, like we did for Moore machines.

\subsection{Composition}

Given More machines~$\mora = \tupp{\prinL_\mora,\prstL_\mora,\proutL_\mora,\prdyn_\mora,\prreadout_\mora,\prstart_\mora}$ and~$\morb = \tupp{\prinL_\morb,\prstL_\morb,\proutL_\morb,\prdyn_\morb,\prreadout_\morb,\prstart_\morb}$ with~$\proutL_\mora = \prinL_\morb$, their composition is the More machine with
\begin{equation}
    \label{eq:more-comp-good-1}
    \begin{aligned}
        \prinL_{\mora\mthen\morb}   & = \prinL_{\mora}, \\
        \prstL_{\mora\mthen\morb}   & = \prstL_{\mora} \cprod  \prstL_{\morb}, \\
        \prstart_{\mora\mthen\morb} & = \prstart_{\mora} \tupconcat \prstart_{\morb}, \\
        \proutL_{\mora\mthen\morb}  & = \proutL_{\morb}.
    \end{aligned}
\end{equation}
%
The dynamics of the composite $\mora \mthen \morb$ is
%
\begin{widepar}
    \begin{equation}
        \label{eq:more-comp-good-2}
        \defmapperiodset{
            \prdyn_{\mora\mthen\morb}
        }{
            \prinL_{\mora} \cprod \prstL_{\mora} \cprod \prstL_{\morb}
        }{
            \prstL_{\mora} \cprod \prstL_{\morb}
        }{
            \prinel \tupconcat \prstel_{\mora} \tupconcat \prstel_{\morb}
        }{
            \prdyn_{\mora} (\prinel \tupconcat \prstel_{\mora}) \tupconcat \prdyn_{\morb}(\tupentry{\proutel_\mora}{n} \tupconcat \prdyn_{\morb}(\tupentry{\proutel_\mora}{n-1}  \tupconcat \ldots \prdyn_{\morb}(\tupentry{\proutel_\mora}{1} \tupconcat \prstel_{\morb} )\ldots))
        }
    \end{equation}
    where~$\proutel_\mora = \prreadout_{\mora}(\prstel_{\mora}) \setin \listsof{\proutL_{\mora}}$ and~$n$ is its length.
\end{widepar}
\todotextjira{740}{Come back later to address notation for list entries (possibly use superscripts?)}
%
The readout of~$\mora \mthen \morb$ is
%
\begin{equation}
    \label{eq:more-comp-good-3}
    \defmapperiodset{
        \prreadout_{\mora\mthen\morb}
    }{
        \prstL_{\mora} \cprod \prstL_{\morb}
    }{
        \listsof{\proutL_{\morb}}
    }{
        \prstel_{\mora} \tupconcat \prstel_{\morb}
    }{
        \prreadout_{\morb}(\prstel_{\morb})
    }
\end{equation}

\begin{definition}[\More]
    \label{def:More}
    The \emph{semicategory of More machines} \More is given by:
    \begin{enumerate}
        \item \emph{Objects:} objects of~\SetL.
        \item \emph{Morphisms:}
              A morphism is a tuple
              \begin{equation}
                  \mora = \tupp{\prinL_{\mora},\prstL_{\mora}, \proutL_{\mora},\prdyn_{\mora},\prreadout_{\mora},\prstart_{\mora}},
              \end{equation}
              where:
              \begin{itemize}
                  \item $\prinL_{\mora},\prstL_{\mora}, \proutL_{\mora}$ are objects of~\SetL;
                  \item $\prstart_{\mora} \setin \prstL_{\mora}$;
                  \item $ \prdyn_{\mora} \colon \prinL_{\mora} \cprod \prstL_{\mora} \mto \prstL_{\mora}$;
                  \item $ \prreadout_{\mora} \colon \prstL_{\mora}  \mto \listsof{\proutL_{\mora}}$.
              \end{itemize}
        \item \emph{Composition of morphisms:}
              Composition is given by \cref{eq:more-comp-good-2,eq:more-comp-good-3}.
    \end{enumerate}
\end{definition}

\subsection{Examples}

\begin{example}[Duplicator]
    We consider an example of a More machine~$\duplicator$ which we call a \emph{duplicator}.
    Practically, this machine takes an input, and duplicates it.
    The machine is written as
    \begin{equation}
        \tupp{\prinL_{\duplicator},\prstL_{\duplicator},\proutL_{\duplicator},\prdyn_{\duplicator},\prreadout_{\duplicator},\prstart_{\duplicator}},
    \end{equation}
    where~$\prinL_{\duplicator}=\prstL_{\duplicator}=\proutL_\duplicator$, and
    \begin{equation}
        \defmapcomma{\prdyn_\duplicator}
        {\prinL_\duplicator \cprod \prstL_\duplicator}
        {\sto}
        {\prstL_\duplicator}
        {\prinel \tupconcat \prstel}
        {\prinel}
    \end{equation}
    %
    \begin{equation}
        \defmapcomma{\prreadout_\duplicator}
        {\prstL_\duplicator}
        {\sto}
        {\listsof{\proutL_\duplicator}}
        {\prstel}
        {\maketypedlist{\prstel,\prstel}{\proutL_\duplicator}}
    \end{equation}
    and~$\prstart=\emptytuple \setin \prstL_\duplicator$.
\end{example}

\begin{example}[Discarder]
    Here is an example of a More machine~$\discarder$ which we call a \emph{discarder}.
    Practically, this machine discards every other input.
    The machine is written as:
    \begin{equation}
        \tupp{\prinL_{\discarder},\prstL_{\discarder},\proutL_{\discarder},\prdyn_{\discarder},\prreadout_{\discarder},\prstart_{\discarder}},
    \end{equation}
    where~$\prstL_{\discarder}= \cObj{\makeset{\false,\true}} \cprod \prinL_\discarder$, and
    \begin{equation}
        \begin{aligned}
            \prdyn_\discarder\colon \prinL_\discarder \cprod \cObj{\makeset{\false,\true}} \cprod \prinL_\discarder & \sto \cObj{\makeset{\false,\true}} \cprod \prinL_\discarder \\
            \prinel \tupconcat \tup{\false} \tupconcat \prstel                                                      & \mapsto \tup{ \true} \tupconcat \prinel \\
            \prinel \tupconcat \tup{\true} \tupconcat \prstel                                                       & \mapsto\tup{ \false} \tupconcat \prinel,
        \end{aligned}
    \end{equation}
    %
    \begin{equation}
        \begin{aligned}
            \prreadout_\discarder\colon \cObj{\makeset{\false,\true}} \cprod \prinL_\discarder & \sto \listsof{\proutL_\discarder} \\
            \tup{\false} \tupconcat \prstel                                                    & \mapsto \maketypedlist{ \ }{\proutL_\discarder} \\
            \tup{\true} \tupconcat \prstel                                                     & \mapsto \maketypedlist{\prstel}{\proutL_\discarder}
        \end{aligned}
    \end{equation}
    and~$\prstart_\discarder = \tup{\false} \tupconcat \tup{\prstel} \setin \prstL_\discarder$, for an arbitrary~$\prstel\setin \prinL_\discarder$.
\end{example}

\todojira{589}{\alphubel: @Gioele: Example of More: Composition of duplicator and discarder gives identity action but not identity of cat}

\begin{example}[Terminator]
    We describe a More machine~$\terminator$ which we call a \emph{terminator}.
    Practically, this machine terminates any input, outputting an empty list.
    The machine is written as
    \begin{equation}
        \tupp{\prinL_{\terminator},\prstL_{\terminator},\proutL_{\terminator},\prdyn_{\terminator},\prreadout_{\terminator},\prstart_{\terminator}},
    \end{equation}
    where:
    \begin{equation}
        \defmapcomma{\prdyn_\terminator}
        {\prinL_\terminator \cprod \prstL_\terminator}
        {\sto}
        {\prstL_\terminator}
        {\prinel \tupconcat \prstel}
        {\prstel}
    \end{equation}
    %
    \begin{equation}
        \defmapcomma{\prreadout_\terminator}
        {\prstL_\terminator}
        {\sto}
        {\listsof{\proutL_\terminator}}
        {\prstL_\terminator}
        {
            \maketypedlist{ \ }{\proutL_\terminator}
        }
    \end{equation}
    and~$\prstart_\terminator \setin \prstL_\terminator$ can be any element.
\end{example}

% \subsection{More machines acting}

% \todojira{700}{missing actions of more machines}
