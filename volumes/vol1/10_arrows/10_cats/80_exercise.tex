\sectionexercises{Semicategories}
\label{sec:exercise-semicategories}

\subsection{Computable semicategories}

We need to make a couple of modifications to the theory to make sure we have implementations of categories that we can easily manipulate.

\begin{marginfigure}
    \includegraphics[width=4cm]{cat_natnotzero}
    \caption{Category with one object and one morphism}
    \label{fig:cat_natnotzero1}
\end{marginfigure}
We must take into account that a category is not a ``static'' data structure, like a graph, but rather a ``dynamic'' object that can grow.
For example, consider a semicategory with one object $\Obja$, and one morphism $\mora\colon\Obja \mto \Obja$, which is not the identity.
Then, even if the semicategory can be specified with a finite amount data (one object and one morphism) there are actually an infinite amount of morphisms:
\begin{equation}
    \HomSet{}{\Obja}{\Obja} = \makeset{\mora,\  (\mora\mthen\mora),\  (\mora\mthen\mora\mthen\mora),\  (\mora\mthen\mora\mthen\mora\mthen\mora),\  \dots}.
\end{equation}
So far, we have not seen a mechanism that, given two objects, allows to produce another object, but we will see several later (\eg, \cref{def:categorical-product}).

Our solution for software modeling is to distinguish among different ``generations'' of morphisms.
If a morphism is given explicitly, like $\mora$, we say it is ``of level 0''.
The levels increase every time we use the composition operator.

Let $\HomSet{i}{\Obja}{\Objb}$ be the set of morphisms of \emph{up to} level $i\geq 0$.
Note that the morphisms at level $i+1$ include all the morphism of level $i$:
\begin{equation}
    \prfperiod{
        i \leq j
    }{
        \HomSet{i}{\Obja}{\Objb} \setsubseteq \HomSet{j}{\Obja}{\Objb}
    }
\end{equation}
The regular hom-set is recovered as the union of all the levels:
\begin{equation}
    \HomSet{}{\Obja}{\Objb} = \bigcup_{i\geq0} \HomSet{i}{\Obja}{\Objb}.
\end{equation}

We need a rule to update the levels of morphisms.
We say that if $\mora$ has level $m$ and $\morb$ has level $n$, then the composition $\morc = \mora\mthen\morb$ is in level $\max(m,n) + 1$.
We can update the signature of the composition rule as follows:
\begin{equation}
    \prfperiod{
        \mora \setin \HomSet{m}{\Obja}{\Objb}
    }{
        \morb \setin \HomSet{n}{\Objb}{\Objc}
    }{
        (\mora\mthen\morb) \setin \HomSet{\max(m,n)+1}{\Obja}{\Objb}
    }
\end{equation}
A morphism could be obtained in different ways, which could give different levels.
We define ``the level'' of a morphism as the \emph{minimum} level at which it appears.

\begin{margintable}
    \caption{Generations of morphisms }
    \begin{tabular}{cl}
        level & new morphisms at level \\
        \hline
        0     & $\mora$ \\
        1     & $\mora^2$ \\
        2     & $\mora^3, \mora^4$ \\
        3     & $\mora^5, \mora^6, \mora^7, \mora^8$ \\
        4     & $\mora^9, \mora^{10}, \mora^{11}, \mora^{12}, $ \\
              & $\mora^{13}, \mora^{14}, \mora^{15}, \mora^{16}$
    \end{tabular}
    \label{tab:generations}

\end{margintable}

Take again the example of the category with one morphism $\mora\colon\Obja \mto \Obja$ in \cref{fig:cat_natnotzero1}.
\Cref{tab:generations} shows how each generation looks like.
For each row after the first,
we look in all the previous rows and find the result of all compositions, and we note the new ones that we have not obtained before.
For clarity, we write $\mora^n$ for the composition of $n$ copies of $\mora$.

There is one important property: if there is a finite number of morphisms at level 0, then there is a finite number of morphisms at each level.
There might still be an overall infinite number of morphisms, but this assumption allows us to look at finite slices of the infinity.

\vfill\pagebreak

\subsection{Interface}

\Cref{lst:SemiCategory} below shows the Python interface we chose to model a category.

Compared to the previous exercises about sets, relations, posets, there is one relevant difference:
we are not assuming anymore that the collections are finite sets.
However, we still assume that the set of objects and the hom-sets are instances of \EnumerableSet.

The class \SemiCategory is a generic class with the following type variables:
\begin{enumerate}
    \item The type variable \TypeVar{Ob} (object data) is the type of the objects;
    \item The type variable \TypeVar{Mor} (morphism data) is the type of the morphisms.
\end{enumerate}

The class \SemiCategory has the following methods:
\begin{enumerate}
    \item The method \funcname{objects} returns an \EnumerableSet of elements with type \TypeVar{Ob}.
          The optional parameter is the maximum level of the objects.
          If the value is \pystr{None}, the method must return all objects.
          So far we have not seen any way to create new objects from old; so far this argument will be unused.
    \item The method \funcname{hom}, given two objects, returns the \EnumerableSet for the morphisms in the hom-set (of type \TypeVar{Mor}).
          The optional parameter is the maximum level of the morphisms.
          If the value is \pystr{None},  it must return all objects.
    \item The method \funcname{identity} returns the identity for the given object, if it exists; otherwise, it raises \str{InvalidValue}.
    \item The method \funcname{compose} represents the composition operation.
          Recall from \cref{eq:semicategory-composition} that the signature of $\mthen$ is
          \begin{equation}
              \mthenof{\Obja,\Objb,\Objc}\colon \HomSet{\CatC}{\Obja}{\Objb} \cartprod \HomSet{\CatC}{\Objb}{\Objc}\mto \HomSet{\CatC}{\Obja}{\Objc}.
          \end{equation}
          That is, we need to specify 3 objects, and then the 2 morphisms.
          In total, 5 parameters.
\end{enumerate}

\vfill
\begin{widepar}
    \aligninner{%
        \begin{minipage}{15cm}
            \classlisting{SemiCategory}{}

        \end{minipage}
    }
\end{widepar}
\vfill
% \classlisting{Category}{}

% \classlisting{FiniteSemiCategory}{}
\clearpage

\subsection{Representation}

\margindatafilefig{cat_example1}{cat\_example1}{fig:cat_example1}
\begin{marginfigure}
    \todo{figure}
\end{marginfigure}

We now introduce a file format for representing categories.
A dictionary representing a category (\cref{fig:cat_example1}) has three fields:
\begin{enumerate}
    \item \fieldname{objects} describes the objects;
    \item \fieldname{morphisms} describes the morphisms;
    \item \fieldname{equations} describes known equations between morphisms.
\end{enumerate}
Each object and morphism has a string label.
In this example, there is only 1 object called \str{X}
and one morphism called \str{f}.

Objects and morphisms have data attached to them.
For an object, it is given by the field \fieldname{obdata}.
For a morphism, it is given by the field \fieldname{mordata}.

Each object has also a field \fieldname{identity}.
If the value is none, it means that there is no identity for that object.
Otherwise, there is an identity called \str{id_OBJECT}. The field \fieldname{mordata} gives the additional data for the identity morphism.

In this example, the object \str{X} has the integer \str{1} associated to it, the morphism \str{f} has the data \str{"py"} associated to it, and the morphism \str{id_X} has the data \str{""} (empty string) associated to it.

For now, they are just objects without semantics; later we introduce a way to interpret the data.

The field \fieldname{equations} describes the assumptions about morphisms composition.
Each equation content is a string, consisting of two substrings separated by equality.
Each substring is the concatenation of morphism names with \str{;} as a separator. In this example, the string \str{f;f;f=f} is to be interpreted as the equation
\begin{equation}
    \label{eq:fffef}
    \mora \mthen \mora \mthen \mora = \mora.
\end{equation}

Therefore, in this example we are describing a category with 1 object and 3 morphisms: $\catidat\Obja$, $\mora$, and $\mora\mthen\mora$.
Note that $\mora \mthen \mora \mthen \mora$ does not appear in this list because it is equivalent to $\mora$ given \cref{eq:fffef}.

In the exercises, when you are given a category description like in~\cref{fig:cat_example1}, you will not be given \emph{all} morphisms \emph{explicitly}, but you need to generate them, based on the composition rules.

\subsection{More examples}

\bigyamlcols{cat_Zero}{A category with zero objects.}

\seprule

\bigyamlcols{cat_single}{A category with one object, no morphisms.}

\vfill\pagebreak

\bigyamlcols{cat_One}{A category with one object and its identity.}

\bigyamlcols{cat_fgh_notsame}{
    A category with three objects, three explicit morphisms $\mora,\morb,\morc$, and \emph{four} morphisms in total: $\mora,\morb,\morc,\mora\mthen\morb$.
}

\seprule
\bigyamlcols{cat_fgh_same}{
    A category with three objects, three explicit morphisms $\mora,\morb,\morc$ and the equation $\mora\mthen\morb=\morc$.
    There are now only 3 morphisms in total: $\mora,\morb,\morc$.

}
\seprule
\bigyamlcols{cat_natnotzero}{
    A category with one object, no identity, but a morphism.
    This is the first case in which there is an infinity of morphisms, starting with
    \begin{equation}
        \mora, \quad  \mora\mthen\mora,  \quad \mora\mthen\mora\mthen\mora,\quad  \dots.
    \end{equation}
}

\vfill
\pagebreak

\bigyamlcols{cat_natmod4}{
    A category with one object, the identity, one morphism and one equation $\mora\mthen\mora\mthen\mora\mthen\mora=\mora$.
    There are 4 morphisms:
    \begin{equation}
        \catidat\Obja, \quad \mora, \quad \mora\mthen\mora, \quad \mora\mthen\mora\mthen\mora.
    \end{equation}
    It's similar to counting in base 4.
}

\subsection{Reading categories}

In the file format that we have introduced, you should treat the \fieldname{obdata} and \fieldname{mordata} as opaque objects that are to be interpreted by two setoids that will be passed to you.
The interface hat you need to implement is in \cref{lst:SemiCategoryRepresentation}.
The function \funcname{load} has the following parameters:
\begin{enumerate}
    \item \str{h} is the usual \str{IOHelper};
    \item \str{data} is the Python data structure corresponding to the YAML.
    \item \str{ObData} is a setoid that is in charge of interpreting the \fieldname{obdata};
    \item \str{MorData} is a setoid that is in charge of interpreting the \fieldname{mordata};
    \item \str{compose} is the compose operation that will allow you to compose the morphisms.
\end{enumerate}
What you need to return is a semicategory with object type \str{RichObject} (\cref{lst:RichObject}) and morphism type \str{RichMorphism} (\cref{lst:RichMorphism}).
These are just wrappers that group together the label and the object data.

\classlisting{SemiCategoryRepresentation}{}

\classlisting{RichObject}
\classlisting{RichMorphism}

For example, in the case of \cref{fig:cat_example1}, you would return the object
\begin{minted}{python}
    RichObject("X", 1)
\end{minted}
and the morphism
\begin{minted}{python}
    RichObject("f", "df")
\end{minted}

To give you a more concrete idea of how the method will be called during the unit tests, here's an example usage.
We set  \str{ObData} and \str{MorData} to be the setoids of integers (\cref{lst:IntegerSetoid}) and strings (\cref{lst:StringSetoid}).
The \funcname{compose} function is just concatenation of strings.

\begin{minted}{python}
    ObData = IntegerSetoid()
    MorData = StringSetoid()
    def compose(od1: int, od2: int, od3: int, md1: str, md2: str) -> str:
        return md1 + md2
    yourcode: SemiCategoryRepresentation = ...
    data = ... # one of the examples
    h = ...
    sc = yourcode.load(
        h,
        data,
        ObData,
        MorData,
        compose
    )
\end{minted}

Once the semicategory is created, it will be queried.
For example, we will check if it has the correct objects and morphisms.

\begin{minted}{python}
    # for the first example, we expect this object to exist
    obx = GenericObject("X", 1)
    objects = sc.objects()
    assert objects.contains(obx)
    # ask for the homset of X
    homset = sc.hom(obx, obx)

    f = GenericMorphism('f', 'df')
    # let's ask for all morphisms in the homset until we find f
    for e in homset.elements():
        if homset.equal(morphism, f):
            break
    else:
        raise ValueError("cannot find morphism f ")
\end{minted}

\classlisting{IntegerSetoid}

\classlisting{StringSetoid}

\codeboilerplate{SemiCategoryRepresentation}{
    Write code to load a semicategory from its representation.
    Please read in details the rules below.
}

Some rules to keep in mind:

\begin{enumerate}
    \item When you compose two \str{RichMorphisms} with labels \str{"label1"} and \str{"label2"}, their new label should be \str{"label1;label2"}.
          Their \str{mordata} will be given by the \funcname{compose} function.
    \item Two morphisms are equal if any of the two conditions are met:
          \begin{enumerate}
              \item Their labels are related by an equation.
              \item Their \str{mordata} is equal based on what the setoid \str{MorData} thinks.
          \end{enumerate}
    \item Always return the shortest name for the morphisms.
          For example, if you can derive \str{f;g} and the equation \pystr{"f;g=h"} holds, you have to return the morphisms \str{f}, \str{g}, and \str{h}, because \str{h} is shorter than \str{f;g} even though they are equivalent.
\end{enumerate}

Some simplifications you can use:

\begin{enumerate}
    \item  \textbf{Simplification 1}:
          You have to return an \EnumerableSet from \funcname{hom}.
          The unit tests will not test the functions \funcname{load}, \funcname{save}, \funcname{contains} of this enumerable set, so you don't strictly need to implement them.
          However, it is important you implement \funcname{equals} and \funcname{elements}.
    \item \textbf{Simplification 2}:
          If the equation is of the form \pystr{"first=second"}, it is guaranteed that you only need to substitute the second term in place of the first to guarantee that you find all equalities, and you never need to substitute in the other directions.
          For example, if the equation is \pystr{"a;b;c=d;e"}, you will have to substitute the sequence \pystr{[d, e]} to \pystr{[a,b,c]}; that is, simplify the list of morphisms \pystr{[a,a,b,c,a]} to \pystr{[a,d,e,a]}.
          But you will never need to substitute \pystr{[a,b,c]} to \pystr{[d,e]}.
          As a result, you are guaranteed to have a \emph{confluent} system, in the sense that if you run all the substitutions you will eventually converge.

\end{enumerate}
