% !TEX root = chapter-standalone.tex

\section{Procedures}
\label{sec:procedures}

In programming, it is common to use the name \emph{function}; we keep that word to denote mathematical functions: morphisms of the category \Set.
We use the word \emph{procedure} to refer to pieces of code that run on a computer or virtual machine.

Procedures are richer than functions:
\begin{itemize}
    \item They might be non-deterministic: not always return the same value.
    \item They might have side-effects: change the world in some way.
    \item They have resource consumption associated to them: they need memory and computation to produce the result.
\end{itemize}

The category \Set is not sufficient to describe these properties, but we can easily invent categories that are built on top of \Set to add these properties.

We are going to do this in stages.
First, we are going to define a category of procedures that keeps track of running time.
Then we are going to keep track of time depending on the size of the input.
Finally, we are going to keep track of memory usage.

\subsection{Modeling execution time}
\label{subsec:modeling-execution-time}
We can model execution time by keeping track of an additional real number in the morphism.

\begin{definition}[Semicategory \ExecTime]
    \label{def:ExecTime}
    The semicategory~\ExecTime consists of the following constituents:
    \begin{enumerate}
        \item \emph{Objects}: The objects of~\ExecTime are the objects of \Set.
        \item \emph{Morphisms}: A morphism
              \begin{equation}
                  \mora \colon \Obja \mtoin\ExecTime \Obja
              \end{equation}
              is a pair $\tupp{\mora_e, t}$, where $\mora_e \colon \Obja \mtoin\Set \Objb$ is a regular function that describes what the procedure computes and $t>0$ is a real number representing ``execution time''.
        \item \emph{Composition operation}: Given two morphisms
              \begin{equation}
                  \mora \colon  \Obja\mtoin\ExecTime \Objb \qqand
                  \morb \colon  \Objb\mtoin\ExecTime \Objc,
              \end{equation}
              represented by $\tupp{\mora_e, t_1}$ and $\tupp{\morb_e, t_2}$, their composition is given by $\tupp{\mora_e\mthenof\Set\morb_e, t_1 + t_2 }$.
    \end{enumerate}
\end{definition}

This category allows distinguishing between different implementations of the same functions with different computational requirements.
For example, there could be two morphisms  $\tupp{\mora_e, 1}$  and  $\tupp{\mora_e, 10}$ which compute the same function, but the second takes 10 times as much.

\subsection{Modeling sized data}

The category \ExecTime models execution time, but it does not model how the execution time depends on the size of the input.

If we wanted to capture such ideas, we need to have an explicit way to talk about the size of the input.
%
For this we introduce ``sized sets''.

\begin{definition}[Sized set]
    \label{def:sized-set}
    A sized set is a pair $\tupp{\setA, \sizefun}$, where $\setA$ is a set, and
    $\sizefun \colon \setA \sto \natnumbers$ is the size function.
\end{definition}

For example, we could have $\setA = \text{lists of integers}$ and  $\sizefun = \text{length of list}$.

Now we can create a category whose objects are sized sets.

The procedures are morphisms that keep track of how the size of the input influences the size of the output.
For example, a sorting function produces an output that is the same size as the input, while a function that chooses an element of a list produces an output of size 1 no matter how big the dimension of the input is.

\begin{definition}[Semicategory \ProcSize]
    \label{def:ProcSize}
    The semicategory~\ProcSize consists of the following constituents:
    \begin{enumerate}
        \item \emph{Objects}: The objects are sized sets.
        \item \emph{Morphisms}: A morphism
              \begin{equation}
                  \mora \colon \Obja \mtoin\ProcSize \Obja
              \end{equation}
              between the two objects
              \begin{equation}
                  \Obja = \tupp{\setA, \sizefun_{\setA}}
                  \qqand
                  \Objb = \tupp{\setB, \sizefun_{\setB}}
              \end{equation}
              is a pair
              \begin{equation}
                  \tupp{\mora_e, \sizetran },
              \end{equation}
              where:
              \begin{enumerate}
                  \item $\mora_e : \setA \sto \setB$ is the function computed;
                  \item $\sizetran: \natnumbers \sto \natnumbers$ keeps track of how the size changes.
              \end{enumerate}

        \item \emph{Composition}: The composition of
              \begin{equation}
                  \tupp{\mora_e, \sizetran_{\mora} } \qqand
                  \tupp{\morb_e, \sizetran_{\morb} }
              \end{equation}
              is given by
              \begin{equation}
                  \tupp{\mora_e \mthen \morb_e,   \sizetran_{\mora} \mthen \sizetran_{\morb} }.
              \end{equation}
    \end{enumerate}
\end{definition}

\subsection{Modeling data-size-dependent running times}

Now we can create a category that keeps track of both data size and execution time, possibly dependent on data size.
\begin{definition}[Semicategory \ProcSizeTime]
    \label{def:ProcSizeTime}
    The semicategory~\ProcSizeTime consists of the following constituents:
    \begin{enumerate}
        \item \emph{Objects}: The objects are sized sets.
        \item \emph{Morphisms}: A morphism
              \begin{equation}
                  \mora \colon \Obja \mtoin\ProcSize \Obja
              \end{equation}
              between the two objects
              \begin{equation}
                  \Obja = \tupp{\setA, \sizefun_{\setA}}
                  \qqand
                  \Objb = \tupp{\setB, \sizefun_{\setB}}
              \end{equation}
              is a tuple
              \begin{equation}
                  \tupp{\mora_e, \sizetran, \timefun },
              \end{equation}
              where:
              \begin{enumerate}
                  \item $\mora_e : \setA \sto \setB$ is the function computed;
                  \item $\sizetran: \natnumbers \sto \natnumbers$ keeps track of how the size changes.
                  \item $\timefun: \natnumbers \sto \reals$ says what is the computation time as a function of instance size;
              \end{enumerate}

        \item \emph{Composition}: The composition of
              \begin{equation}
                  \tupp{\mora_1, \sizetran_1,  \timefun_1  }
                  \qqand
                  \tupp{\morb_2, \sizetran_2,  \timefun_2  }
              \end{equation}
              is given by
              \begin{equation}
                  \tupp{
                      \mora_1 \mthen \morb_2,
                      \sizetran_1 \mthen \sizetran_2,
                      \timefun_{1,2}
                  },
              \end{equation}
              where $\timefun_{1,2}$ is defined as
              \begin{equation}
                  \label{eq:timefun-composition}
                  \defmapperiodset{
                      \timefun_{1,2}
                  }{
                      \natnumbers
                  }{
                      \reals
                  }{
                      n
                  }{
                      \timefun_1(n) + \timefun_2(\sizetran_1(n))
                  }
              \end{equation}
    \end{enumerate}
\end{definition}

\begin{exercise}
    Check that associativity holds for the composition in \ProcSizeTime.
\end{exercise}
\begin{solution}
    The only nontrivial step is checking that associativity holds for composition of~$\timefun$.
    Consider 3 compatible morphisms~$\mora_1,\mora_2,\mora_3$.
    We know from~\cref{eq:timefun-composition} that
    \begin{equation}
        \timefun_{1;2} (n) = \timefun_1(n) + \timefun_2(\sizetran_1(n)).
    \end{equation}
    Now we compose~$\mora_{1;2}$ with~$\mora_3$.
    For~$\timefun$ we obtain
    \begin{align}
        \timefun_{(1;2);3}(n) & =  \timefun_{1;2}(n) + \timefun_3(\sizetran_{1;2}(n)) \\
                              & =  \timefun_1(n)
        + \timefun_2(\sizetran_1(n))
        + \timefun_3(\sizetran_2(\sizetran_1(n))) \label{eq:asbefore}
    \end{align}
    Instead, if we first compute~$\mora_2\mthen\mora_3$, we have
    \begin{equation}
        \timefun_{2;3} (n) = \timefun_2(n) + \timefun_3(\sizetran_2(n)).
    \end{equation}
    If we now compose~$\mora_1$ with~$\mora_2\mthen\mora_3$ we get:
    \begin{align}
        \timefun_{1;(2;3)} (n) & = \timefun_1(n) + \timefun_{2;3}(\sizetran_1(n)) \\
                               & = \timefun_1(n) + \timefun_2(n) + \timefun_3(\sizetran_2(\sizetran_1(n))),
    \end{align}
    which is the same as \cref{eq:asbefore}.
\end{solution}

% \iflabelexists{sec:ProcMod}{
%     \begin{remark}[Spoilers]
%         This example will be extended in \vref{sec:ProcMod}.
%     \end{remark}
% }

\vfill
\begin{gradedexercise}[\exname{Asymptotics}]
    The category \ProcSizeTime as defined thinks of time as real numbers, and size of the data as integers.
    In computer science, it is convenient to use \emph{asymptotic analysis}.
    For example, we know that, in the general case, ordering a list of $n$ elements takes $O(n \log n)$ steps.

    Discuss how you can extend or modify \ProcSizeTime to be able to capture asymptotic analysis.
\end{gradedexercise}

\solutionof{Asymptotics}

