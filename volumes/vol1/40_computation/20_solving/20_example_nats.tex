\section{Example: Optimizing over the natural numbers}

This is a simple example that can show two interesting properties of CDPIs:
\begin{enumerate}
    \item the ability to work with discrete posets; and
    \item the ability to treat multi-objective optimization problems.
\end{enumerate}
Consider the family of optimization problems indexed by~${\colF c}\setin\natnumbers$:
%
\begin{equation}
    \begin{cases}
        \Min_{\posleqof{\overline{\natnumbers}\Ptimes\overline{\natnumbers}}} & \tup{ {\colR x},{\colR y}},                                     \\
        \subto                                                                & x+y\geq\lceil\sqrt{x}\,\rceil+\lceil\sqrt{y}\,\rceil+{\colF c}.
    \end{cases}\label{eq:example-1}
\end{equation}
%
One can show that this optimization problem is a CDP by producing a co-design diagram with an equivalent semantics, such as the one in~\cref{fig:toydiagram}.

\begin{figure}[h]
    \centering
    \includegraphics[width=6.2cm]{gmcdptro_example_diagram}
    \caption{Co-design diagram equivalent to~\cref{eq:example-1}}
    \label{fig:toydiagram}
    \todographics{@Gioele: redo diagram}
\end{figure}

The diagram contains three primitive DPIs: $\adp_{1},$ $\adp_{2}$ (used twice), and $\adp_{3}$.
Their \ftor maps are:
\begin{eqnarray*}
    \ftor_{1}\colon {\colF\overline{\natnumbers}\Ptimes\overline{\natnumbers}\Ptimes\overline{\natnumbers}} & \to & {\colR\fantichains\overline{\natnumbers}},\\
    \tup{ \funan{1},\funan{2},\funan{3}}  & \mapsto & \makeset{\funan{1}+\funan{2}+\funan{3}},\\
    \ftor_{2}\colon {\colF\overline{\natnumbers}} & \rightarrow & {\colR\fantichains\overline{\natnumbers}},\\
    \fun& \mapsto & \makeset{\lceil\sqrt{\fun}\,\rceil},\\
    \ftor_{3}\colon{\colF\overline{\natnumbers}} & \rightarrow & {\colR\fantichains(\overline{\natnumbers}\Ptimes\overline{\natnumbers})},\\
    \fun& \mapsto & \makeset{\tup{ a,b} \setin\overline{\natnumbers}\Ptimes\overline{\natnumbers}\colon a+b=\fun}.
\end{eqnarray*}

\begin{marginfigure}
    \includesag{toydiagram_tree}
    \caption{}
    \label{fig:toydiagram_tree}
\end{marginfigure}

The tree decomposition (\cref{fig:toydiagram_tree}) corresponds to the expression
%
\begin{equation}
    \adp=\dploop(\dpseries(\dppar(\adpan{2},\adpan{2}),\dpseries(\adpan{1},\adpan{3}))).
    \label{eq:expression}
\end{equation}
%
From~\cref{eq:expression} we obtain an expression for~\ftor:
%
\begin{equation}
    \ftor=\left((\ftor_{2}\oppar\ftor_{2})\opseries\ftor_{1}\opseries\ftor_{3}\right)^{\oploop}.
    \label{eq:h}
\end{equation}
%
This problem is small enough that we can write down an explicit expression for~\ftor.
By substituting in~\cref{eq:h} the definitions for $\oppar, \oploop, \opseries$, we obtain that evaluating~$\ftor(\F{c})$ means finding the \SY{least fixed point} of a map~$\Psi_{\F{c}}$:
%
\begin{equation}
    \ftor:\F{c}\mapsto\lfp(\Psi_{\F{c}}).
\end{equation}
%
The map $\Psi_{\F{c}}:\R{\fantichains(\overline{\natnumbers}\Ptimes\overline{\natnumbers})}\rightarrow\R{\fantichains(\overline{\natnumbers}\Ptimes\overline{\natnumbers})}$ can be obtained from~\cref{prop:loop-continuous} as follows:
%
\begin{equation}
    \Psi_{\F{c}}:\RR\mapsto\Min\bigsetunion_{\tup{ x,y} \setin\RR}\upit\tup{ x,y} \setintersection\qquad\qquad\qquad\qquad
\end{equation}
%
\begin{equation}
    \setintersection \makesett{
        \tup{ a,b} \setin\natnumbers^{2}:
        (
        a+b\geq\lceil\sqrt{x}\,\rceil+\lceil\sqrt{y}\,\rceil+\F{c}
        )
    }.
\end{equation}
%

\begin{figure}
    \centering
    \includegraphics[bb=0bp 0bp 458bp 621bp,clip,scale=0.5]{gmcdptro_example20}
    \caption{
        Kleene ascent to solve the problem~\cref{eq:example-1} for $\F{c}=20$.
        The sequence converges in five steps to $\RR_{5}=\RR_{\infty}$.
    }
    \label{fig:example24}
    \todographics{@Gioele: remake figures}
\end{figure}
%
Kleene's algorithm is the iteration $\RR_{k+1}=\Psi_{\F{c}}(\RR_{k})$ starting from
\begin{equation}
    \RR_{0}
    =
    \posbot_{\R{\fantichains(\overline{\natnumbers}\Ptimes\overline{\natnumbers})}}
    =\makeset{\tup{ 0,0} }.
\end{equation}
%
For $\F{c}=0$, the sequence converges immediately:
%
\begin{equation}
    \RR_{0}=\makeset{\boldsymbol{\tup{0,0}}}=\ftor(\F{0}).
\end{equation}
%
For~$\F{c}=1$, the sequence converges at the sixth step; however, some solutions (in bold) converge sooner:
%
\begin{align}
    \RR_{0} & =\makeset{\tup{0,0} }, \\
    \RR_{1} & =\makeset{\tup{0,1},\tup{1,0}}, \\
    \RR_{2} & =\makeset{\tup{0,2},\tup{1,1}, \tup{2,0}}, \\
    \RR_{3} & =\makeset{\boldsymbol{\tup{0,3}},\tup{1,2}, \tup{2,1},\boldsymbol{\tup{3,0}}}, \\
    \RR_{4} & =\makeset{\boldsymbol{\tup{0,3}},\tup{2,2},\boldsymbol{\tup{3,0}}}, \\
    \RR_{5} & =\makeset{\boldsymbol{\tup{0,3}},\boldsymbol{\tup{3,0}}}=\ftor(\F{1}).
\end{align}
%
For~$\F{c}=2$, the sequence converges at the fifth step; however, some solutions (in bold) converge sooner:
%
\begin{align}
    \RR_{0} & =\makeset{\tup{ 0,0} }, \\
    \RR_{1} & =\makeset{\tup{ 0,2},\tup{ 1,1},\tup{ 2,0} }, \\
    \RR_{2} & =\makesett{ \boldsymbol{\tup{ 0,4} }, \tup{1,3}, \tup{2,2}, \tup{3,1}, \boldsymbol{\tup{ 4,0} }}, \\
    \RR_{3} & =\makeset{\boldsymbol{\tup{0,4} },\tup{ 3,2}, \tup{2,3}, \boldsymbol{\tup{ 4,0} }} \\
    \RR_{4} & =\makeset{\boldsymbol{\tup{0,4} },\boldsymbol{\tup{ 3,3}},\boldsymbol{\tup{ 4,0} }}=\ftor(\F{2}).
\end{align}
%
The next values in the sequence are:
%
\begin{align}
    \ftor(\F{3}) & =\makesett{ \boldsymbol{\tup{ 0,6} },\boldsymbol{\tup{ 3,4} },\boldsymbol{\tup{ 4,3} },\boldsymbol{\tup{ 6,0} }}, \\
    \ftor(\F{4}) & =\makesett{ \boldsymbol{\tup{ 0,7} },\boldsymbol{\tup{ 3,6} },\boldsymbol{\tup{ 4,4} },\boldsymbol{\tup{ 6,3} },\boldsymbol{\tup{ 7,0} }} .
\end{align}
%
\Cref{fig:example24}~shows the sequence for~$\F{c}=20$.

\subsection{Guarantees of Kleene ascent}

Solving an CDP with cycles reduces to computing a Kleene ascent sequence~$\RR_{k}$.
At each instant~$k$ we have some additional guarantees.

For any finite~$k$, the resources ``below''~$\RR_{k}$ (the set~$\ressp\ \backslash\upit\RR_{k}$,) are infeasible.
(In \cref{fig:example24}, those are colored in red.)

If the iteration converges to a non-empty \SY{antichain}~$\RR_{\infty}$, the \SY{antichain}~$\RR_{\infty}$ divides~\ressp in two.
Below the \SY{antichain}, all resources are infeasible.
However, above the \SY{antichain} (purple area), it is not necessarily true that all points are feasible, because there might be holes in the feasible set.
% as in \cref{exa:one}.
Note that this method does not compute the entire feasible set, but rather only the \emph{minimal elements} of the feasible set, which might be much easier to compute.

Finally, if the sequence converges to the empty set, it means that there are no solutions.
The sequence~$\RR_{k}$ can be considered a certificate of infeasibility.
