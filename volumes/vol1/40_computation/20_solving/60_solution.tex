% !TEX root = chapter-standalone.tex

\section{Solution of MCDPs}
\label{sec:Solution-of-Monotone}
\linkvideo{spring2021-functorial-comp-b:solving-queries:solving-series} % Series composition
\linkvideo{spring2021-functorial-comp-b:solving-queries:solving-parallel} % Parallel composition
\linkvideo{spring2021-functorial-comp-b:solving-queries:solving-loop} % Loop composition
\linkvideo{spring2021-functorial-comp-b:solving-queries:or-and-and} % Join and Meet in DP

The second main result is that the map \ftor of a MCDP has an explicit expression in terms of the maps~\ftor of the subproblems.

\begin{theorem}
    \label{thm:CDP-solvig}
    The map~\ftor for an MCDP has an explicit expression in terms of the maps \ftor of its subproblems, defined recursively using the rules in \cref{tab:correspondence}.
\end{theorem}

\begin{table}[h]
    \caption{Recursive expressions for \ftor.}
    \label{tab:correspondence}
    \centering{}\setlength\extrarowheight{5pt}\normalsize
    \begin{tabular}{ccc}
        series     & $\adp=\dpseries(\adp_{1},\adp_{2})$ & $\ftor=\ftor_{1}\opseries\ftor_{2}$\tabularnewline
        parallel   & $\adp=\dppar(\adp_{1},\adp_{2})$    & $\ftor=\ftor_{1}\oppar\ftor_{2}$\tabularnewline
        feedback   & $\adp=\dploop(\adp_{1})$            & $\ftor=\ftor_{1}^{\oploop}$\tabularnewline
        co-product & $\adp=\adp_{1}\sqcup\adp_{2}$       & $\ftor=\ftor_{1}\opcoprod\ftor_{2}$\tabularnewline
    \end{tabular}
\end{table}

\begin{proof}
    These expressions were derived in the proofs of~\cref{prop:dppar-monotone,prop:loop-continuous}.
    The operators $\opseries,\oppar,\oploop,\opcoprod$ are defined in \cref{def:opseries1}.
\end{proof}
\begin{definition}
    [Series operator~$\opseries$]
    \label{def:opseries1}
    For two maps~$\ftor_{1}\colon\funsp_{1}\rightarrow\Aressp_{1}$
    and~$\ftor_{2}\colon\funsp_{2}\rightarrow\Aressp_{2}$, if~$\ressp_{1}=\funsp_{2}$
    , define
    \begin{align*}
        {\displaystyle \ftor_{1}\opseries\ftor_{2}\colon\funsp_{1}}
                 & \rightarrow\Aressp_{2},                                                       \\
        \fun_{1} & \mapsto\Min_{\posleqof{\ressp_{2}}}\bigcup_{s\in\ftor_{1}(\fun)}\ftor_{2}(s).
    \end{align*}
\end{definition}

\begin{definition}
    [Parallel operator $\oppar$] \label{def:oppar}
    For two maps $\ftor_{1}\colon\funsp_{1}\rightarrow\Aressp_{1}$ and $\ftor_{2}\colon\funsp_{2}\rightarrow\Aressp_{2}$, define
    \begin{align}
        \ftor_{1}\oppar\ftor_{2}:(\funsp_{1}\cartprod\funsp_{2}) & \rightarrow\antichains(\ressp_{1}\cartprod\ressp_{2}),\label{eq:oppar} \\
        \tup{ \fun_{1},\fun_{2}}                                 & \mapsto\ftor_{1}(\fun_{1})\acprod\ftor_{2}(\fun_{2}),\nonumber
    \end{align}
    where $\acprod$ is the product of two antichains.
\end{definition}

\begin{definition}
    [Feedback operator $\oploop$]
    \label{def:oploop1}
    For $\ftor:\funsp_{1}\cartprod\ressp\rightarrow\Aressp$,
    define
    \begin{align}
        \ftor^{\oploop}:\funsp_{1} & \rightarrow\Aressp,\nonumber                     \\
        \fun_{1}                   & \mapsto\lfp\left(\Psi_{\fun_{1}}^{\ftor}\right),
    \end{align}
    where~$\Psi_{\fun_{1}}^{\ftor}$ is defined as
    \begin{align}
        \Psi_{\fun_{1}}^{\ftor}:\Aressp & \rightarrow\Aressp,\nonumber                                                                  \\
        {\colR R}                       & \mapsto\Min_{\posleqof{\ressp}}\bigcup_{\res\in{\colR R}}\ftor(\fun_{1},\res)\ \cap\upit\res.
        \label{eq:phi}
    \end{align}
\end{definition}

\begin{definition}
    [Coproduct operator $\opcoprod$]
    \label{def:opcoprod}
    For $\ftor_{1},\ftor_{2}:\funsp\rightarrow\Aressp$,
    define
    \begin{align*}
        \ftor_{1}\opcoprod\ftor_{2}:\funsp & \rightarrow\Aressp,                                                             \\
        \fun                               & \mapsto\Min_{\posleqof{\ressp}}\left(\ftor_{1}(\fun)\cup\ftor_{2}(\fun)\right).
    \end{align*}
\end{definition}

\subsection{Example: Optimizing over the natural numbers}

This is a simple example that can show two interesting properties of MCDPs:
\begin{enumerate}
    \item the ability to work with discrete posets; and
    \item the ability to treat multi-objective optimization problems.
\end{enumerate}
Consider the family of optimization problems indexed by~${\colF c}\in\natnumbers$:
\begin{equation}
    \begin{cases}
        \Min_{\posleqof{\overline{\natnumbers}\cartprod\overline{\natnumbers}}} & \tup{ {\colR x},{\colR y}} ,                                    \\
        \subto                                                                  & x+y\geq\lceil\sqrt{x}\,\rceil+\lceil\sqrt{y}\,\rceil+{\colF c}.
    \end{cases}\label{eq:example-1}
\end{equation}
One can show that this optimization problem is an MCDP by producing a co-design diagram with an equivalent semantics, such as the one in~\cref{fig:toydiagram}.

\begin{figure}[h]
    \subfloat[\label{fig:toydiagram}]{
        \centering{}\includegraphics[width=6.2cm]{gmcdptro_example_diagram}}
    \subfloat[\label{fig:toydiagram_tree}]{
        \begin{centering}
            \includegraphics[scale=0.33]{gmcdptro_example_diagram_tree}
        \end{centering}
    }

    \caption{Co-design diagram equivalent to~\cref{eq:example-1} and its tree representation.}
\end{figure}

The diagram contains three primitive DPIs: $\adp_{1},$ $\adp_{2}$ (used twice), and $\adp_{3}$.
Their \ftor maps are:
\begin{eqnarray*}
    \ftor_{1}:{\colF\overline{\natnumbers}\cartprod\overline{\natnumbers}\cartprod\overline{\natnumbers}} & \rightarrow & {\colR\antichains\overline{\natnumbers}},\\
    \tup{ \fun_{1},\fun_{2},\fun_{3}}  & \mapsto & \{\fun_{1}+\fun_{2}+\fun_{3}\},\\
    \ftor_{2}:{\colF\overline{\natnumbers}} & \rightarrow & {\colR\antichains\overline{\natnumbers}},\\
    \fun& \mapsto & \{\lceil\sqrt{\fun}\,\rceil\},\\
    \ftor_{3}:{\colF\overline{\natnumbers}} & \rightarrow & {\colR\antichains(\overline{\natnumbers}\cartprod\overline{\natnumbers})},\\
    \fun& \mapsto & \{\tup{ a,b} \in\overline{\natnumbers}\cartprod\overline{\natnumbers}:a+b=\fun\}.
\end{eqnarray*}
The tree decomposition (\cref{fig:toydiagram_tree}) corresponds to the expression
\begin{equation}
    \adp=\dploop(\dpseries(\dppar(\adp_{2},\adp_{2}),\dpseries(\adp_{1},\adp_{3}))).
    \label{eq:expression}
\end{equation}
Consulting \cref{tab:correspondence}, from~\cref{eq:expression} one obtains an expression for~\ftor:
\begin{equation}
    \ftor=\left((\ftor_{2}\oppar\ftor_{2})\opseries\ftor_{1}\opseries\ftor_{3}\right)^{\oploop}.
    \label{eq:h}
\end{equation}
This problem is small enough that we can write down an explicit expression for~\ftor.
By substituting in~\cref{eq:h} the definitions given in~\cref{def:opseries1,def:oploop1}, we obtain that evaluating~$\ftor(\F{c})$ means finding the least fixed point of a map~$\Psi_{\F{c}}$:
\begin{equation*}
    \ftor:\F{c}\mapsto\lfp(\Psi_{\F{c}}).
\end{equation*}
The map $\Psi_{\F{c}}:\R{\antichains(\overline{\natnumbers}\cartprod\overline{\natnumbers})}\rightarrow\R{\antichains(\overline{\natnumbers}\cartprod\overline{\natnumbers})}$ can be obtained from~\cref{eq:phi} as follows:

\begin{equation}
    \Psi_{\F{c}}:\RR\mapsto\Min\bigcup_{\tup{ x,y} \in\RR}\upit\tup{ x,y} \cap\qquad\qquad\qquad\qquad
\end{equation}
%
\begin{equation}
    \cap\left\{ \tup{ a,b} \in\natnumbers^{2}:\left(a+b\geq\lceil\sqrt{x}\,\rceil+\lceil\sqrt{y}\,\rceil+\F{c}\right)\right\}.
\end{equation}
%

\begin{figure}
    \begin{centering}
        \includegraphics[bb=0bp 0bp 458bp 621bp,clip,scale=0.5]{gmcdptro_example20}
    \end{centering}
    \caption{Kleene ascent to solve the problem~\cref{eq:example-1} for $\F{c}=20$.
        The sequence converges in five steps to $\RR_{5}=\RR_{\infty}.
        $ }
    \label{fig:example24}
\end{figure}

\noindent Kleene's algorithm is the iteration $\RR_{k+1}=\Psi_{\F{c}}(\RR_{k})$
starting from $\RR_{0}=\posbot_{\R{\antichains(\overline{\natnumbers}\cartprod\overline{\natnumbers})}}=\{\tup{ 0,0} \}$.

\noindent For $\F{c}=0$, the sequence converges immediately:
\begin{equation*}
    \RR_{0}=\{\boldsymbol{\tup{ 0,0} }\}=\ftor(\F{0}).
\end{equation*}
For~$\F{c}=1$, the sequence converges at the sixth step; however, some solutions (in bold) converge sooner:
\begin{align*}
    \RR_{0} & =\{\tup{0,0} \},                                                         \\
    \RR_{1} & =\{\tup{0,1},\tup{1,0}\},                                                \\
    \RR_{2} & =\{\tup{0,2},\tup{1,1}, \tup{2,0}\},                                     \\
    \RR_{3} & =\{\boldsymbol{\tup{0,3}},\tup{1,2}, \tup{2,1},\boldsymbol{\tup{3,0}}\}, \\
    \RR_{4} & =\{\boldsymbol{\tup{0,3}},\tup{2,2},\boldsymbol{\tup{3,0}}\},            \\
    \RR_{5} & =\{\boldsymbol{\tup{0,3}},\boldsymbol{\tup{3,0}}\}=\ftor(\F{1}).
\end{align*}
For~$\F{c}=2$, the sequence converges at the fifth step; however,
some solutions (in bold) converge sooner:
\begin{align*}
    \RR_{0} & =\{\tup{ 0,0} \},                                                                                      \\
    \RR_{1} & =\{\tup{ 0,2} ,\tup{ 1,1} ,\tup{ 2,0} \},                                                              \\
    \RR_{2} & =\left\{ \boldsymbol{\tup{ 0,4} }, \tup{1,3}, \tup{2,2}, \tup{3,1}, \boldsymbol{\tup{ 4,0} }\right\} , \\
    \RR_{3} & =\{\boldsymbol{\tup{0,4} },\tup{ 3,2}, \tup{2,3}, \boldsymbol{\tup{ 4,0} }\}                           \\
    \RR_{4} & =\{\boldsymbol{\tup{0,4} },\boldsymbol{\tup{ 3,3}},\boldsymbol{\tup{ 4,0} }\}=\ftor(\F{2}).
\end{align*}
The next values in the sequence are:
\begin{align*}
    \ftor(\F{3}) & =\left\{ \boldsymbol{\tup{ 0,6} },\boldsymbol{\tup{ 3,4} },\boldsymbol{\tup{ 4,3} },\boldsymbol{\tup{ 6,0} }\right\} ,                          \\
    \ftor(\F{4}) & =\left\{ \boldsymbol{\tup{ 0,7} },\boldsymbol{\tup{ 3,6} },\boldsymbol{\tup{ 4,4} },\boldsymbol{\tup{ 6,3} },\boldsymbol{\tup{ 7,0} }\right\} .
\end{align*}
\Cref{fig:example24}~shows the sequence for~$\F{c}=20$.

\subsection{Guarantees of Kleene ascent}

Solving an MCDP with cycles reduces to computing a Kleene ascent sequence~$\RR_{k}$.
At each instant~$k$ we have some additional guarantees.

For any finite~$k$, the resources ``below''~$\RR_{k}$ (the set~$\ressp\ \backslash\upit\RR_{k}$,) are infeasible.
(In \cref{fig:example24}, those are colored in red.)

If the iteration converges to a non-empty antichain~$\RR_{\infty}$, the antichain~$\RR_{\infty}$ divides~\ressp in two.
Below the antichain, all resources are infeasible.
However, above the antichain (purple area), it is not necessarily true that all points are feasible, because there might be holes in the feasible set, as in \cref{exa:one}.
Note that this method does not compute the entire feasible set, but rather only the \emph{minimal elements} of the feasible set, which might be much easier to compute.

Finally, if the sequence converges to the empty set, it means that there are no solutions.
The sequence~$\RR_{k}$ can be considered a certificate of infeasibility.
