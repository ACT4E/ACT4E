% !TEX root = chapter-standalone.tex


\section{Monads}
\label{sec:monads}

In the previous section we considered the operation of taking the powerset of a set. This was used to think about generalized sets and generalized functions: given a set $\setA$, we thought of its powerset $\powerset \setA$ as a set whose elements -- subsets of $\setA$ -- are ``generalized elements of $\setA$''. Furthermore we saw that it was possible to generalize a function $\mora : \setA \mto \setB$ to a function $\widehat \mora:  \setA \mto \powerset \setB$, and that such generalized functions could be composed. In this section we will see that this construction is possible because the operation of ``taking the powerset'' has a special structure to it: it is an example of a \emph{monad}. 

Before introducing the the general definition, let us approach this concept by listing some of the properties that make the ``powerset operation''  a monad. 

Firstly, note that the ``powerset operation'' can be viewed as functor $\Set \mto \Set$. For each object -- that is, for each set $\setA$ -- it produces a new set, $\powerset \setA$. For each function $\mora: \setA \mto \setB$ we define $\powerset \mora : \powerset \setA \mto \powerset \setB$ by
\begin{equation}\label{eq:powerset-functor}
 \subA \longmapsto \bigcup_{\ela \in \subA} \mora(\ela).
\end{equation}
In other words, $\powerset \mora$ maps a subset $\subA \subseteq \setA$ to its image under $\mora$, which is a subset of $\setB$. 


[INSERT EXERCISE: check that this is a functor]


Second, as noted in the previous section, each element $\ela \in \setA$ can be viewed as a ``generalized element'' $\{ \ela \} \in \powerset \setA$. So we have, for each set, a function $\monunit_\setA : \setA \to \powerset \setA, \ela \mapsto \{ \ela \}$. 
Furthermore, these maps are ``coherent'' with morphisms in $\Set$ in the sense that ...  In other words, the diagram ... commutes. This means precisely that the maps ... are the components of a natural transformation .... . 

Third, consider the question of how to compose generalized morphisms -- that is, how to define the mape \emph{fish}... We saw that... 

\begin{ctdefinition}[Monad]
  \label{def:monad}
  Let \CatC be a category. A \emph{monad} on \CatC is specified by:\\
  \constit
  \begin{compactenum}
    \item A functor~$ \monA \colon \CatC \fto \CatC$;
    \item A natural transformation~$\monunit \colon \funid_\CatC \nto \monA$, called the \emph{unit};
    \item A natural transformation~$\moncomp \colon \monAA \nto \monA$, called the \emph{composition} or \emph{multiplication}.
  \end{compactenum}
  \condit
  \begin{compactenum}
 \item \emph{Left and right unitality}: the diagrams
  \begin{center}\label{eq:monad-unitality}
    \includesag{55_monad_1}
  \end{center}
  must commute. 
  \item \emph{Associativity}: the diagram
  \begin{center}\label{eq:monad-associativity}
    \includesag{55_monad_2}
  \end{center}
  must commute.
  \end{compactenum}
\end{ctdefinition}

\begin{remark}
In terms of components, the unitality conditions state that for every object~$\Obja \in \ObC$, the diagrams

\includesag{monad_components}


commute. And the associativity condition states that for every object~$\Obja \in \ObC$,

\includesag{monad_components_bis}

commutes. 
\end{remark}

\todotext{I'm not sure if we every introduced ``whiskering'' and the notation for it (which is used in the diagrams in the definition of a monad). We should check and if needed introduce this in the section on natural transformations.}

\

\todotext{explain how the three conditions in the definition of a monad spell out in the case of the powerset monad (as Paolo does in his notes)}




\devel{

\begin{forslides}

\begin{equation}\label{eq:set-i-want-1}
\Obja 
\end{equation}

\begin{equation}\label{eq:set-i-want-2}
\Objb
\end{equation}

\begin{equation}\label{eq:set-i-want-3}
\Objc
\end{equation}

\begin{equation}\label{eq:morph-i-want-1}
\mora : \Obja \mto \Objb
\end{equation}

\begin{equation}\label{eq:morph-i-want-2}
\morb : \Objb \mto \Objc
\end{equation}


\begin{equation}\label{eq:set-apple-banana}
\Obja = \{ \sapple, \sbanana, \scarrot \}
\end{equation}

\begin{equation}\label{eq:fruit-sum-0}
  \sapple \sbanana \scarrot 
\end{equation}

\begin{equation}\label{eq:fruit-sum-1}
  [ \sapple ]   *   [\sbanana ] *   [\scarrot ]
\end{equation}

\begin{equation}\label{eq:fruit-sum-2}
 [ \sapple ]   *  [\sbanana  ]
\end{equation}

\begin{equation}\label{eq:fruit-sum-3}
 [\sbanana ] * [\scarrot]
\end{equation}

\begin{equation}\label{eq:fruit-sum-4}
 [ [\sapple]   *  [ \sbanana ] * [ \scarrot] ]
\end{equation}


\begin{equation}\label{eq:fruit-sum-5}
  [ [ \sapple ] ]
\end{equation}


\begin{equation}\label{eq:fruit-sum-6}
[ [ \sapple]   *  [\sbanana ] ]
\end{equation}


\begin{equation}\label{eq:fruit-sum-7}
 [ [ \sapple ] ] * [[ \sbanana ] ]  *  [[\scarrot]]
\end{equation}

\begin{equation}\label{eq:fruit-sum-7'}
 [ [ \sapple ]  * [ \sbanana ] ] *  [[\scarrot]]
\end{equation}

\begin{equation}\label{eq:fruit-sum-8}
 [ \sapple ]   *  [[ \sbanana ]  * [ \scarrot ]]
\end{equation}

\begin{equation}\label{eq:fruit-sum-9}
 [[ \sapple ]]  * [[ \sbanana ]] *  [[ \scarrot ]]
\end{equation}


\begin{equation}\label{eq:fruit-sum-10}
 [ \sapple ]   *  [ \sapple ]  *  [\sapple]  
\end{equation}

\begin{equation}\label{eq:fruit-sum-11}
 [ \sapple ]   *  [ \sapple ]  * [ \scarrot ]
\end{equation}

\begin{equation}\label{eq:fruit-sum-12}
[\sbanana ] * [ \sapple ]   
\end{equation}

\begin{equation}\label{eq:fruit-sum-13}
 [ \sapple ]   *  [ \sbanana ]  *  [ \scarrot ] 
\end{equation}

\begin{equation}\label{eq:fruit-sum-14}
[ [ \sapple ]   *  [ \sbanana ]  *  [ \scarrot ] ]
\end{equation}

\begin{equation}\label{eq:fruit-sum-15}
 [ [ \sapple ]  *  [\sbanana]  *  [\scarrot ]  ]
\end{equation}

\begin{equation}\label{eq:fruit-sum-16}
 [ \sapple ] 
\end{equation}

\begin{equation}\label{eq:fruit-sum-17}
 [ \sbanana ] 
\end{equation}

\begin{equation}\label{eq:fruit-sum-18}
 [ \scarrot ] 
\end{equation}

\begin{equation}\label{eq:fruit-sum-20}
 [ [ \sapple ]   * [ \sbanana] ] *  [[ \sapple ]   *  [ \sapple ] *  [\scarrot ] ]   *  [[ \sapple ] ]
\end{equation}



\end{forslides}

}



\begin{exercise}
  \todotext{Dummy exercise to check code}
\end{exercise}
\begin{solution}
  \todotext{to write}
\end{solution}


\begin{equation}\label{eq:monad-power-functor}
  \definemap{
    \powerset \mora 
  }{
    \powerset \Obja
  }{
    \powerset \Objb
  }{
    S
  }{
  \bigcup_{x\in S} \mora(x)
  }
\end{equation}

\begin{equation}\label{eq:monad-power-monunit}
  \definemap{
    \monunit_\Obja
  }{
    \Obja
  }{
    \powerset\Obja
  }{
    x
  }{
    \{ x \}
  }
\end{equation}


\begin{equation}\label{eq:monad-power-monunit-power}
  \definemap{
    \monunit_{\powerset \Obja}
  }{
    \powerset \Obja
  }{
    \powerset (\powerset\Obja)
  }{
    \{a, b, c\} 
  }{
    \{ \{a, b, c \} \}
  }
\end{equation}


\begin{equation}\label{eq:monad-power-power-monunit}
  \definemap{
    \powerset(\monunit_\Obja)
  }{
    \powerset \Obja
  }{
    \powerset (\powerset\Obja)
  }{
    \{a, b, c\} 
  }{
     \{ \{a\}, \{ b\}, \{c\} \} 
  }
\end{equation}


\begin{equation}\label{eq:monad-power-moncomp}
  \definemap{
    \moncomp_{\Obja}
  }{
    \powerset (\powerset\Obja)
  }{
    \powerset \Obja
  }{
    \{S_1, S_2, \dots \} 
  }{
     \bigcup_i  S_i
  }
\end{equation}


\begin{equation}\label{eq:monad-power-power-moncomp}
  \definemap{
    \powerset \moncomp_{\Obja}
  }{
    \powerset (\powerset (\powerset\Obja))
  }{
    \powerset (\powerset \Obja)
  }{
    \{  \{   \{a\}, \{b\} \} , \{ \{c\}, \{d\} \}\}
  }{
     \{  \{ a, b \}, \{ c, d \} \}
  }
\end{equation}


\begin{equation}\label{eq:monad-power-moncomp-power}
  \definemap{
    \moncomp_{\powerset \Obja}
  }{
    \powerset (\powerset (\powerset\Obja))
  }{
    \powerset (\powerset \Obja)
  }{
    \{  \{   \{a\}, \{b\} \} , \{ \{c\}, \{d\} \}\}
  }{
    \{    \{a\}, \{b\}  ,  \{c\}, \{d\}  \}
  }
\end{equation}


-------

\begin{equation}\label{eq:monad-arrow-functor}
  \definemap{
    \Arrow  \mora 
  }{
    \Arrow  \Obja
  }{
    \Arrow  \Objb
  }{
    \interv{a}{b}
  }{
    \interv{\mora(a)}{\mora(b)}
  }
\end{equation}

\begin{equation}\label{eq:monad-arrow-monunit}
  \definemap{
    \monunit_\Obja
  }{
    \Obja
  }{
    \Arrow\Obja
  }{
    x
  }{
    \interv{x}{x}
  }
\end{equation}


\begin{equation}\label{eq:monad-arrow-monunit-arrow}
  \definemap{
    \monunit_{\Arrow \Obja}
  }{
    \Arrow \Obja
  }{
    \Arrow (\Arrow\Obja)
  }{
    \interv{a}{b}
  }{
    \interv{\interv{a}{b}}{\interv{a}{b}}
  }
\end{equation}


\begin{equation}\label{eq:monad-arrow-arrow-monunit}
  \definemap{
    \Arrow(\monunit_\Obja)
  }{
    \Arrow \Obja
  }{
    \Arrow (\Arrow\Obja)
  }{
    \interv{a}{b}
  }{
    \interv{\interv{a}{a}}{\interv{b}{b}}
  }
\end{equation}


\begin{equation}\label{eq:monad-arrow-moncomp}
  \definemap{
    \moncomp_{\Obja}
  }{
    \Arrow (\Arrow\Obja)
  }{
    \Arrow \Obja
  }{
    \interv{\interv{\alpha}{\beta}}{ \interv{\gamma}{ \delta}}
  }{
    \interv{\min(\alpha, \gamma)}{\max(\beta, \delta)} = \interv{\alpha}{\delta}
  }
\end{equation}


\begin{equation}\label{eq:monad-arrow-arrow-moncomp}
  \definemap{
    \Arrow \moncomp_{\Obja}
  }{
    \Arrow (\Arrow (\Arrow\Obja))
  }{
    \Arrow (\Arrow \Obja)
  }{
    \interv{\interv{\interv{\alpha_1}{\beta_1}}{ \interv{\gamma_1}{ \delta_1}}}%
           {\interv{\interv{\alpha_2}{\beta_2}}{ \interv{\gamma_2}{ \delta_2}}}
  }{
    \interv{\interv{\alpha_1}{\delta_1}}{ \interv{\alpha_2}{ \delta_2}}
  }
\end{equation}


\begin{equation}\label{eq:monad-arrow-moncomp-arrow}
  \definemap{
    \moncomp_{\Arrow \Obja}
  }{
    \Arrow (\Arrow (\Arrow\Obja))
  }{
    \Arrow (\Arrow \Obja)
  }{
    \interv{\interv{\interv{\alpha_1}{\beta_1}}{ \interv{\gamma_1}{ \delta_1}}}%
    {\interv{\interv{\alpha_2}{\beta_2}}{ \interv{\gamma_2}{ \delta_2}}}
  }{
    \interv{\interv{\alpha_1}{\beta_1}}{ \interv{\gamma_2}{ \delta_2}}
  }
\end{equation}