% !TEX root = chapter-standalone.tex

\section{Monads}
\label{sec:monads}

In the previous section we considered the operation of taking the \SY{powerset} of a set.
This was used to think about generalized sets and generalized functions: given a set \setA, we thought of its \SY{powerset} $\powerset \setA$ as a set whose elements -- subsets of \setA -- are ``generalized elements of \setA''.
Furthermore, we saw that it was possible to generalize a function $\mora \colon \setA \mto \setB$ to a function $\widehat \mora \colon  \setA \mto \powerset \setB$, and that such generalized functions could be composed.
In this section we will see that this construction is possible because the operation of ``taking the \SY{powerset}'' has a special structure to it: it is an example of a \emph{monad}.

Before introducing the general definition, let us approach this concept by listing some of the properties that make the ``powerset operation'' a monad.

Firstly, note that the ``powerset operation'' can be viewed as \SY{functor}
\begin{equation}
    \powersetfunctor\colon \Set \fto \Set.
\end{equation}
For each object -- that is, for each set \setA -- it produces a new set, $\powerset \setA$.
For each function $\mora \colon \setA \mto \setB$ we define $\powersetfunctor \mora \colon \powerset \setA \mto \powerset \setB$ by
\begin{equation}
    \label{eq:powerset-functor}
    \subA \longmapsto \bigsetunion_{\ela \setin \subA} \mora(\ela).
\end{equation}
In other words, $\powerset \mora$ maps a subset $\subA \setsubseteq \setA$ to its image under $\mora$, which is a subset of \setB.

\begin{gradedexercise}[\exname{PowersetImageFunctor}]
    \label{ex:PowersetImageFunctor}
    Prove that ``taking the \SY{powerset}'' defines a \SY{functor} $\powersetfunctor : \Set \fto \Set$ if we define its component on morphisms as in \cref{eq:powerset-functor}.
\end{gradedexercise}
\solutionof{PowersetImageFunctor}

\devel{
    Second, as noted in the previous section, each element $\ela \setin \setA$ can be viewed as a ``generalized element'' $\makeset{ \ela } \setin \powerset \setA$.
    So we have, for each set, a function $\monunit_\setA : \setA \sto \powerset \setA, \ela \mapsto \makeset{ \ela }$.
    Furthermore, these maps are ``coherent'' with morphisms in \Set in the sense that \XXX In other words, the diagram \XXX commutes.
    This means precisely that the maps \XXX are the components of a \SY{natural transformation} \XXX .

    Third, consider the question of how to compose generalized morphisms -- that is, how to define the map \emph{fish} \XXX We saw that \XXX
}

\linkvideo{spring2021-monads-a:monad-def} % Monad definition
\begin{ctdefinition}[Monad]
    \label{def:monad}
    Let \CatC be a category.
    A \maindef{monad} on \CatC is specified by:\\
    \constit
    \begin{enumerate}
        \item A \SY{functor}~$ \monA \colon \CatC \fto \CatC$;
        \item A \SY{natural transformation}~$\moncomp \colon \monAA \nto \monA$, called the \emph{composition} or \emph{multiplication};
        \item A \SY{natural transformation}~$\monunit \colon \funidC \nto \monA$, called the \emph{unit}.
    \end{enumerate}
    \condit
    \begin{enumerate}
        \item \emph{Associativity}: the following diagram must commute:
              \equationsag{55_monad_2}{eq:monad-associativity}
        \item \emph{Left and right unitality}: the following diagrams must commute:
              \equationsag{55_monad_1}{eq:monad-unitality}
    \end{enumerate}
\end{ctdefinition}

\begin{remark}
    \label{rem:monad-condition-components}
    In terms of components, the unitality conditions state that for every object~$\Obja \setin \ObC$, the following diagram commute:
    \equationsag{monad_components}{eq:monad_components}
    The associativity condition states that for every object~$\Obja \setin \ObC$,
    the following diagram commutes:
    \equationsag{monad_components_bis}{eq:monad_components_bis}
\end{remark}

\todotextjira{230}{\alphubel: @JL: I'm not sure if we ever introduced ``whiskering'' and the notation for it (which is used in the diagrams in the definition of a monad).
    We should check and if needed introduce this in the section on \SY{natural transformations}.
}

\linkvideo{spring2021-monads-a:monad-powerset} % Powerset construction
\linkvideo{spring2021-monads-a:monad-interval} % Interval construction

\begin{gradedexercise}[\exname{PowersetMonad}]
    \label{ex:PowersetMonad}
    The aim of this exercise is to prove in full detail that the \SY{powerset} \SY{functor} $\powersetfunctor : \Set \fto \Set$ from \cref{ex:PowersetImageFunctor} is a monad, when equipped with the following \emph{unit} and \emph{multiplication}.
    We define $\monunit \colon \funidof\Set  \nto \powersetfunctor$ and $\moncomp \colon \powersetfunctor \fthen \powersetfunctor \nto \powersetfunctor$ in terms of components: given an object $\setA \setin \Set$, let
    \todotext{@JL: write these using defmap, on two lines}
    \begin{equation}
        \label{eq:powerset-mult-component}
        \moncomp_{\setA} \colon (\powersetfunctor \fthen \powersetfunctor)(\setA) \mto \powersetfunctor(\setA), \ \stylesets{D} \mapsto \bigsetunion_{\subA \setin \stylesets{D}} \subA
    \end{equation}
    and
    \begin{equation}
        \label{eq:powerset-unit-component}
        \monunit{_\setA} \colon \setA \mto \powersetfunctor(\setA), \ \ela \mapsto \makeset{ \ela }.
    \end{equation}
    To show that $\tup{\powersetfunctor, \moncomp, \monunit}$ is a monad,
    \begin{enumerate}
        \item prove that $\monunit$, as defined in components in \cref{eq:powerset-unit-component}, is a \SY{natural transformation};
        \item prove that $\moncomp$, as defined in components in \cref{eq:powerset-mult-component}, is a \SY{natural transformation};
        \item prove that $\monunit$ and $\moncomp$ satisfy the associativity condition and the left and right unitality conditions given in \cref{def:monad}.
              For this, work in components, as in \cref{rem:monad-condition-components}.
    \end{enumerate}
\end{gradedexercise}
\solutionof{PowersetMonad}

\showslides{
    \begin{forslides}
        \begin{equation}
            \label{eq:set-i-want-1}
            \Obja
        \end{equation}
        %
        \begin{equation}
            \label{eq:set-i-want-2}
            \Objb
        \end{equation}
        %
        \begin{equation}
            \label{eq:set-i-want-3}
            \Objc
        \end{equation}
        %
        \begin{equation}
            \label{eq:morph-i-want-1}
            \mora \colon \Obja \mto \Objb
        \end{equation}
        %
        \begin{equation}
            \label{eq:morph-i-want-2}
            \morb \colon \Objb \mto \Objc
        \end{equation}
        %
        \begin{equation}
            \label{eq:set-apple-banana}
            \Obja = \makeset{ \sapple, \sbanana, \scarrot }
        \end{equation}
        %
        \begin{equation}
            \label{eq:fruit-sum-0}
            \sapple \sbanana \scarrot
        \end{equation}
        %
        \begin{equation}
            \label{eq:fruit-sum-1}
            [ \sapple ]   *   [\sbanana ] *   [\scarrot ]
        \end{equation}
        %
        \begin{equation}
            \label{eq:fruit-sum-2}
            [ \sapple ]   *  [\sbanana  ]
        \end{equation}
        %
        \begin{equation}
            \label{eq:fruit-sum-3}
            [\sbanana ] * [\scarrot]
        \end{equation}
        %
        \begin{equation}
            \label{eq:fruit-sum-4}
            [ [\sapple]   *  [ \sbanana ] * [ \scarrot] ]
        \end{equation}
        %
        \begin{equation}
            \label{eq:fruit-sum-5}
            [ [ \sapple ] ]
        \end{equation}
        %
        \begin{equation}
            \label{eq:fruit-sum-6}
            [ [ \sapple]   *  [\sbanana ] ]
        \end{equation}
        %
        \begin{equation}
            \label{eq:fruit-sum-7}
            [ [ \sapple ] ] * [[ \sbanana ] ]  *  [[\scarrot]]
        \end{equation}
        %
        \begin{equation}
            \label{eq:fruit-sum-7-bis}
            [ [ \sapple ]  * [ \sbanana ] ] *  [[\scarrot]]
        \end{equation}
        %
        \begin{equation}
            \label{eq:fruit-sum-8}
            [ \sapple ]   *  [[ \sbanana ]  * [ \scarrot ]]
        \end{equation}
        %
        \begin{equation}
            \label{eq:fruit-sum-9}
            [[ \sapple ]]  * [[ \sbanana ]] *  [[ \scarrot ]]
        \end{equation}
        %
        \begin{equation}
            \label{eq:fruit-sum-10}
            [ \sapple ]   *  [ \sapple ]  *  [\sapple]
        \end{equation}
        %
        \begin{equation}
            \label{eq:fruit-sum-11}
            [ \sapple ]   *  [ \sapple ]  * [ \scarrot ]
        \end{equation}
        %
        \begin{equation}
            \label{eq:fruit-sum-12}
            [\sbanana ] * [ \sapple ]
        \end{equation}
        %
        \begin{equation}
            \label{eq:fruit-sum-13}
            [ \sapple ]   *  [ \sbanana ]  *  [ \scarrot ]
        \end{equation}
        %
        \begin{equation}
            \label{eq:fruit-sum-14}
            [ [ \sapple ]   *  [ \sbanana ]  *  [ \scarrot ] ]
        \end{equation}
        %
        \begin{equation}
            \label{eq:fruit-sum-15}
            [ [ \sapple ]  *  [\sbanana]  *  [\scarrot ]  ]
        \end{equation}
        %
        \begin{equation}
            \label{eq:fruit-sum-16}
            [ \sapple ]
        \end{equation}
        %
        \begin{equation}
            \label{eq:fruit-sum-17}
            [ \sbanana ]
        \end{equation}
        %
        \begin{equation}
            \label{eq:fruit-sum-18}
            [ \scarrot ]
        \end{equation}
        %
        \begin{equation}
            \label{eq:fruit-sum-20}
            [ [ \sapple ]   * [ \sbanana] ] *  [[ \sapple ]   *  [ \sapple ] *  [\scarrot ] ]   *  [[ \sapple ] ]
        \end{equation}

        \begin{equation}
            \label{eq:monad-power-functor}
            \defmapset{
                \powerset \mora
            }{
                \powerset \Obja
            }{
                \powerset \Objb
            }{
                S
            }{
                \bigsetunion_{x\setin S} \mora(x)
            }
        \end{equation}
        %
        \begin{equation}
            \label{eq:monad-power-monunit}
            \defmapset{
                \monunit_\Obja
            }{
                \Obja
            }{
                \powerset\Obja
            }{
                x
            }{
                \makeset{ x }
            }
        \end{equation}

        \begin{equation}
            \label{eq:monad-power-monunit-power}
            \defmapset{
                \monunit_{\powerset \Obja}
            }{
                \powerset \Obja
            }{
                \powerset (\powerset\Obja)
            }{
                \makeset{a, b, c}
            }{
                \makeset{ \makeset{a, b, c } }
            }
        \end{equation}

        \begin{equation}
            \label{eq:monad-power-power-monunit}
            \defmapset{
                \powerset(\monunit_\Obja)
            }{
                \powerset \Obja
            }{
                \powerset (\powerset\Obja)
            }{
                \makeset{a, b, c}
            }{
                \makeset{ \makeset{a}, \makeset{ b}, \makeset{c} }
            }
        \end{equation}

        \begin{equation}
            \label{eq:monad-power-moncomp}
            \defmapset{
                \moncomp_{\Obja}
            }{
                \powerset (\powerset\Obja)
            }{
                \powerset \Obja
            }{
                \makeset{S_1, S_2, \dots }
            }{
                \bigsetunion_i S_i
            }
        \end{equation}

        \begin{equation}
            \label{eq:monad-power-power-moncomp}
            \defmapset{
                \powerset \moncomp_{\Obja}
            }{
                \powerset (\powerset (\powerset\Obja))
            }{
                \powerset (\powerset \Obja)
            }{
                \makeset{  \makeset{   \makeset{a}, \makeset{b} }, \makeset{ \makeset{c}, \makeset{d} }}
            }{
                \makeset{  \makeset{ a, b }, \makeset{ c, d } }
            }
        \end{equation}

        \begin{equation}
            \label{eq:monad-power-moncomp-power}
            \defmapset{
                \moncomp_{\powerset \Obja}
            }{
                \powerset (\powerset (\powerset\Obja))
            }{
                \powerset (\powerset \Obja)
            }{
                \makeset{  \makeset{   \makeset{a}, \makeset{b} }, \makeset{ \makeset{c}, \makeset{d} }}
            }{
                \makeset{    \makeset{a}, \makeset{b}  ,  \makeset{c}, \makeset{d}  }
            }
        \end{equation}
        %
    \end{forslides}
}

\paragraph*{Example: interval construction}
In the following, we analyze the interval construction and show that it gives rise to a monad.
Given \Pos, we define the action of the $\ArrowFunctor$ \SY{functor} on objects (posets) as

\todotextjira{422}{@JL: I think we should use two different notations for the \SY{functor} for the monad and the actual arrow construction\dots}
\begin{equation}
    \label{eq:monad-arrow-functor-objects}
    \begin{aligned}
        \ArrowFunctor\colon \Obof\Pos & \to \Obof\Pos \\
        \posA                         & \mapsto \posintbis\posA
    \end{aligned}
\end{equation}
and on morphisms as
\begin{equation}
    \label{eq:monad-arrow-functor-morphisms}
    \begin{aligned}
        \Arrowof\mora \colon \posintbis\posA & \to \posintbis\posB \\
        \interv{a}{b}                        & \mapsto \interv{\mora(a)}{\mora(b)}.
    \end{aligned}
\end{equation}
%
Furthermore, we define the multiplication as
%
\begin{equation}
    \label{eq:monad-arrow-moncomp}
    \defmapset{
        \moncomp_{\Obja}
    }{
        \Arrowof {(\Arrowof\Obja)}
    }{
        \Arrowof \Obja
    }{
        \interv{\interv{\alpha}{\beta}}{ \interv{\gamma}{ \delta}}
    }{
        \interv{\min(\alpha, \gamma)}{\max(\beta, \delta)} = \interv{\alpha}{\delta},
    }
\end{equation}
%
and the unit as
%
\begin{equation}
    \label{eq:monad-arrow-monunit}
    \defmapset{
        \monunit_\Obja
    }{
        \Obja
    }{
        \Arrowof\Obja
    }{
        x
    }{
        \interv{x}{x}.
    }
\end{equation}
%
First, we need to show that both the multiplication and the unit are indeed \SY{natural transformations}.
We start with multiplication.
On the one hand, we have:
%
\begin{equation}
    \label{eq:example_arrow_nat_1}
    \begin{aligned}
        ((\ArrowFunctor\fthen \ArrowFunctor)(\mora) \mthen \moncomp_\Objb)(\interv{\interv{a}{b}}{\interv{c,d}}) & =\moncomp_\Objb(\interv{\interv{\mora(a)}{\mora(b)}}{\interv{\mora(c)}{\mora(d)}}) \\
                                                                                                                 & =\interv{\mora(a)}{\mora(d)}.
    \end{aligned}
\end{equation}
%
On the other hand we have:
%
\begin{equation}
    \label{eq:example_arrow_nat_2}
    \begin{aligned}
        (\moncomp_\Obja \fthen \ArrowFunctor)(\interv{\interv{a}{b}}{\interv{c}{d}})
         & =(\Arrowof\mora)(\interv{a}{d}) \\
         & =\interv{\mora(a)}{\mora(d)}.
    \end{aligned}
\end{equation}
%
The equivalence of \cref{eq:example_arrow_nat_1} and \cref{eq:example_arrow_nat_2} proves naturality.
We now check that the unit defines a \SY{natural transformation}.
We have
%
\begin{equation}
    \label{eq:example_arrow_nat_3}
    \begin{aligned}
        (\mora \mthen \monunit_\Objb)(x)
         & =\mora(x)\mthen \monunit_\Objb \\
         & =\interv{\mora(x)}{\mora(x)}
    \end{aligned}
\end{equation}
%
and
%
\begin{equation}
    \label{eq:example_arrow_nat_4}
    \begin{aligned}
        (\monunit_\Obja \mthen \Arrowof\mora)(x)
         & =(\Arrowof\mora)(\interv{x}{x}) \\
         & =\interv{\mora(x)}{\mora(x)}
    \end{aligned}
\end{equation}
%
Again, equivalence of \cref{eq:example_arrow_nat_3} and \cref{eq:example_arrow_nat_4} proves naturality.

We now need to check associativity and left and right unitality.
We start with associativity.
To clearly see the property holding, we need to define intermediate quantities.
We have
%
\begin{equation}
    \label{eq:monad-arrow-arrow-moncomp}
    \defmapset{
        \Arrowof {\moncomp_{\Obja}}
    }{
        \Arrowof {(\ArrowFunctor (\Arrowof(\Obja)))}
    }{
        \Arrowof {(\Arrowof\Obja)}
    }{
        \interv{\interv{\interv{\alpha_1}{\beta_1}}{ \interv{\gamma_1}{ \delta_1}}}%
        {\interv{\interv{\alpha_2}{\beta_2}}{ \interv{\gamma_2}{ \delta_2}}}
    }{
        \interv{\interv{\alpha_1}{\delta_1}}{ \interv{\alpha_2}{ \delta_2}}
    }
\end{equation}
%
and
%
\begin{equation}
    \label{eq:monad-arrow-moncomp-arrow}
    \defmapset{
        \moncomp_{\Arrowof \Obja}
    }{
        \ArrowFunctor (\ArrowFunctor (\Arrowof\Obja))
    }{
        \ArrowFunctor (\Arrowof\Obja)
    }{
        \interv{\interv{\interv{\alpha_1}{\beta_1}}{ \interv{\gamma_1}{ \delta_1}}}%
        {\interv{\interv{\alpha_2}{\beta_2}}{ \interv{\gamma_2}{ \delta_2}}}
    }{
        \interv{\interv{\alpha_1}{\beta_1}}{ \interv{\gamma_2}{ \delta_2}}
    }
\end{equation}
%
With this in mind, it is easy to see that the following diagram commutes.
%
\begin{center}
    \todographicsjira{260}{@Gioele: add associativity diagram in tikz.
        Take it from GZ recital.
    }
\end{center}
%
For left and right unitality, we need to work out two additional quantities:
%
\begin{equation}
    \label{eq:monad-arrow-monunit-arrow}
    \defmapset{
        \monunit_{\Arrowof\Obja}
    }{
        \Arrowof\Obja
    }{
        \Arrowof{\Arrowof\Obja)}
    }{
        \interv{a}{b}
    }{
        \interv{\interv{a}{b}}{\interv{a}{b}},
    }
\end{equation}
%
and
%
\begin{equation}
    \label{eq:monad-arrow-arrow-monunit}
    \defmapset{
        \Arrowof{(\monunit_\Obja)}
    }{
        \Arrowof\Obja
    }{
        \Arrowof{(\Arrowof\Obja)}
    }{
        \interv{a}{b}
    }{
        \interv{\interv{a}{a}}{\interv{b}{b}}.
    }
\end{equation}
\todotext{Content missing!}
%
\devel{
    With this in mind, it is easy to see that the following diagrams commute.
    %
    \todographicsjira{261}{
        @Gioele: add left and right diagrams in tikz.
        Take it from GZ recital.
    }
}
