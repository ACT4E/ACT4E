% !TEX root = chapter-standalone.tex

\section{Monads}
\label{sec:monads}

In the previous section we considered the operation of taking the powerset of a set.
This was used to think about generalized sets and generalized functions: given a set $\setA$, we thought of its powerset $\powerset \setA$ as a set whose elements -- subsets of $\setA$ -- are ``generalized elements of $\setA$''.
Furthermore we saw that it was possible to generalize a function $\mora : \setA \mto \setB$ to a function $\widehat \mora:  \setA \mto \powerset \setB$, and that such generalized functions could be composed.
In this section we will see that this construction is possible because the operation of ``taking the powerset'' has a special structure to it: it is an example of a \emph{monad}.

Before introducing the the general definition, let us approach this concept by listing some of the properties that make the ``powerset operation'' a monad.

Firstly, note that the ``powerset operation'' can be viewed as functor $\Set \mto \Set$.
For each object -- that is, for each set $\setA$ -- it produces a new set, $\powerset \setA$.
For each function $\mora: \setA \mto \setB$ we define $\powerset \mora : \powerset \setA \mto \powerset \setB$ by
\begin{equation}
    \label{eq:powerset-functor}
    \subA \longmapsto \bigcup_{\ela \in \subA} \mora(\ela).
\end{equation}
In other words, $\powerset \mora$ maps a subset $\subA \subseteq \setA$ to its image under $\mora$, which is a subset of $\setB$.

\begin{gradedexercise}[\exname{PowersetImageFunctor}]
    \label{ex:PowersetImageFunctor}
    Prove that ``taking the powerset'' defines a functor $\powerset : \Set \mto \Set$ if we define its component on morphisms as in \cref{eq:powerset-functor}.
\end{gradedexercise}
\solutionof{PowersetImageFunctor}

\devel{
    Second, as noted in the previous section, each element $\ela \in \setA$ can be viewed as a ``generalized element'' $\{ \ela \} \in \powerset \setA$.
    So we have, for each set, a function $\monunit_\setA : \setA \to \powerset \setA, \ela \mapsto \{ \ela \}$.
    Furthermore, these maps are ``coherent'' with morphisms in $\Set$ in the sense that \XXX In other words, the diagram \XXX commutes.
    This means precisely that the maps \XXX are the components of a natural transformation \XXX .

    Third, consider the question of how to compose generalized morphisms -- that is, how to define the mape \emph{fish} \XXX We saw that \XXX
}

\linkvideo{spring2021-monads-a:monad-def} % Monad definition
\begin{ctdefinition}[Monad]
    \label{def:monad}
    Let \CatC be a category.
    A \emph{monad} on \CatC is specified by:\\
    \constit
    \begin{enumerate}
        \item A functor~$ \monA \colon \CatC \fto \CatC$;
        \item A natural transformation~$\moncomp \colon \monAA \nto \monA$, called the \emph{composition} or \emph{multiplication};
        \item A natural transformation~$\monunit \colon \funid_\CatC \nto \monA$, called the \emph{unit}.
    \end{enumerate}
    \condit
    \begin{enumerate}
        \item \emph{Associativity}: the diagram
              \begin{center}
                  \label{eq:monad-associativity}
                  \includesag{55_monad_2}
              \end{center}
              must commute.
        \item \emph{Left and right unitality}: the diagrams
              \begin{center}
                  \label{eq:monad-unitality}
                  \includesag{55_monad_1}
              \end{center}
              must commute.
    \end{enumerate}
\end{ctdefinition}

\begin{remark}
    \label{rem:monad-condition-components}
    In terms of components, the unitality conditions state that for every object~$\Obja \in \ObC$, the diagrams

    \begin{center}
        \includesag{monad_components}
    \end{center}

    commute.
    And the associativity condition states that for every object~$\Obja \in \ObC$,

    \begin{center}
        \includesag{monad_components_bis}
    \end{center}

    commutes.
\end{remark}

\todotextjira{230}{@J: I'm not sure if we ever introduced ``whiskering'' and the notation for it (which is used in the diagrams in the definition of a monad).
    We should check and if needed introduce this in the section on natural transformations.
}

\linkvideo{spring2021-monads-a:monad-powerset} % Powerset construction
\linkvideo{spring2021-monads-a:monad-interval} % Interval construction

\begin{gradedexercise}[\exname{PowersetMonad}]
    \label{ex:PowersetMonad}
    The aim of this exercise is to prove in full detail that the powerset functor $\stylefunctors{\powerset} : \Set \mto \Set$ from \cref{ex:PowersetImageFunctor} is a monad, when equipped with the following \emph{unit} and \emph{multiplication}.
    We define $\monunit : \stylefunctors{\text{Id}}_{\Set}  \nto \stylefunctors{\powerset}$ and $\moncomp : \stylefunctors{\powerset} \then \stylefunctors{\powerset} \nto \stylefunctors{\powerset}$ in terms of components: given an object $\setA \in \Set$, let
    \begin{equation}
        \label{eq:powerset-mult-component}
        \moncomp_{\setA} : (\stylefunctors{\powerset} \then \stylefunctors{\powerset})(\setA) \mto \stylefunctors{\powerset}(\setA), \ \stylesets{D} \mapsto \bigcup_{\subA \in \stylesets{D}} \subA
    \end{equation}
    and
    \begin{equation}
        \label{eq:powerset-unit-component}
        \monunit{_\setA} \colon \setA \mto \stylefunctors{\powerset}(\setA), \ \ela \mapsto \{ \ela \}.
    \end{equation}
    To show that $\tup{\stylefunctors{\powerset}, \moncomp, \monunit}$ is a monad,
    \begin{enumerate}
        \item prove that $\monunit$, as defined in components in \cref{eq:powerset-unit-component}, is a natural transformation;
        \item prove that $\moncomp$, as defined in components in \cref{eq:powerset-mult-component}, is a natural transformation;
        \item prove that $\monunit$ and $\moncomp$ satisfy the associativity condition and the left and right unitality conditions given in \cref{def:monad}.
              For this, work in components, as in \cref{rem:monad-condition-components}.
    \end{enumerate}
\end{gradedexercise}
\solutionof{PowersetMonad}

\showslides{
    \begin{forslides}
        \begin{equation}
            \label{eq:set-i-want-1}
            \Obja
        \end{equation}
        %
        \begin{equation}
            \label{eq:set-i-want-2}
            \Objb
        \end{equation}
        %
        \begin{equation}
            \label{eq:set-i-want-3}
            \Objc
        \end{equation}
        %
        \begin{equation}
            \label{eq:morph-i-want-1}
            \mora : \Obja \mto \Objb
        \end{equation}
        %
        \begin{equation}
            \label{eq:morph-i-want-2}
            \morb : \Objb \mto \Objc
        \end{equation}
        %
        \begin{equation}
            \label{eq:set-apple-banana}
            \Obja = \{ \sapple, \sbanana, \scarrot \}
        \end{equation}
        %
        \begin{equation}
            \label{eq:fruit-sum-0}
            \sapple \sbanana \scarrot
        \end{equation}
        %
        \begin{equation}
            \label{eq:fruit-sum-1}
            [ \sapple ]   *   [\sbanana ] *   [\scarrot ]
        \end{equation}
        %
        \begin{equation}
            \label{eq:fruit-sum-2}
            [ \sapple ]   *  [\sbanana  ]
        \end{equation}
        %
        \begin{equation}
            \label{eq:fruit-sum-3}
            [\sbanana ] * [\scarrot]
        \end{equation}
        %
        \begin{equation}
            \label{eq:fruit-sum-4}
            [ [\sapple]   *  [ \sbanana ] * [ \scarrot] ]
        \end{equation}
        %
        \begin{equation}
            \label{eq:fruit-sum-5}
            [ [ \sapple ] ]
        \end{equation}
        %
        \begin{equation}
            \label{eq:fruit-sum-6}
            [ [ \sapple]   *  [\sbanana ] ]
        \end{equation}
        %
        \begin{equation}
            \label{eq:fruit-sum-7}
            [ [ \sapple ] ] * [[ \sbanana ] ]  *  [[\scarrot]]
        \end{equation}
        %
        \begin{equation}
            \label{eq:fruit-sum-7-bis}
            [ [ \sapple ]  * [ \sbanana ] ] *  [[\scarrot]]
        \end{equation}
        %
        \begin{equation}
            \label{eq:fruit-sum-8}
            [ \sapple ]   *  [[ \sbanana ]  * [ \scarrot ]]
        \end{equation}
        %
        \begin{equation}
            \label{eq:fruit-sum-9}
            [[ \sapple ]]  * [[ \sbanana ]] *  [[ \scarrot ]]
        \end{equation}
        %
        \begin{equation}
            \label{eq:fruit-sum-10}
            [ \sapple ]   *  [ \sapple ]  *  [\sapple]
        \end{equation}
        %
        \begin{equation}
            \label{eq:fruit-sum-11}
            [ \sapple ]   *  [ \sapple ]  * [ \scarrot ]
        \end{equation}
        %
        \begin{equation}
            \label{eq:fruit-sum-12}
            [\sbanana ] * [ \sapple ]
        \end{equation}
        %
        \begin{equation}
            \label{eq:fruit-sum-13}
            [ \sapple ]   *  [ \sbanana ]  *  [ \scarrot ]
        \end{equation}
        %
        \begin{equation}
            \label{eq:fruit-sum-14}
            [ [ \sapple ]   *  [ \sbanana ]  *  [ \scarrot ] ]
        \end{equation}
        %
        \begin{equation}
            \label{eq:fruit-sum-15}
            [ [ \sapple ]  *  [\sbanana]  *  [\scarrot ]  ]
        \end{equation}
        %
        \begin{equation}
            \label{eq:fruit-sum-16}
            [ \sapple ]
        \end{equation}
        %
        \begin{equation}
            \label{eq:fruit-sum-17}
            [ \sbanana ]
        \end{equation}
        %
        \begin{equation}
            \label{eq:fruit-sum-18}
            [ \scarrot ]
        \end{equation}
        %
        \begin{equation}
            \label{eq:fruit-sum-20}
            [ [ \sapple ]   * [ \sbanana] ] *  [[ \sapple ]   *  [ \sapple ] *  [\scarrot ] ]   *  [[ \sapple ] ]
        \end{equation}
    \end{forslides}

}

\begin{equation}
    \label{eq:monad-power-functor}
    \definemap{
        \powerset \mora
    }{
        \powerset \Obja
    }{
        \powerset \Objb
    }{
        S
    }{
        \bigcup_{x\in S} \mora(x)
    }
\end{equation}
%
\begin{equation}
    \label{eq:monad-power-monunit}
    \definemap{
        \monunit_\Obja
    }{
        \Obja
    }{
        \powerset\Obja
    }{
        x
    }{
        \makeset{ x }
    }
\end{equation}

\begin{equation}
    \label{eq:monad-power-monunit-power}
    \definemap{
        \monunit_{\powerset \Obja}
    }{
        \powerset \Obja
    }{
        \powerset (\powerset\Obja)
    }{
        \makeset{a, b, c}
    }{
        \{ \{a, b, c \} \}
    }
\end{equation}

\begin{equation}
    \label{eq:monad-power-power-monunit}
    \definemap{
        \powerset(\monunit_\Obja)
    }{
        \powerset \Obja
    }{
        \powerset (\powerset\Obja)
    }{
        \{a, b, c\}
    }{
        \{ \{a\}, \{ b\}, \{c\} \}
    }
\end{equation}

\begin{equation}
    \label{eq:monad-power-moncomp}
    \definemap{
        \moncomp_{\Obja}
    }{
        \powerset (\powerset\Obja)
    }{
        \powerset \Obja
    }{
        \{S_1, S_2, \dots \}
    }{
        \bigcup_i S_i
    }
\end{equation}

\begin{equation}
    \label{eq:monad-power-power-moncomp}
    \definemap{
        \powerset \moncomp_{\Obja}
    }{
        \powerset (\powerset (\powerset\Obja))
    }{
        \powerset (\powerset \Obja)
    }{
        \{  \{   \{a\}, \{b\} \} , \{ \{c\}, \{d\} \}\}
    }{
        \{  \{ a, b \}, \{ c, d \} \}
    }
\end{equation}

\begin{equation}
    \label{eq:monad-power-moncomp-power}
    \definemap{
        \moncomp_{\powerset \Obja}
    }{
        \powerset (\powerset (\powerset\Obja))
    }{
        \powerset (\powerset \Obja)
    }{
        \{  \{   \{a\}, \{b\} \} , \{ \{c\}, \{d\} \}\}
    }{
        \{    \{a\}, \{b\}  ,  \{c\}, \{d\}  \}
    }
\end{equation}
%

\paragraph*{Example: interval construction}
In the following, we analyze the interval construction and show that it gives rise to a monad.
Given \Pos, we define the action of the $\Arrow$ functor on objects (posets) as

\todotextjira{422}{@J: I think we should use two different notations for the functor for the monad and the actual arrow construction\dots}
\begin{equation}
    \label{eq:monad-arrow-functor-objects}
    \begin{aligned}
        \Arrow\colon \Pos & \to \Pos              \\
        \posA             & \mapsto \Arrow(\posA)
    \end{aligned}
\end{equation}
and on morphisms as
\begin{equation}
    \label{eq:monad-arrow-functor-morphisms}
    \begin{aligned}
        \Arrow \mora\colon \Arrow(\posA) & \to \Arrow(\posB)                    \\
        \interv{a}{b}                    & \mapsto \interv{\mora(a)}{\mora(b)}.
    \end{aligned}
\end{equation}
%
Furthermore, we define the multiplication as
%
\begin{equation}
    \label{eq:monad-arrow-moncomp}
    \definemap{
        \moncomp_{\Obja}
    }{
        \Arrow (\Arrow(\Obja))
    }{
        \Arrow (\Obja)
    }{
        \interv{\interv{\alpha}{\beta}}{ \interv{\gamma}{ \delta}}
    }{
        \interv{\min(\alpha, \gamma)}{\max(\beta, \delta)} = \interv{\alpha}{\delta},
    }
\end{equation}
%
and the unit as
%
\begin{equation}
    \label{eq:monad-arrow-monunit}
    \definemap{
        \monunit_\Obja
    }{
        \Obja
    }{
        \Arrow(\Obja)
    }{
        x
    }{
        \interv{x}{x}.
    }
\end{equation}
%
First of all, we need to show that both the multiplication and the unit are indeed natural transformation.
Let's start with multiplication.
On one hand, we have:
%
\begin{equation}
    \label{eq:example_arrow_nat_1}
    \begin{aligned}
        ((\Arrow\fthen \Arrow)(\mora) \mthen \moncomp_\Objb)(\interv{\interv{a}{b}}{\interv{c,d}}) & =\moncomp_\Objb(\interv{\interv{\mora(a)}{\mora(b)}}{\interv{\mora(c)}{\mora(d)}}) \\
                                                                                                   & =\interv{\mora(a)}{\mora(d)}.
    \end{aligned}
\end{equation}
%
On the other hand we have:
%
\begin{equation}
    \label{eq:example_arrow_nat_2}
    \begin{aligned}
        (\moncomp_\Obja \fthen \Arrow)(\interv{\interv{a}{b}}{\interv{c}{d}})
         & =\Arrow(\mora)(\interv{a}{d}) \\
         & =\interv{\mora(a)}{\mora(d)}.
    \end{aligned}
\end{equation}
%
The equivalence of \cref{eq:example_arrow_nat_1} and \cref{eq:example_arrow_nat_2} proves naturality.
Let's not check that the unit defines a natural transformation.
We have
%
\begin{equation}
    \label{eq:example_arrow_nat_3}
    \begin{aligned}
        (\mora \mthen \monunit_\Objb)(x)
         & =\mora(x)\mthen \monunit_\Objb \\
         & =\interv{\mora(x),\mora(x)},
    \end{aligned}
\end{equation}
%
and
%
\begin{equation}
    \label{eq:example_arrow_nat_4}
    \begin{aligned}
        (\monunit_\Obja \mthen \Arrow(\mora))(x)
         & =\Arrow(\mora)(\interv{x}{x}) \\
         & =\interv{\mora(x),\mora(x)},
    \end{aligned}
\end{equation}
%
Again, equivalence of \cref{eq:example_arrow_nat_3} and \cref{eq:example_arrow_nat_4} proves naturality.

We now need to check associativity and left and right unitality.
Let's start with associativity.
To clearly see the property holding, we need to define intermediate quantities.
One has
%
\begin{equation}
    \label{eq:monad-arrow-arrow-moncomp}
    \definemap{
        \Arrow \moncomp_{\Obja}
    }{
        \Arrow (\Arrow (\Arrow(\Obja)))
    }{
        \Arrow (\Arrow (\Obja))
    }{
        \interv{\interv{\interv{\alpha_1}{\beta_1}}{ \interv{\gamma_1}{ \delta_1}}}%
        {\interv{\interv{\alpha_2}{\beta_2}}{ \interv{\gamma_2}{ \delta_2}}}
    }{
        \interv{\interv{\alpha_1}{\delta_1}}{ \interv{\alpha_2}{ \delta_2}}
    }
\end{equation}
%
and
%
\begin{equation}
    \label{eq:monad-arrow-moncomp-arrow}
    \definemap{
        \moncomp_{\Arrow (\Obja)}
    }{
        \Arrow (\Arrow (\Arrow(\Obja)))
    }{
        \Arrow (\Arrow(\Obja))
    }{
        \interv{\interv{\interv{\alpha_1}{\beta_1}}{ \interv{\gamma_1}{ \delta_1}}}%
        {\interv{\interv{\alpha_2}{\beta_2}}{ \interv{\gamma_2}{ \delta_2}}}
    }{
        \interv{\interv{\alpha_1}{\beta_1}}{ \interv{\gamma_2}{ \delta_2}}
    }
\end{equation}
%
With this in mind, it is easy to see that the following diagram commutes.
%
\begin{center}
    \todographicsjira{260}{@Gioele: add associativity diagram in tikz.
        Take it from GZ recital.
    }
\end{center}
%
For left and right unitality, we need to work out two additional quantities:
%
\begin{equation}
    \label{eq:monad-arrow-monunit-arrow}
    \definemap{
        \monunit_{\Arrow(\Obja)}
    }{
        \Arrow(\Obja)
    }{
        \Arrow (\Arrow(\Obja))
    }{
        \interv{a}{b}
    }{
        \interv{\interv{a}{b}}{\interv{a}{b}},
    }
\end{equation}
%
and
%
\begin{equation}
    \label{eq:monad-arrow-arrow-monunit}
    \definemap{
        \Arrow(\monunit_\Obja)
    }{
        \Arrow(\Obja)
    }{
        \Arrow (\Arrow(\Obja))
    }{
        \interv{a}{b}
    }{
        \interv{\interv{a}{a}}{\interv{b}{b}}.
    }
\end{equation}
%
With this in mind, it is easy to see that the following diagrams commute.
%
\begin{center}
    \todographicsjira{261}{@Gioele: add left and right diagrams in tikz.
        Take it from GZ recital.
    }
\end{center}
