% !TEX root = chapter-standalone.tex

\section{The advantages of ACT}

So far in the book we have discussed Applied Category Theory from a modeling perspective: we have described various mathematical structures, their properties, and how they can be used for modeling certain engineering phenomena.

But we never actually \emph{did} anything.

How can category theory help?

\todojira{250}{\bernina: @Andrea: Do discussion: descriptive \vs actionable, workflow systematization}

\section{From theory to practice}
\todojira{211}{Discuss the 4 phases}
\linkvideo{spring2021-functorial-comp-a:how-cat-helps} % How can category theory help?
%\linkvideo{spring2021-functorial-comp-a:patterns} % Looking for patterns
%\todojira{212}{remove compositional theories bit}
%\linkvideo{spring2021-functorial-comp-a:compositionality} % Looking for compositionality
\linkvideo{spring2021-functorial-comp-a:from-math-to-impl} % From math to implementation
\publictodomessage
In this section, we will discuss the four phases that bring you from the mathematical definition of a problem to the implementation on a specific machine of the algorithm finding a solution.
To practically explain each phase, we will use the underlying example of vector normalization, inspired by John Carmack's \emph{fast inverse square root algorithm}.

\todotextjira{251}{History/intro bit of Carmack's stuff.}

\paragraph*{Mathematical phase}
The \emph{mathematical phase}, consists in proving that the given problem is well posed, and that a solution exists.
For the example of vector normalization, given a vector $v\setin \reals^3$, you want to find a \emph{unit} vector~$n\setin \reals^3$ which has the same direction as~$v$.
Mathematically, for any vector~$v\setin \reals^3$, there exists a~$n\setin \reals^3$ such that~$\tup{n,v}=\normof v $.
How many such~$n$ are there?
If~$v=\begin{bmatrix}
        0 & 0 & 0
    \end{bmatrix}\mattransp$ any~$n\setin \reals^3$ satisfies the condition.
In all other cases, there will be just one single~$n$ satisfying the condition.
\paragraph*{Constructive phase}
The \emph{constructive} phase consists in defining a constructive method to actually find the solution.
For our example, this amounts to, while assuming~$v$ is not the zero vector, writing
\begin{equation}
    \label{eq:normalization}
    n=\frac{v}{\normof v}.
\end{equation}
It is clear that \cref{eq:normalization} satisfies the condition for~$n$ to be a solution of the problem.
\paragraph*{Algorithmic phase}
Given a constructive method to find the solution, one needs to find an \emph{effective} method for a specific model of computation.
In other words, we need to answer the question ``how do we actually compute the solution?''.
An effective way to compute the solution of our example problem is to first compute the norm squared (given by the sum of the squares of the vector components), and to then apply the Newton method for a couple of iterations:
\begin{equation}
    \label{eq:newton_normalization}
    \begin{aligned}
         & M\leftarrow v_1^2+v_2^2+v_3^2 \\
         & m\leftarrow \text{Newton}\pars{a\mapsto 1/\sqrt{a},M} \\
         & \text{return }\tup{mv_1,mv_2,mv_3}.
    \end{aligned}
\end{equation}
%

\paragraph*{Implementation phase}
The actual implementation of the algorithm is targeted to a \emph{specific machine}, which has limited resources.
John Carmack's fast inverse square root implementation uses particularities about the bit representation of floating point numbers and integers in x86 and proposes the following implementation:

\begin{center}
    \begin{minted}{cpp}
float InvSqrt(float x){
    float xhalf = 0.5f * x;
    int i = *(int*)&x;
    i = 0x5f3759df - (i >> 1);
    x = x*(1.5f - xhalf*x*x);
    return x;
}
    \end{minted}
\end{center}

\paragraph*{Philosophical perspectives}
The \emph{mathematical} phase and the \emph{constructive phase} are the same, if you are a \emph{constructivist}.
Also, the \emph{algorithmic} phase becomes the same if you are a \emph{finitist}.
Finally, the \emph{implementation} phase becomes the same if you are an \emph{ultra-finitist}.
\todojira{252}{Elaborate more here.}

\todojira{251}{Also provide a reference.}
\devel{
    \includepdf[scale=0.8,pages={7-10},nup=1x3,frame,pagecommand={}]{ACT4E-12-computation.pdf}
}

\devel{
    \includepdf[scale=0.8,pages={11,12,13,14,16,17},nup=1x3,frame,pagecommand={}]{ACT4E-12-computation.pdf}

    \includepdf[scale=0.8,pages={18-23},nup=1x3,frame,pagecommand={}]{ACT4E-12-computation.pdf}
}

\subsection{An example}

\publictodomessage

\section{Compositional solutions}

\publictodomessage

\subsection{The four phases when solving  design problems}
We can use the very same four phases to think about the solution of \SY{design problems}.
The next sections will explain the details of each part, but here we want to give you an overview on the steps in each phase.
We will focus our exposition on \FixFunMinRes.

Given any \SY{design problem} to be solved, we want to find a map
\todotextjira{427}{\bernina: @Andrea: Not just any map, but the curried and op-ed version of the original design problem, right?
    Also, we need to say explicitly here that we are ordering \SY{upper sets} by containment.
    We can refer back to \cref{ex:CurryingDesignProblems} which was about showing that \SY{design problems} can be viewed this way.
}
%
\begin{equation}
    \label{eq:hfromftoupr}
    \ftor\colon \funsp \toinPos \uppersets \ressp.
\end{equation}
%
\todotextjira{419}{\bernina: @Andrea: J: is this perhaps a bit misleading?
    Isn't what we actually want a map to \SY{antichains} ?
    Why not say it here rather than below?
    From a mathematical perspective, $h$ above is just the curried version of the original \SY{design problem} \dots  so it seems almost a bit strange to pose that as the problem perhaps?
}
%
A constructive method to find the solution consists in applying two restrictions, both needed to allow for computation:
\begin{enumerate}
    \item First, we allow only \SY{posets}~\posA such that~$\uppersets \posA$ is a \emph{direct complete partial order}.
    \item Second, we only allow \SY{design problems} for which \cref{eq:hfromftoupr} is a \SY{Scott continuous} map.
\end{enumerate}
Note that a \emph{sufficient} conditions for the restrictions above is that all \SY{posets} are \emph{finite}.
\begin{remark}
    In this context, the two conditions above are analogous to \SY{compactness} and \SY{Cauchy sequences} in analysis: they ensure that some type of sequences will converge somewhere.
\end{remark}

\todotextjira{298}{\bernina: @Andrea: Make the above remark clearer or more precise. (I which include a recollection of the relevant fact from analysis).}

Now, given the constructive method, we actually need to find an effective method to compute the solution.
In this case we want to find finite solutions, and allow only \SY{upper sets} that can be represented as finite \SY{antichains}:
\begin{equation}
    \posA=\upit \Min \posA.
\end{equation}
In other words, we want to find a map
\begin{equation}
    \label{eq:hfromftoantir}
    \ftor\colon \funsp \toinPos \antichains \ressp.
\end{equation}
%

\todojira{253}{\bernina: @Andrea: I think it is good to have an overview that connects to the four phases before starting the meat.
    Should we also talk about \SY{functors} DP to UPos, UPoscomp, UPosdiscrete?
}
