% !TEX root = chapter-standalone.tex

\section{Set-enriched DPs (DPIs)}

\begin{proposition}
    \label{prop:DP_loc_pos}
    \DP is enriched in \Pos.
    Equivalently, it is a locally posetal 2-category: a 2-category where the hom-categories are also \SY{posets}.
\end{proposition}
\begin{proof}
    Suppose that $f,g\colon \F{\cP} \profto \R{\cQ}$ and $j,k\colon \F{\cQ} \profto \R{\cR}$ are \SY{design problems} and that $f\Imp g$ and $j\Imp k$.
    We need to show that $(f\dpthen j)\Imp(g\dpthen k)$ in \DP.
    \equationsag{77_dploc}{eq:77_dploc}
    Assume $f\Imp g$ and $j\Imp k$, and choose $\F{p}\setin\F{\cP} $ and $\res\setin\R{\cR}$ such that $(f\dpthen j)(\F{p}^*,\res)=\true$; we must show that $(g \dpthen k)(\F{p}^*,\res)=\true$.
    By assumption, there is some $q\setin Q$ such that $f(\F{p}^*,\R{q})\booland j(\F{q}^*,\res)=\true$.
    But then also $g(\F{p}^*,\R{q})\booland k(\F{q}^*,\res)=\true$, and this implies the result.
\end{proof}
\todotext{Style}
Since \SY{posets} are also categories, \SY{monotone maps} between \SY{posets} can be defined as \SY{functors} between \SY{poset} categories (\cref{lem:posetfunctor}).
Furthermore, \SY{posets} are enriched in \Bool (\cref{ex:enrichbool}), \ie, $\Hom_A(a,b) \setin \Bool$ for all $A \setin \Pos$.
So when we say that a \SY{design problem}~$f$ is ``enriched in \Bool'', we mean that is not only a \SY{profunctor} $f \colon \F{A} \profto \R{B}$ between \SY{posets} $A\op \cartprod B$ and \Bool, but that its action on \SY{hom-sets} is always a morphism in \Bool.
Explicitly,

\begin{widepar}
    \begin{equation}
        f \colon \Hom_{\F{A}\op \Ctimes \R{B}}(\tup{\F{a_1}^*,\R{b_1}}, \tup{\F{a_2}^*,\R{b_2}}) \to \Hom_{\Bool}(f(\tup{\F{a_1}^*,\R{b_1}}), f(\tup{\F{a_2}^*,\R{b_2}}))
    \end{equation}
\end{widepar}
is a morphism in \Bool---in other words, one among the set $1 \posleqof\Bool 1, 0 \posleqof\Bool 0$, and $0 \posleqof\Bool 1$.

\linkvideo{spring2021-enrichment:from-dp-to-upos} % A functor from DP to UPos
\linkvideo{spring2021-enrichment:enriched-functors} % Enriched functors
\begin{ctdefinition}[Enriched functor]
    \label{def:enrichedfunctor}
    Given two categories \CatC and \CatD enriched in the same \SY{monoidal category} \CatV, an \maindef{enriched functor}~$\funa\colon \CatC \to \CatD$ consists of:
    \begin{enumerate}
        \item A map~$\funa\colon \ObC \sto \ObD$ that maps objects of~\CatC to objects of~\CatD.
        \item For each~$\Obja, \Objb$ in $\ObC$, there exists a morphism in \CatV given by
              \begin{equation}
                  \funa_{\Obja, \Objb} \colon \HomSet\CatC{\Obja}{\Objb} \mto \HomSet\CatD{\funa(\Obja)}{\funa(\Objb)},
              \end{equation}
              such that composing maps ``across~$\funa$'' respects the composition in \CatC and the unit of \CatV in the obvious ways:
              \equationsag{77_enriched_functor}{eq:77_enriched_functor}
              and
              \equationsag{77_enriched_functor_2}{eq:77_enriched_functor_2}
              where~$\mtimescat$ and~$\idmoncat$ are the monoidal product and monoidal unit in \CatV.
    \end{enumerate}
\end{ctdefinition}

\linkvideo{spring2021-enrichment:monotone-maps-bool-func} % Monotone maps are Bool functors

\begin{proposition}
    Design problems in \DP are Boolean-enriched \SY{profunctors}.
\end{proposition}
\begin{proof}
    We will show that any \SY{monotone maps}~$f\colon A \toinPos B$ between \SY{posets} is a Boolean-enriched \SY{functor}.
    Then a \SY{design problem} is simply a Boolean-enriched \SY{functor} that happens to be a \SY{profunctor}.

    Monotonicity of~$f$ means that~$a_1 \ordleq_A a_2$ implies $f(a_1) \ordleq_B f(a_2)$.
    Rewriting this condition considering~$A, B$ as categories enriched in \Bool, we have that
    \begin{equation}
        \Hom_A(a_1, a_2) \to \Hom_B(f(a_1), f(a_2)),
    \end{equation}
    which can be re-stated as proclaiming the existence of a morphism~$f_{a_1, a_2}$ in \Bool:
    \begin{equation}
        f_{a_1, a_2} \colon \Hom_A(a_1, a_2) \to_{\Bool} \Hom_B\pars{f(a_1), f(a_2)}.
    \end{equation}
    It remains to be checked that the diagrams in \cref{def:enrichedfunctor} commute.
    The first is trivial since~$a \ordleq_A a$ is true by definition in all posets:
    \begin{equation}
        \dpidat{a} \mthen f_{a,a} (\ast) = \dpidat{f(a) = \true}.
    \end{equation}
    The second is also relatively trivial: the monoidal product is just the conjunction~$\booland$ in \Bool, so commuting with the composition in the \SY{poset} can be thought of as a verification of the monotonicity of~$f$ via the natural~$\Imp$ inside \Bool:
    \begin{equation}
        \begin{tabular}{ccc}
            $(a \ordleq b) \booland (b \ordleq c)$             & $\to$ & $(a \ordleq c)$ \\
            $\Downarrow$                                       &       & $\Downarrow$ \\
            $(f(a) \ordleq f(b)) \booland (f(b) \ordleq f(c))$ & $\to$ & $(f(a) \ordleq f(c))$
        \end{tabular}
    \end{equation}
\end{proof}

Having defined morphisms in \DP as Boolean-enriched \SY{design problems}, we can directly generalize these Boolean-enriched \SY{design problems} to \Set-enriched \SY{design problems}, or \SY{design problem with implementations}.
\begin{widepar}
    \begin{definition}[Design problems with implementation as monotone functions]
        \label{def:dpwithimp}
        Suppose that~\funsp,~\ressp are \SY{posets}.
        A \maindef{design problem with implementation} is a \SY{monotone map} (a \Set-enriched \SY{profunctor})~$\tup{\impsp_d,\prov,\req}\colon \funsp\profto \ressp$, where~$\impsp_d$ is a set,~$\prov$ and~$\req$ are functions from~$\impsp_d$ to~\funsp and~\ressp, respectively
        \begin{equation}
            \funsp \xleftarrow{\prov} I \xrightarrow{\req} \ressp,
        \end{equation}
        and $\tup{\impsp_d,\prov,\req}\colon \funsp\profto \ressp$ is given by
        % \begin{widepar}
        \begin{equation}
            \begin{aligned}
                \tup{\impsp_d,\prov,\req}\colon \funsp\profto \ressp \colon \funspop \Ptimes \ressp & \toinPos \powerset(\impsp_\adp) \\
                \tup{\fun^*, \res}                                                                  & \mapsto \makeset{ \imp \setin \impsp_\adp \colon ( \fun \funleq \prov(i)) \booland (\req(i) \resleq \res) },
            \end{aligned}
        \end{equation}
        % \end{widepar}
        %
        where the partial order on~$\powerset\impsp$ is given by subset inclusion.
    \end{definition}
\end{widepar}

\paragraph{Intended semantics}
When we consider a \SY{design problem with implementation} $\tup{\impsp_d, \prov, \req}\colon \funsp\profto \ressp$, we imagine the \SY{poset} \funsp to represent the functionality to be provided and the \SY{poset} \ressp to represent the resources required.
The object $\tup{\impsp_d,\prov,\req}\colon \funsp\profto \ressp$ is the set of ways to provide $\fun\setin \funsp$ using $\res\setin \ressp$.

\noindent The monotonicity of $d$ represents the two assumptions:
\begin{enumerate}
    \item If \fun is feasible with \res in a set $i$ of ways, then any $\F{f'}\funleq \fun$ is feasible with \res in a set $i'\setsupseteq i$ of ways.
    \item If \fun is feasible with \res in a set $i$ of ways, then \fun is feasible with any $r'\resgeq r$ in a set $i'\setsupseteq i$ of ways.
\end{enumerate}

\begin{definition}[Series composition of design problem with implementation]
    \label{def:seriesdpi}
    Given two \SY{design problem with implementation} $\tup{\impsp_f,\prov_f,\req_f}\colon \F{A}\profto \R{B}$ and $\tup{\impsp_g,\prov_g,\req_g}\colon \F{B}\profto \R{C}$, we can define their series interconnection
    \begin{equation}
        \tup{\impsp_{f\dpthen g},\prov_{f\dpthen g},\req_{f\dpthen g}}\colon \F{A}\profto \R{C}
    \end{equation}
    as follows.
    With reference to this diagram:
    \begin{equation}
        \F{A} \xleftarrow{\prov_f} \impsp_f \xrightarrow{\req_f} B
        \xleftarrow{\prov_g} \impsp_g \xrightarrow{\req_g} \R{C}
    \end{equation}
    we let the implementation space be the \emph{pullback}
    \begin{equation}
        \begin{aligned}
            \impsp_{f\dpthen g} & = \impsp_f \cartprod_B \impsp_g \definedas \makeset{
                \tup{i_f,i_g} \setin \impsp_f \cartprod \impsp_g \colon
                \req_f(i_f) \leq_{B} \prov_g(i_g)
            }, \\
        \end{aligned}
    \end{equation}
    and the two maps $\prov$, $\req$ defined as:
    \begin{equation}
        \begin{aligned}
            \req  & \colon \tup{i_f,i_g} \mapsto \req_2(i_g) \\
            \prov & \colon  \tup{i_f,i_g} \mapsto \prov_1(i_f).
        \end{aligned}
    \end{equation}
    In terms of the \SY{profunctors}, we have
    \begin{widepar}
        \begin{equation}
            \label{eq:seriesdpi}
            \begin{aligned}
                 & \tup{\impsp_{f\dpthen g},\prov_{f\dpthen g},\req_{f\dpthen g}}\colon \F{A}\Ctimes \R{C} \toinPos \powerset(\impsp_f \cartprod_B \impsp_g) \\
                 & \tup{\F{a}^*,\R{c}} \mapsto \bigsetunion_{\substack{(b,b') \setin B\op \cartprod B\op \\ b \leq_B b'}} \Bigg[ \tup{\impsp_f,\prov_f,\req_f}(\F{a}^*,\R{b}) \cartprod \tup{\impsp_g,\prov_g,\req_g}(\F{b'}^*,\R{c}) \Bigg].
            \end{aligned}
        \end{equation}
    \end{widepar}
\end{definition}

\begin{lemma}
    \label{lem:series-dp}
    The series composition operation for \SY{design problem with implementation} as in \cref{eq:seriesdpi} is monotone in~$a$ and~$c$.
\end{lemma}
\begin{proof}
    Consider \cref{eq:seriesdpi}.
    By choosing $\F{a'}\geq_\F{A} \F{a}$, we have
    \begin{equation}
        \tup{\impsp_{f},\prov_{f},\req_{f}}(\F{a'}^*,\R{c})\setsubseteq \tup{\impsp_{f},\prov_{f},\req_{f}}(\F{a}^*,\R{c}),
    \end{equation}
    and hence
    \begin{equation}
        \tup{\impsp_{f\dpthen g},\prov_{f\dpthen g},\req_{f\dpthen g}}(\F{a'}^*,\R{c})\setsubseteq \tup{\impsp_{f\dpthen g},\prov_{f\dpthen g},\req_{f\dpthen g}}(\F{a}^*,\R{c}).
    \end{equation}
    Similarly, by choosing $\R{c'}\geq_{\R{C}} \R{c}$, we have
    \begin{equation}
        \tup{\impsp_{f},\prov_{f},\req_{f}}(\F{a}^*,\R{c'})\setsupseteq \tup{\impsp_{f},\prov_{f},\req_{f}}(\F{a}^*,\R{c})
    \end{equation}
    and hence
    \begin{equation}
        \tup{\impsp_{f\dpthen g},\prov_{f\dpthen g},\req_{f\dpthen g}}(\F{a}^*,\R{c'})\setsupseteq \tup{\impsp_{f\dpthen g},\prov_{f\dpthen g},\req_{f\dpthen g}}(\F{a}^*,\R{c}).
    \end{equation}
    This shows monotonicity, and hence shows that the series composition of two DPIs is a DPI.
\end{proof}

\begin{lemma}
    \label{lem:dpi-series}
    The series composition operation for \SY{design problems with implementation} as in \cref{eq:seriesdpi} is \SY{associative}, \ie,  given three (composable) \SY{design problems with implementation} $f,g,h$:
    \begin{equation}
        (f\dpthen g)
        \dpthen h = f\dpthen (g\dpthen h).
    \end{equation}
\end{lemma}
\begin{proof}
    Consider three \SY{design problems with implementation}:
    \begin{equation}
        \begin{aligned}
            f=\tup{{\impsp_f, \prov_f, \req_f} } & \colon \F{A} \profto\R{B,} \\
            g=\tup{\impsp_g, \prov_g, \req_g}    & \colon \F{B} \profto \R{C}, \\
            h=\tup{\impsp_h, \prov_h, \req_h}    & \colon \F{C} \profto \R{D}.
        \end{aligned}
    \end{equation}
    First, we have:
    \begin{equation}
        A \xleftarrow{\prov_f} \impsp_f \xrightarrow{\req_f} B
        \xleftarrow{\prov_g} \impsp_g \xrightarrow{\req_g} C
        \xleftarrow{\prov_h} \impsp_h \xrightarrow{\req_h} D.
    \end{equation}
    We first consider the composition $f\dpthen g$.
    We have:
    \begin{equation}
        \begin{aligned}
            \impsp_{f\dpthen g}                       & = \makeset{
                \tup{i_f,i_g} \setin \impsp_f \cartprod \impsp_g \colon
                \req_f(i_f) \ordleq_{B} \prov_g(i_g)
            } \\
            \req_{f\dpthen g}  \colon  \tup{i_f,i_g}  & \mapsto \req_g(i_g) \\
            \prov_{f\dpthen g}  \colon  \tup{i_f,i_g} & \mapsto \prov_f(i_f).
        \end{aligned}
    \end{equation}
    We can now look at~$(f\dpthen g)\dpthen h$.
    We have:
    \begin{equation}
        \begin{aligned}
             & \impsp_{(f\dpthen g)\dpthen h} = \makeset{
                \tup{i_{f\dpthen g},i_h} \setin \impsp_{f\dpthen g} \cartprod \impsp_{h}\colon
                \req_{f\dpthen g}(i_{f\dpthen g}) \ordleq_{C} \prov_h(i_h)
            } \\
             & =\makeset{
                \tup{\tup{i_f, i_g},i_h} \setin (\impsp_f \cartprod \impsp_g) \cartprod \impsp_{h}\colon
                (\req_f(i_f) \ordleq_{B} \prov_g(i_g))
                \booland
                (\req_g(i_g) \ordleq_{C} \prov_h(i_h))
            },
        \end{aligned}
    \end{equation}
    ~
    \begin{equation}
        \begin{aligned}
            \req_{(f\dpthen g)\dpthen h} & \colon  \tup{i_{f\dpthen g},i_h} \mapsto \req_h(i_h) \\
            \req_{(f\dpthen g)\dpthen h} & \colon  \tup{\tup{i_f, i_g},i_h} \mapsto \req_h(i_h),
        \end{aligned}
    \end{equation}
    and
    \begin{equation}
        \begin{aligned}
            \prov_{(f\dpthen g)\dpthen h} & \colon  \tup{i_{f\dpthen g},i_h} \mapsto \prov_{f\dpthen g}(i_{f\dpthen g}) \\
            \prov_{(f\dpthen g)\dpthen h} & \colon  \tup{\tup{i_f, i_g},i_h} \mapsto \prov_f(i_f).
        \end{aligned}
    \end{equation}
    Since
    \begin{equation}
        (\impsp_f \cartprod \impsp_g)
        \cartprod \impsp_{h} \cong  \impsp_f \cartprod (\impsp_g \cartprod \impsp_{h}),
    \end{equation}
    the above is exactly what we would obtain for $f\dpthen (g\dpthen h)$, so we can say that~$f\dpthen(g\dpthen h)\cong (f\dpthen g)\dpthen h$, meaning that this composition is \SY{associative} up to isomorphism.
\end{proof}

\begin{definition}[Identity design problem with implementation]
    \label{def:identitydpi}
    The \maindef{identity design problem with implementation}~$\tup{\impsp_{\dpidat A},\prov,\req} \colon \F{A} \profto \R{A}$ is given by implementation set $\impsp_{\dpidat A} = A$ and $\prov=\req$ being the identity on $A$.
    The \SY{profunctor} is defined as
    \begin{align}
        \tup{\impsp_{\dpidat A},\prov,\req} \colon \F{A}\op \Ctimes \R{A} & \toinPos \powerset(A) \\
        \tup{\F{a}^*,\R{a'}}                                              & \mapsto (\upit \F{a}) \setintersection (\downarrow \R{a'})
    \end{align}
\end{definition}
\begin{remark}
    Alternatively, we can define the \SY{identity profunctor} as
    \begin{align}
        \tup{\impsp_{\dpidat A},\prov,\req}\colon \F{A}\posop \Ptimes \ressp & \toinPos \powerset{A} \\
        \tup{\F{a}^*,\R{a'}}                                              & \mapsto
        \begin{cases}
            \makeset{a}, & \F{a}\ordleq_A \R{a'} \\
            \Emptyset,   & \text{otherwise}.
        \end{cases}
    \end{align}
\end{remark}

\begin{lemma}
    \label{lem:dp-unital}
    The series composition operation for \SY{design problem with implementation} as in \cref{eq:seriesdpi} satisfies the left and right unit laws (unitality).
\end{lemma}

\todojira{248}{\bernina: Do the proof and see if we need to change some definitions to make it work}

\begin{definition}[Category of \Set-enriched design problems]
    \label{def:set-enriched-dp}
    The category of \Set-enriched \SY{design problems} \DPI consists of the following data:
    \begin{enumerate}
        \item \emph{Objects:}
              Objects of~\DPI are \SY{posets}.
        \item \emph{Morphisms:}
              The morphisms of \DPI are \SY{design problem with implementation} (\cref{def:dpwithimp}).
        \item \emph{Identity morphism}: The \SY{identity morphism} is given by \cref{def:identitydpi}.
        \item \emph{Composition operation}: Given two composable morphisms~$f$ and~$g$, their composition $f\dpthen g$ is given by \cref{def:seriesdpi}.
    \end{enumerate}
\end{definition}

\begin{lemma}
    \label{lem:DPI-is-category}
    \DPI is a category.
\end{lemma}

\begin{proof}
    We have already shown that the composition operator in \DPI is \SY{associative} and unital, and that the composition of two \SY{design problem with implementation} is a \SY{design problem with implementation} (closure).
    Therefore, \DPI is a valid category.
\end{proof}

Like \DP, \DPI is also a \SY{traced symmetric monoidal category} with monoidal product $\mtimescat$ and \SY{biproduct} given by $+$;
we will skip the proofs for \DPI since most are directly analogous to those for \DP.
We already saw an example of \DPI in \cref{ex:dpi_example} above.
It remains to verify that morphisms in \DPI are indeed enriched in \Set:

\begin{proposition}
    Design problems with implementation are \Set-enriched \SY{profunctors}.
\end{proposition}
\begin{publictodo}
    Proof to be written.
\end{publictodo}
\devel{
    \begin{proof}
        Fix a \SY{design problem} $f \colon A\op \cartprod B \toinPos \powerset \impsp$.
        \todojira{249}{\bernina: @Gioele: Finish the proof}
    \end{proof}
}
We introduce \DPI mainly as a point of comparison; enriching in \Set is the most obvious, if not the most elegant, way of representing and reasoning about implementations of \SY{design problems}.
Indeed, the way we defined morphisms is rather clunky (note how~$\impsp_\adp$ is a set rather than a poset, and the extra provisions for~$\prov$ and~$\req$ in the \SY{identity morphism}), and it also essentially restricts implementations~$\impsp_\adp$ to being subsets of~$\funspop \Ptimes \ressp$, \ie, an implementation \emph{rigidly} provides a fixed functionality \fun with a fixed \res.

The far more natural option, from the perspective of  \SY{enriched category theory}, is to enrich \SY{design problems} in \DP itself.

\begin{example}
    \begin{equation}
        \begin{aligned}
            \text{engine} \colon \F{\text{Thrust}}\op \Ctimes \R{\text{Fuel}} & \toinPos \powerset(\text{Engines}) \\
            \tup{\F{t}^*,\R{f}}                                               & \mapsto \makeset{ e \setin \text{Engines} \colon e(\F{t}^*, \R{f}) = \true }
        \end{aligned}
    \end{equation}
    where Engines is the hom-poset $\HomSet{\DP}{\text{Thrust}}{\text{Fuel}}$ from \XXX. %\cref{ex:rdproblem}.
\end{example}

\todotext{ Now ex:rdproblem is in Playground - copy or remove reference}

\subsubsection{Operations on DPIs}

% \begin{table}[t!]
%     \centering
% \begin{tabular}{c|c|c|crl}
%     series &
%     $f:A\profto B$&
%     $g:B\profto C$&
%     $f;g:$&$A$&$\profto C$ \\
%     %
%     sum &
%     $f:A\profto B$ &
%     $g:A\profto B$ &
%     $f\boolor g:$&$A$&$\profto B$ \\
%     %
%     intersection &
%     $f:A\profto B$ &
%     $g:A\profto B$ &
%     $f\wedge g:$&$A$&$\profto B$ \\
%     %
%     monoidal product &
%     $f:A\profto C$&
%     $g:B\profto D$ &
%     $f\otimes g:$&$A\times B$&$\profto C \times D$ \\
%     %
%     product &
%     $f:A\profto C$&
%     $g:A\profto D$ &
%     $f\times g:$&$A $&$\profto C + D$ \\
%     %
%     coproduct &
%     $f:A\profto C$&
%     $g:B\profto C$ &
%     $f\sqcup g:$&$A + B $&$\profto C$ \\
%     %
%     \SY{biproduct} &
%     $f:A\profto B$ &
%     $g:A\profto B$ &
%     $f+ g:$&$A + A$&$\profto B + B$ \\
%     %
%     trace &
%     $f: C \times A \profto C \times B$ &
%     -&
%     $\Tr_{A,B}^C(f) :$&$A$&$\profto B$
% \end{tabular}
%     \caption{Various composition operations on \SY{design problems} (\ie  morphisms) in \DP.}
% \end{table}

%We can now extend the ways we can compose to DPs to the case of DPIs.

%\begin{definition}[Category enriched in $\tup{\Bool,\true,\wedge}$]\label{def:cat_enriched_bool}
%A \emph{category enriched in $\tup{\Bool,\true,\wedge}$}, denoted $\cP =\tup{P,\leqP }$, consists of the following:
%\begin{description}
%\item[\quad 1) Reflexivity:] for any object $p\setin P$, it is true that $p \leqP p$.
%\item[\quad 2) Transitivity:] for any three objects $p_1,p_2,p_3\setin P$, if $p_1\leqP  p_2$ and $p_2\leqP p_3$, then $p_1 \leqP p_3$.
%\end{description}
%\end{definition}

% \begin{example}The only morphisms in \Bool are $\false \leq \false$, $\true \leq \true$, and $\false \leq \true$. For \SY{posets} and \SY{monotone maps}. this makes sense, since there is at most one element in each hom-set $\hom_P(p_1,p_2)$ of any \SY{poset} $P$, so the mapping $F : \hom_P(p_1,p_2) \to \hom_Q(q_1,q_2)$ is either $\false \to \false$ (\ie  $p_1 \not \leq p_2$ so $q_1 \not \leq q_2$), $\true \leq \true$ (\ie  $p_1 \leq p_2$ implies $q_1 \leq q_2$, which is just the naturality condition of being a functor), or $\false \leq \true$ (\ie  $p_1 \not \leq p_2$, and $q_1 \leq q_2$). Importantly, what is not allowed is $\true \to \false$, which contradicts the naturality condition of a functor between \SY{posets} (\ie  that it is monotone).\end{example}

%\begin{definition}
%Given \SY{posets} $\cP = \tup{P,\leqP }$ and $\cQ = \tup{Q,\leqQ }$, a \emph{boolean-enriched functor} $F\colon P\to Q$ consists of the following:
%\begin{description}
%    \item[\quad Objects:] a map $F\colon P\to Q$, from objects in $P$ to objects in $Q$.
%    \item[\quad Order:] for every $p_1,p_2\setin P$ an assurance that $\cP(p_1, p_2)\leq_\Bool \cQ(F(p_1),F(p_2))$. In other words, if $p_1\leqP p_2$, then $F(p_1)\leqQ F(p_2)$.
%\end{description}
%We often denote $\Ob_F$ simply by $F$, \eg \ writing $F(c)$ rather than $\Ob_F(c)$; it overloads the notation $F$, but is often easier to read.
%\end{definition}

%\begin{definition}
%Given two \SY{posets} $\cP =\tup{P,\leqP }$ and $\cQ =\tup{Q,\leqQ }$, a \emph{boolean-enriched profunctor} \[f\colon \cP \profto \cQ \] is a monotone map
%\[
%    f\colon\cP \op\times \cQ \toinPos \Bool.
%\]
%\end{definition}

% Recall that a \Set-enriched functor is just a functor, while a \Set-enriched category is just a category.
% Then:

%\begin{definition}
%Given two categories $\CatC=\tup{\ObC,\to_{\CatC}}$ and $\cat{D}=\tup{\Ob_\cat{D},\to_{\cat{D}}}$, a \emph{set-enriched functor} $F\colon\CatC\to\cat{D}$ consists of the following:
%\begin{description}
%    \item[\quad Objects:] a map $\Ob_F\colon \ObC\to \Ob_\cat{D}$, from objects in \CatC to objects in \CatD.
%    \item[\quad Morphisms:] for every $c_1,c_2\setin\ObC$ a map $F\colon\CatC(c_1, c_2)\to_\Set\cat{D}(\Ob_F(c_1),\Ob_F(c_2))$. In other words, for every $f\colon c_1\to_\CatC c_2$ in \CatC, we associate a $F(f)\colon \Ob_F(c_1)\to_\cat{D} \Ob_F(c_2)$ in \CatD.
%    \item[\quad Identities:] for every $c\setin\CatC$, we have $F(\catid_c)=\catid_{F(c)}$.
%    \item[\quad Composition:] for every $f\colon c_1\to_\CatC c_2$ and $g\colon c_2\to_\CatC c_3$ in \CatC, we have $F(f;g)=F(f);F(g)$ in \CatD.
%\end{description}
%We often denote $\Ob_F$ simply by $F$, \eg \ writing $F(c)$ rather than $\Ob_F(c)$; it overloads the notation $F$, but is often easier to read.
%\end{definition}
