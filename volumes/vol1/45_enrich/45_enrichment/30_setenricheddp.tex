% !TEX root = chapter-standalone.tex

\section{Set-enriched DPs (DPIs)}

\begin{proposition}
    \label{prop:DP_loc_pos}
    \DP is enriched in \Pos.
    Equivalently, it is a locally posetal 2-category: a 2-category where the hom-categories are also posets.
\end{proposition}
\begin{proof}
    Suppose that $f,g\colon \F{\cP} \profto \R{\cQ}$ and $j,k\colon \F{\cQ} \profto \R{\cR}$ are design problems and that $f\Imp g$ and $j\Imp k$.
    We need to show that $(f\then j)\Imp(g\then k)$ in \DP.
    \equationsag{77_dploc}{eq:77_dploc}
    Assume $f\Imp g$ and $j\Imp k$, and choose $\F{p}\setin\F{\cP} $ and $\res\setin\R{\cR}$ such that $(f\then j)(\F{p}^*,\res)=\true$; we must show that $(g \then k)(\F{p}^*,\res)=\true$.
    By assumption, there is some $q\setin Q$ such that $f(\F{p}^*,\R{q})\booland j(\F{q}^*,\res)=\true$.
    But then also $g(\F{p}^*,\R{q})\booland k(\F{q}^*,\res)=\true$, and this implies the result.
\end{proof}
\todotext{Style}
Since posets are also categories, monotone maps between posets can be defined as functors between poset categories (\cref{lem:posetfunctor}).
Furthermore, posets are enriched in \Bool (\cref{ex:enrichbool}), \ie $\Hom_A(a,b) \setin \Bool$ for all $A \setin \Pos$.
So when we say that a design problem~$f$ is ``enriched in \Bool'', we mean that is not only a profunctor $f \colon \F{A} \profto \R{B}$ between posets $A\op \cartprod B$ and \Bool, but that its action on hom-sets is always a morphism in \Bool.
Explicitly,

\begin{widepar}
    \begin{equation}
        f \colon \Hom_{\F{A}\op \cartprod \R{B}}(\tup{\F{a_1}^*,\R{b_1}}, \tup{\F{a_2}^*,\R{b_2}}) \to \Hom_\Bool(f(\tup{\F{a_1}^*,\R{b_1}}), f(\tup{\F{a_2}^*,\R{b_2}}))
    \end{equation}
\end{widepar}
is a morphism in \Bool---in other words, one among the set $1 \leq_\Bool 1, 0 \leq_\Bool 0$, and $0 \leq_\Bool 1$ familiar from \cref{ex:bool}.

\linkvideo{spring2021-enrichment:from-dp-to-upos} % A functor from DP to UPos
\linkvideo{spring2021-enrichment:enriched-functors} % Enriched functors
\begin{ctdefinition}[\iindex{Enriched functor}]
    \label{def:enrichedfunctor}
    Given two categories \CatC and \CatD enriched in the same monoidal category \CatV, an enriched functor~$\funa\colon \CatC \to \CatD$ consists of:
    \begin{enumerate}
        \item A map~$\funa\colon \ObC \sto \ObD$ that maps objects of~\CatC to objects of~\CatD.
        \item For each~$\Obja, \Objb$ in $\ObC$, there exists a morphism in \CatV given by
              \begin{equation}
                  \funa_{\Obja, \Objb} \colon \HomSet\CatC{\Obja}{\Objb} \mto \HomSet\CatD{\funa(\Obja)}{\funa(\Objb)},
              \end{equation}
              such that composing maps ``across~$\funa$'' respects the composition in \CatC and the unit in \CatV in the obvious ways:
              \equationsag{77_enriched_functor}{eq:77_enriched_functor}
              and
              \equationsag{77_enriched_functor_2}{eq:77_enriched_functor_2}
              where~$\mtimescat$ and~$\idmoncat$ are the monoidal product and monoidal unit in \CatV.
    \end{enumerate}
\end{ctdefinition}

\linkvideo{spring2021-enrichment:monotone-maps-bool-func} % Monotone maps are Bool functors

\devel{
    \begin{proposition}
        Design problems in \DP are Boolean-enriched profunctors.
    \end{proposition}
    \begin{proof}
        We will show that any monotone map~$f\colon A \toinPos B$ between posets is a Boolean-enriched functor.
        Then a design problem is simply a Boolean-enriched functor that happens to be a profunctor.

        Monotonicity of~$f$ means that~$a_1 \ordleq_A a_2$ implies $f(a_1) \ordleq_B f(a_2)$.
        Rewriting this condition considering~$A, B$ as categories enriched in \Bool, we have that
        \begin{equation}
            \Hom_A(a_1, a_2) \to \Hom_B(f(a_1), f(a_2)),
        \end{equation}
        which can be re-stated as proclaiming the existence of a morphism~$f_{a_1, a_2}$ in \Bool:
        \begin{equation}
            f_{a_1, a_2} \colon \Hom_A(a_1, a_2) \to_{\Bool} \Hom_B\left(f(a_1), f(a_2)\right).
        \end{equation}
        It remains to be checked that the diagrams in \cref{def:enrichedfunctor} commute.
        The first is trivial since~$a \ordleq_A a$ is true by definition in all posets:
        \begin{equation}
            \id_{a} \then f_{a,a} (\ast) = \id_{f(a) = \true}.
        \end{equation}
        The second is also relatively trivial: the monoidal product is just the conjunction~$\booland$ in \Bool, so commuting with the composition in the poset can be thought of as a verification of the monotonicity of~$f$ via the natural~$\Imp$ inside \Bool:
        \begin{equation}
            \begin{tabular}{ccc}
                $(a \ordleq b) \booland (b \ordleq c)$             & $\to$ & $(a \ordleq c)$ \\
                $\Downarrow$                                       &       & $\Downarrow$ \\
                $(f(a) \ordleq f(b)) \booland (f(b) \ordleq f(c))$ & $\to$ & $(f(a) \ordleq f(c))$
            \end{tabular}
        \end{equation}
    \end{proof}

    Having defined morphisms in \DP as Boolean-enriched design problems, we can directly generalize these Boolean-enriched design problems to \Set-enriched design problems, or esign problems with implementations.
    \begin{widepar}
        \begin{definition}[Design problems with implementation as monotone functions]
            \label{def:dpwithimp}
            Suppose that~\funsp,~\ressp are posets.
            A \emph{\iindex{design problem with implementation}} is a monotone map (a \Set-enriched profunctor)~$\tup{\impsp_d,\prov,\req}\colon \funsp\profto \ressp$, where~$\impsp_d$ is a set,~$\prov$ and~$\req$ are functions from~$\impsp_d$ to~\funsp and~\ressp, respectively
            \begin{equation}
                \funsp \xleftarrow{\prov} I \xrightarrow{\req} \ressp,
            \end{equation}
            and $\tup{\impsp_d,\prov,\req}\colon \funsp\profto \ressp$ is given by

            % \begin{widepar}
            \begin{equation}
                \begin{aligned}
                    \tup{\impsp_d,\prov,\req}\colon \funsp\profto \ressp \colon \funsp\op \cartprod \ressp & \toinPos \powerset(\impsp_\adp) \\
                    \tup{\fun^*, \res}                                                                     & \mapsto \makeset{ \imp \setin \impsp_\adp \colon ( \fun \funleq \prov(i)) \booland (\req(i) \resleq \res) },
                \end{aligned}
            \end{equation}
            % \end{widepar}

            where the partial order on~$\powerset\impsp$ is given by subset inclusion.
        \end{definition}
    \end{widepar}

    \paragraph{Intended semantics}
    When we consider a design problem with implementation $\tup{\impsp_d, \prov, \req}\colon \funsp\profto \ressp$, we imagine the poset \funsp to represent the functionality to be provided and the poset \ressp to represent the resources required.
    The object $\tup{\impsp_d,\prov,\req}\colon \funsp\profto \ressp$ is the set of ways to provide $\fun\setin \funsp$ using $\res\setin \ressp$.

    \noindent The monotonicity of $d$ represents the two assumptions:
    \begin{enumerate}
        \item If \fun is feasible with \res in a set $i$ of ways, then any $\F{f'}\funleq \fun$ is feasible with \res in a set $i'\setsupseteq i$ of ways.
        \item If \fun is feasible with \res in a set $i$ of ways, then \fun is feasible with any $r'\resgeq r$ in a set $i'\setsupseteq i$ of ways.
    \end{enumerate}

    \begin{definition}[Series composition of design problems with implementation]
        \label{def:seriesdpi}
        Given two design problems with implementation $\tup{\impsp_f,\prov_f,\req_f}\colon \F{A}\profto \R{B}$ and $\tup{\impsp_g,\prov_g,\req_g}\colon \F{B}\profto \R{C}$, we can define their series interconnection
        \begin{equation}
            \tup{\impsp_{f\then g},\prov_{f\then g},\req_{f\then g}}\colon \F{A}\profto \R{C}.
        \end{equation}
        as follows.
        With reference to this diagram:
        \begin{equation}
            \F{A} \xleftarrow{\prov_f} \impsp_f \xrightarrow{\req_f} B
            \xleftarrow{\prov_g} \impsp_g \xrightarrow{\req_g} \R{C}
        \end{equation}
        we let the implementation space be the \emph{pullback}
        \begin{equation}
            \begin{aligned}
                \impsp_{f\then g} & = \impsp_f \cartprod_B \impsp_g \definedas \makeset{
                    \tup{i_f,i_g} \setin \impsp_f \cartprod \impsp_g \colon
                    \req_f(i_f) \leq_{B} \prov_g(i_g)
                }, \\
            \end{aligned}
        \end{equation}
        and the two maps $\prov$, $\req$ defined as:
        \begin{equation}
            \begin{aligned}
                \req  & \colon \tup{i_f,i_g} \mapsto \req_2(i_g) \\
                \prov & \colon  \tup{i_f,i_g} \mapsto \prov_1(i_f).
            \end{aligned}
        \end{equation}
        In terms of the profunctors, we have
        \begin{widepar}
            \begin{equation}
                \label{eq:seriesdpi}
                \begin{aligned}
                     & \tup{\impsp_{f\then g},\prov_{f\then g},\req_{f\then g}}\colon \F{A}\cartprod \R{C} \toinPos \powerset(\impsp_f \cartprod_B \impsp_g) \\
                     & \tup{\F{a}^*,\R{c}} \mapsto \bigsetunion_{\substack{(b,b') \setin B\op \cartprod B\op \\ b \leq_B b'}} \Bigg[ \tup{\impsp_f,\prov_f,\req_f}(\F{a}^*,\R{b}) \cartprod \tup{\impsp_g,\prov_g,\req_g}(\F{b'}^*,\R{c}) \Bigg].
                \end{aligned}
            \end{equation}
        \end{widepar}
    \end{definition}

    \begin{lemma}
        The series composition operation for design problems with implementation as in \cref{eq:seriesdpi} is monotone in~$a$ and~$c$.
    \end{lemma}
    \begin{proof}
        Consider \cref{eq:seriesdpi}.
        By choosing $\F{a'}\geq_\F{A} \F{a}$, we have
        \begin{equation}
            \tup{\impsp_{f},\prov_{f},\req_{f}}(\F{a'}^*,\R{c})\setsubseteq \tup{\impsp_{f},\prov_{f},\req_{f}}(\F{a}^*,\R{c}),
        \end{equation}
        and hence
        \begin{equation}
            \tup{\impsp_{f\then g},\prov_{f\then g},\req_{f\then g}}(\F{a'}^*,\R{c})\setsubseteq \tup{\impsp_{f\then g},\prov_{f\then g},\req_{f\then g}}(\F{a}^*,\R{c}).
        \end{equation}
        Similarly, by choosing $\R{c'}\geq_{\R{C}} \R{c}$, we have
        \begin{equation}
            \tup{\impsp_{f},\prov_{f},\req_{f}}(\F{a}^*,\R{c'})\setsupseteq \tup{\impsp_{f},\prov_{f},\req_{f}}(\F{a}^*,\R{c})
        \end{equation}
        and hence
        \begin{equation}
            \tup{\impsp_{f\then g},\prov_{f\then g},\req_{f\then g}}(\F{a}^*,\R{c'})\setsupseteq \tup{\impsp_{f\then g},\prov_{f\then g},\req_{f\then g}}(\F{a}^*,\R{c}).
        \end{equation}
        This shows monotonicity, and hence shows that the series composition of two DPIs is a DPI.
    \end{proof}

    \begin{lemma}
        The series composition operation for design problems with implementation as in \cref{eq:seriesdpi} is associative, \ie  given three (composable) codesign problems with implementation $f,g,h$:
        \begin{equation}
            (f\then g)
            \then h = f\then (g\then h).
        \end{equation}
    \end{lemma}
    \begin{proof}
        Consider three design problems with implementation:
        \begin{equation}
            \begin{aligned}
                f=\tup{{\impsp_f, \prov_f, \req_f} } & \colon \F{A} \profto\R{B,} \\
                g=\tup{\impsp_g, \prov_g, \req_g}    & \colon \F{B} \profto \R{C}, \\
                h=\tup{\impsp_h, \prov_h, \req_h}    & \colon \F{C} \profto \R{D}.
            \end{aligned}
        \end{equation}
        First, we have:
        \begin{equation}
            A \xleftarrow{\prov_f} \impsp_f \xrightarrow{\req_f} B
            \xleftarrow{\prov_g} \impsp_g \xrightarrow{\req_g} C
            \xleftarrow{\prov_h} \impsp_h \xrightarrow{\req_h} D.
        \end{equation}
        We first consider the composition $f\then g$.
        We have:
        \begin{equation}
            \begin{aligned}
                \impsp_{f\then g}                       & = \makeset{
                    \tup{i_f,i_g} \setin \impsp_f \cartprod \impsp_g \colon
                    \req_f(i_f) \ordleq_{B} \prov_g(i_g)
                } \\
                \req_{f\then g}  \colon  \tup{i_f,i_g}  & \mapsto \req_g(i_g) \\
                \prov_{f\then g}  \colon  \tup{i_f,i_g} & \mapsto \prov_f(i_f).
            \end{aligned}
        \end{equation}
        We can now look at~$(f\then g)\then h$.
        We have:
        \begin{equation}
            \begin{aligned}
                 & \impsp_{(f\then g)\then h} = \makeset{
                    \tup{i_{f\then g},i_h} \setin \impsp_{f\then g} \cartprod \impsp_{h}\colon
                    \req_{f\then g}(i_{f\then g}) \ordleq_{C} \prov_h(i_h)
                } \\
                 & =\makeset{
                    \tup{\tup{i_f, i_g},i_h} \setin (\impsp_f \cartprod \impsp_g) \cartprod \impsp_{h}\colon
                    (\req_f(i_f) \ordleq_{B} \prov_g(i_g))
                    \booland
                    (\req_g(i_g) \ordleq_{C} \prov_h(i_h))
                },
            \end{aligned}
        \end{equation}
        ~
        \begin{equation}
            \begin{aligned}
                \req_{(f\then g)\then h} & \colon  \tup{i_{f\then g},i_h} \mapsto \req_h(i_h) \\
                \req_{(f\then g)\then h} & \colon  \tup{\tup{i_f, i_g},i_h} \mapsto \req_h(i_h),
            \end{aligned}
        \end{equation}
        and
        \begin{equation}
            \begin{aligned}
                \prov_{(f\then g)\then h} & \colon  \tup{i_{f\then g},i_h} \mapsto \prov_{f\then g}(i_{f\then g}) \\
                \prov_{(f\then g)\then h} & \colon  \tup{\tup{i_f, i_g},i_h} \mapsto \prov_f(i_f).
            \end{aligned}
        \end{equation}
        Since
        \begin{equation}
            (\impsp_f \cartprod \impsp_g)
            \cartprod \impsp_{h} \cong  \impsp_f \cartprod (\impsp_g \cartprod \impsp_{h}),
        \end{equation}
        the above is exactly what we would obtain for $f\then (g\then h)$, so we can say that~$f\then(g\then h)\cong (f\then g)\then h$, meaning that this composition is associative up to isomorphism.
    \end{proof}

    \begin{definition}[Identity design problem with implementation]
        \label{def:identitydpi}
        The \emph{identity design problem with implementation}~$\tup{\impsp_{\id_A},\prov,\req} \colon \F{A} \profto \R{A}$ is given by implementation set $\impsp_{\id_A} = A$ and $\prov=\req$ being the identity on $A$.
        The profunctor is defined as
        \begin{align}
            \tup{\impsp_{\id_A},\prov,\req} \colon \F{A}\op \cartprod \R{A} & \toinPos \powerset(A) \\
            \tup{\F{a}^*,\R{a'}}                                            & \mapsto (\upit \F{a}) \setintersection (\downarrow \R{a'})
        \end{align}
    \end{definition}
    \begin{remark}
        Alternatively, one can define the identity profunctor as
        \begin{align}
            \tup{\impsp_{\id_A},\prov,\req}\colon \F{A}\op \cartprod \ressp & \toinPos \powerset{A} \\
            \tup{\F{a}^*,\R{a'}}                                            & \mapsto
            \begin{cases}
                \makeset{a}, & \F{a}\ordleq_A \R{a'} \\
                \Emptyset,   & \text{otherwise}.
            \end{cases}
        \end{align}
    \end{remark}

    \begin{lemma}
        The series composition operation for design problems with implementation as in \cref{eq:seriesdpi} satisfies the left and right unit laws (unitality).
    \end{lemma}

    \begin{proof}
        \todojira{248}{Do the proof and see if we need to change some definitions to make it work}
    \end{proof}

    \begin{definition}[Category of \Set-enriched design problems]
        The category of \Set-enriched design problems,~\DPI, consists of the following data:
        \begin{enumerate}
            \item \emph{Objects:}
                  Objects of~\DPI are posets.
            \item \emph{Morphisms:}
                  The morphisms of \DPI are design problems with implementation (\cref{def:dpwithimp}).
            \item \emph{Identity morphism}: The identity morphism is given by \cref{def:identitydpi}.
            \item \emph{Composition operation}: Given two composable morphisms~$f$ and~$g$, their composition $f\then g$ is given by \cref{def:seriesdpi}.
        \end{enumerate}
    \end{definition}

    \begin{lemma}
        \DPI is a category.
    \end{lemma}

    \begin{proof}
        We have already shown that the composition operator in \DPI is associative and unital, and that the composition of two design problems with implementation is a design problem with implementation (closure).
        Therefore, \DPI is a valid category.
    \end{proof}

    Like \DP, \DPI is also a traced symmetric monoidal category with monoidal product $\mtimescat$ and biproduct given by $+$;
    we will skip the proofs for \DPI since most are directly analogous to those for \DP.
    We already saw an example of \DPI in \cref{ex:dpi_example} above.
    It remains to verify that morphisms in \DPI are indeed enriched in \Set:

    \begin{proposition}
        Design problems with implementation are \Set-enriched profunctors.
    \end{proposition}
    \begin{publictodo}
        Proof to be written.
    \end{publictodo}
    \devel{
        \begin{proof}
            Fix a design problem $f \colon A\op \cartprod B \toinPos \powerset \impsp$.
            \todojira{249}{@Gioele: Finish the proof}
        \end{proof}
    }
    We introduce \DPI mainly as a point of comparison; enriching in \Set is the most obvious, if not the most elegant, way of representing and reasoning about implementations of design problems.
    Indeed, the way we defined morphisms is rather clunky (note how~$\impsp_\adp$ is a set rather than a poset, and the extra provisions for~$\prov$ and~$\req$ in the identity morphism), and it also essentially restricts implementations~$\impsp_\adp$ to being subsets of~$\funsp\op \cartprod \ressp$, \ie  an implementation \emph{rigidly} provides a fixed functionality \fun with a fixed \res.

    The far more natural option, from the perspective of enriched category theory, is to enrich design problems in \DP itself.

    \begin{example}
        \begin{equation}
            \begin{aligned}
                \text{engine} \colon \F{\text{Thrust}}\op \cartprod \R{\text{Fuel}} & \toinPos \powerset(\text{Engines}) \\
                \tup{\F{t}^*,\R{f}}                                                 & \mapsto \makeset{ e \setin \text{Engines} \colon e(\F{t}^*, \R{f}) = \true }
            \end{aligned}
        \end{equation}
        where Engines is the hom-poset $\HomSet{\DP}{\text{Thrust}}{\text{Fuel}}$ from \XXX. %\cref{ex:rdproblem}.
    \end{example}

    \todotext{ Now ex:rdproblem is in Playground - copy or remove reference}

    \subsubsection{Operations on DPIs}
}

% \begin{table}[t!]
%     \centering
% \begin{tabular}{c|c|c|crl}
%     series &
%     $f:A\profto B$&
%     $g:B\profto C$&
%     $f;g:$&$A$&$\profto C$ \\
%     %
%     sum &
%     $f:A\profto B$ &
%     $g:A\profto B$ &
%     $f\boolor g:$&$A$&$\profto B$ \\
%     %
%     intersection &
%     $f:A\profto B$ &
%     $g:A\profto B$ &
%     $f\wedge g:$&$A$&$\profto B$ \\
%     %
%     monoidal product &
%     $f:A\profto C$&
%     $g:B\profto D$ &
%     $f\otimes g:$&$A\times B$&$\profto C \times D$ \\
%     %
%     product &
%     $f:A\profto C$&
%     $g:A\profto D$ &
%     $f\times g:$&$A $&$\profto C + D$ \\
%     %
%     coproduct &
%     $f:A\profto C$&
%     $g:B\profto C$ &
%     $f\sqcup g:$&$A + B $&$\profto C$ \\
%     %
%     biproduct &
%     $f:A\profto B$ &
%     $g:A\profto B$ &
%     $f+ g:$&$A + A$&$\profto B + B$ \\
%     %
%     trace &
%     $f: C \times A \profto C \times B$ &
%     -&
%     $\Tr_{A,B}^C(f) :$&$A$&$\profto B$
% \end{tabular}
%     \caption{Various composition operations on design problems (\ie  morphisms) in \DP.}
% \end{table}

%We can now extend the ways we can compose to DPs to the case of DPIs.

%\begin{definition}[Category enriched in $\tup{\Bool,\true,\wedge}$]\label{def:cat_enriched_bool}
%A \emph{category enriched in $\tup{\Bool,\true,\wedge}$}, denoted $\cP =\tup{P,\leqP }$, consists of the following:
%\begin{description}
%\item[\quad 1) Reflexivity:] for any object $p\setin P$, it is true that $p \leqP p$.
%\item[\quad 2) Transitivity:] for any three objects $p_1,p_2,p_3\setin P$, if $p_1\leqP  p_2$ and $p_2\leqP p_3$, then $p_1 \leqP p_3$.
%\end{description}
%\end{definition}

% \begin{example}The only morphisms in \Bool are $\false \leq \false$, $\true \leq \true$, and $\false \leq \true$. For posets and monotone maps, this makes sense, since there is at most one element in each hom-set $\hom_P(p_1,p_2)$ of any poset $P$, so the mapping $F : \hom_P(p_1,p_2) \to \hom_Q(q_1,q_2)$ is either $\false \to \false$ (\ie  $p_1 \not \leq p_2$ so $q_1 \not \leq q_2$), $\true \leq \true$ (\ie  $p_1 \leq p_2$ implies $q_1 \leq q_2$, which is just the naturality condition of being a functor), or $\false \leq \true$ (\ie  $p_1 \not \leq p_2$, and $q_1 \leq q_2$). Importantly, what is not allowed is $\true \to \false$, which contradicts the naturality condition of a functor between posets (\ie  that it is monotone).\end{example}

%\begin{definition}
%Given posets $\cP = \tup{P,\leqP }$ and $\cQ = \tup{Q,\leqQ }$, a \emph{boolean-enriched functor} $F\colon P\to Q$ consists of the following:
%\begin{description}
%    \item[\quad Objects:] a map $F\colon P\to Q$, from objects in $P$ to objects in $Q$.
%    \item[\quad Order:] for every $p_1,p_2\setin P$ an assurance that $\cP(p_1, p_2)\leq_\Bool \cQ(F(p_1),F(p_2))$. In other words, if $p_1\leqP p_2$, then $F(p_1)\leqQ F(p_2)$.
%\end{description}
%We often denote $\Ob_F$ simply by $F$, \eg \ writing $F(c)$ rather than $\Ob_F(c)$; it overloads the notation $F$, but is often easier to read.
%\end{definition}

%\begin{definition}
%Given two posets $\cP =\tup{P,\leqP }$ and $\cQ =\tup{Q,\leqQ }$, a \emph{boolean-enriched profunctor} \[f\colon \cP \profto \cQ \] is a monotone map
%\[
%    f\colon\cP \op\times \cQ \toinPos \Bool.
%\]
%\end{definition}

% Recall that a \Set-enriched functor is just a functor, while a \Set-enriched category is just a category.
% Then:

%\begin{definition}
%Given two categories $\CatC=\tup{\ObC,\to_{\CatC}}$ and $\cat{D}=\tup{\Ob_\cat{D},\to_{\cat{D}}}$, a \emph{set-enriched functor} $F\colon\CatC\to\cat{D}$ consists of the following:
%\begin{description}
%    \item[\quad Objects:] a map $\Ob_F\colon \ObC\to \Ob_\cat{D}$, from objects in \CatC to objects in \CatD.
%    \item[\quad Morphisms:] for every $c_1,c_2\setin\ObC$ a map $F\colon\CatC(c_1, c_2)\to_\Set\cat{D}(\Ob_F(c_1),\Ob_F(c_2))$. In other words, for every $f\colon c_1\to_\CatC c_2$ in \CatC, we associate a $F(f)\colon \Ob_F(c_1)\to_\cat{D} \Ob_F(c_2)$ in \CatD.
%    \item[\quad Identities:] for every $c\setin\CatC$, we have $F(\id_c)=\id_{F(c)}$.
%    \item[\quad Composition:] for every $f\colon c_1\to_\CatC c_2$ and $g\colon c_2\to_\CatC c_3$ in \CatC, we have $F(f;g)=F(f);F(g)$ in \CatD.
%\end{description}
%We often denote $\Ob_F$ simply by $F$, \eg \ writing $F(c)$ rather than $\Ob_F(c)$; it overloads the notation $F$, but is often easier to read.
%\end{definition}
