\sectionexercises{Type theory}

\begin{remark}
    You can skip this section until you want to get started on the code exercises.
\end{remark}

At a basic level, the notion of set seems uncontroversial.
However, there are some difficulties that led to the development of \emph{type theory},
which can be used as an alternative foundation to mathematics.
Type theory is also used as the foundation for computing; the exercises utilize the type theory nomenclature.

If you are an experienced programmer, you likely already have some informal knowledge of type theory which will be sufficient to carry you through these exercises.

% If you would like to know about type theory in a more formal way, our suggestion is to read the wonderfully entertaining \emph{Little Typer}~\cite{friedman2018little}.

If you are more theoretical inclined, a proper comprehensive introduction to type theory is in Pierce's book~\cite{pierce02types}.

\subsection{Sets/elements \vs types/terms}

We do not give here a complete introduction to type theory.
In fact, there are different type systems.
For now, what is important to understand is the difference between set theory and type theory.
This allows translating between the theory parts of this book, which use set theory, and the programming exercises.

In type theory there are two basic kinds: \emph{terms} and \emph{types}.
A term is a formal expression built from the constructions in a language.
A term might have a type.
We write~$a \colon T$ to say that the \emph{term}~$a$ has the \emph{type}~$T$.
For example, we could say~$42 \colon \aword{int}$ to mean that the \emph{term}  $42$ has \emph{type}~$\aword{int}$ (the type of integers).

In set theory there are elements and sets.
It is assumed that elements have ``an identity of their own'': each element is equal to itself and different from the other elements.
Furthermore, elements might \emph{belong} to sets.

In type theory the concepts of \emph{equality} and \emph{belonging} are not primitive.
Rather, we can build them from scratch, enjoying much more flexibility.

For example, we can define a \emph{setoid} as a set-like structure in type theory as follows.

\begin{ctdefinition}[Setoid]
    \label{def:setoid}
    A \maindef{setoid} is a tuple~$S = \tup{T, \aword{contains}, \aword{equal}}$ where
    \begin{itemize}
        \item $T$ is a type;
        \item $\aword{contains}\colon T\sto\boolset$ is a function that tells use whether an element belongs to the \SY{setoid};
        \item $\aword{equal}\colon T\cartprod T\sto\boolset$ is the equality.
              % \item $\aword{apart}:T\times T\to\Bool$ is the apartness function.
    \end{itemize}
\end{ctdefinition}
The function~$\aword{equal}$ should have the properties of an \emph{equivalence relation},
which will be discussed in \cref{def:equivalence-relation}.
% Ignore for now why we need $\aword{apart}$ in addition to $\aword{equal}$; we will return to this topic much later in the exposition.

Here is an example that shows the advantages of such construction.
Imagine we want to represent rational numbers with two numbers, nominator and denominator, using arbitrary integers.
We want to define a \SY{setoid} for which the element~$\tup{2, \shortminus 4}$ is equal to~$\tup{\minusone, 2}$.
Assume that we already have a \SY{setoid} for integers defined, so that we have a function~$\aword{equal}_{\aword{int}}$.

We can do it as follows:
\begin{equation}
    S_1 =
    \begin{cases}
        \begin{aligned}
            T                & =
            \aword{Tuple}[\aword{int}, \aword{int}]
            \\
            \aword{contains} & = \tup{a,b} \mapsto \aword{contains}_{\aword{int}}(a)  \booland \aword{contains}_{\aword{int}}(b)
            \\
            \aword{equal}    & = \tup{\tup{a,b}, \tup{c,d}}
            \mapsto \aword{equal}_{\aword{int}} (a\cdot d, b\cdot c)
        \end{aligned}
    \end{cases}
\end{equation}

One can define a different \SY{setoid} with the same underlying type~$\aword{Tuple}[\aword{int}, \aword{int}]$ where a pair of elements is interpreted as an interval:
\begin{equation}
    S_2 =
    \begin{cases}
        \begin{aligned}
            T                & = \aword{Tuple}[\aword{int}, \aword{int}] \\
            \aword{contains} & = \tup{a,b} \mapsto
            \aword{contains}_{\aword{int}}(a)
            \booland
            \aword{contains}_{\aword{int}}(b)
            \booland
            (a\leq b) \\
            \aword{equal}    & = \tup{\tup{a,b}, \tup{c,d}}
            \mapsto
            \aword{equal}_{\aword{int}}(a,c)
            \booland
            \aword{equal}_{\aword{int}}(b,d)
        \end{aligned}
    \end{cases}
\end{equation}

The elements~$\tup{1,4}$ and~$\tup{2, 8}$ are in both \SY{setoids}.
However, we have that
\begin{equation}
    \aword{equal}_{S_1} (\tup{1,4}, \tup{2, 8}) = \true
    \qqand
    \aword{equal}_{S_2} (\tup{1,4}, \tup{2, 8}) = \false .
\end{equation}
Every time we have an equality we should think about in which \SY{setoid} the equality is understood.
We would rewrite the above as
\begin{equation}
    \tup{1,4} =_{S_1} \tup{2, 8}
    \qqand
    \tup{1,4} \neq_{S_2} \tup{2, 8}.
\end{equation}

\subsection{Python and other design choices}

We chose to use Python as the language for the exercises because, as of 2021, it is the most used language in the world, according to the TIOBE index.

We should also note that, fixed the language, there is considerable freedom in defining the interfaces and the class hierarchy.
We tried to follow these principles:
\begin{itemize}
    \item \emph{Elements are opaque}: We never specify any interface for elements.
          It is the \emph{structure} that ``owns'' the elements that knows how to operate on them.
          For example, we define a \classname{SetProduct} which is a set whose elements are a tuple of elements.
          Rather than defining a class \classname{ElementTuple} that can tell us its \funcname{elements}, there is a function \classname{unpack} in \classname{SetProduct} that tells us the content of the opaque element.

          This works very well and gives the implementer (you) total freedom to choose the internal representation.

          However, this might be counter-intuitive for a beginner, as it goes against the beginner's advice in object-oriented languages, where a \classname{Dog} is an \classname{Animal} that \funcname{barks}.

    \item \emph{Object-oriented composition over inheritance}:
          Two basic principles of object-oriented programming are ``composition'' (create complex objects out of simpler objects) and ``class inheritance'' (subclass a simple class to obtain a more complex class).
          An example use of inheritance would be saying: ``a \SY{poset} is a set which also has an order relation''; composition would be saying ``a \SY{poset} is a tuple of a set and an order relation''.
          We adopt composition, which is also the way we define mathematical objects.
          The over-use of inheritance is another beginner mistake in object-oriented programming.
\end{itemize}

