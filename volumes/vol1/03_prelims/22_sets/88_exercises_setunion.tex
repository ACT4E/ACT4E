\sectionexercises{Set union \hardexercise}
\begin{remark}
    This is a more advanced exercise; feel free to skip the first time around.
\end{remark}

When in mathematics we compute the union of two sets, we obtain a set, but we forget the structure.
We cannot do this when we take a constructive approach.

For example, suppose that we have two \Setoid{}s $\setA = \makeset{a,b,c}$ and~$\setB = \makeset{a,b,3}$.
By all accounts the elements $a,b$ are in both.
However, how can we judge that~$a=b$?
Should we use the first setoid or the second?
Both?
What if they disagree?

One way to think about it is the following: we judge two elements as different if they fail according to any of the tests at our disposal.
The first set of tests that we have is that we can test if they belong to each setoid.
If they are not in exactly the same set of setoids, then we judge them differently.

Now, suppose that the two elements belong to the same set of setoids.
In this case we judge them as equal if they are equal according to all the setoids.

% Let's look at it the other direction: if you have two objects x and y, when are they *different*?
% I would say: whenever they are different with respect to any of the setoids.
% For example: if x belongs to only one subsetoid, and y belongs only to another setoid: well, I would say they are different.
% So if there are no common subsetoids, then they are DIFFERENT.
% They are also DIFFERENT if any of the setoids judges them unequal.

% We choose this semantics: when comparing two elements, we see the set of components to which they both belong.
% Then we compare them using all the equalities.
% The elements are equal if they are equal according to all of them.

\todotextjira{724}{\bernina: @Andrea: think about the implications of this idea.}

From the point of view of the implementation, we create an interface like in \cref{lst:SetUnion}, together with \EnumerableSetUnion and \FiniteSetUnion, not shown.

\classlisting{SetUnion}

The method \funcname{components} allows us to recover the components for the union.

\codeboilerplate{FiniteMakeSetUnion}{
    (For advanced students)
}

\begin{widepar}
    \aligninner{%
        \begin{minipage}{14cm}
            \classlisting{FiniteMakeSetUnion}
        \end{minipage}
    }
\end{widepar}

% The \str{@overload} annotations means that:
% \begin{itemize}
%     \item if the method is given all \FiniteSet, it should return a \FiniteSet;
%     \item if the method is give all \EnumerableSet, it should return an \EnumerableSet;
%     \item otherwise, in the general case, it should return a \Setoid.
% \end{itemize}

\margindatafilefig{set_union}{Union}{fig:set_union}

Extend now the code you wrote for loading sets to allow the format in \cref{fig:set_union}.

\todo{add test for this?}

%This is the algorithm to implement.
%
% Given a dictionary:
% \begin{enumerate}
%     \item If it has a field \fieldname{elements}, it is a finite set described with elements directly.
%     \item If it has a field \fieldname{union}, then the value must be a list of set representation dictionaries.
%     \item Otherwise, it is an error --- for now; we will introduce many more ways to describe sets.
% \end{enumerate}

In particular, note that these are valid representations.

\begin{widepar}
    \begin{tabular}{cccc}
        An empty set                             &
        The union of 1 empty set                 &
        The union of 2 empty sets                &
        The union of zero sets \\
        %
        \datafile{set_empty}{min_lines=5}        &
        \datafile{set_union_empty1}{min_lines=5} &
        \datafile{set_union_empty2}{min_lines=5}
                                                 &
        \datafile{set_union_zero}{min_lines=5} \\
    \end{tabular}
\end{widepar}
