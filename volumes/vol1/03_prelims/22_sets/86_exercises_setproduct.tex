\sectionexercises{Set products}

We define a \classname{SetProduct} to be a \Setoid that also has the structure of the Cartesian product of sets.
This means that:
\begin{itemize}
    \item It is possible to recover the ``factors'' of the product (if $\setA = \makecartprod{\setB, \setC, \setD}$, we must be able to recover the components $\setB, \setC, \setD$ from $\setA$);
    \item It is possible to access the elements of a tuple (if $\setA = \makecartprod{\setB, \setC, \setD}$ and $x = \tupp{\setBel, \setCel, \setDel}$, we should be able to access the components of the tuple).
    \item On the other way around: it is possible to construct a tuple from the single components.
\end{itemize}
Our Python interpretation of these properties is specified in the class \classname{SetProduct}.

\classlisting{SetProduct}

The semantics is the following:
\begin{itemize}
    \item The generic type variable \TypeVar{C} represents the type of the components; the generic type variable \TypeVar{E}
          refers to the type of the product.
          Note that we are not constraining the internal representation of the product.
          (A possible choice could be \pystr{E = List[C]}).
    \item The method \funcname{components} returns the ordered list of the setoid factors; these must be setoids of type \TypeVar{C}.
    \item The method \funcname{pack} takes a number of arguments and creates an element of the product.
    \item The method \funcname{unpack} allows to recover the components of an element of the product.
\end{itemize}

There is also a specialization, which corresponds to a product of finite sets; the only change is that the components are finite sets rather than setoids.

\classlisting{FiniteSetProduct}

\codeboilerplate{FiniteMakeSetProduct}{

}
\classlisting{FiniteMakeSetProduct}{}

As in the previous exercises, you need to implement the class \classname{FiniteSetProduct} and all the methods from the classes in inherits from as well as the \funcname{__init__} method.
This procedure will be similar for subsequent exercises and won't be repeated every time.

%\clearpage

\subsection{Representation}
% The interface above means that if you are passed 2 \FiniteSet{}s, you should return a \FiniteSet.
% Otherwise, you should return a \Setoid.

\margindatafilefig{set_product}{$\makeset{a,b} \cartprod \makeset{1,2}$}{fig:set_product}

\margindatafilefig{set_product111}{$\makeset{1} \cartprod \makeset{1} \times \makeset{1}$}{fig:set_product11}%

\margindatafilefig{set_product10}{$\makeset{1} \cartprod\Emptyset$}{fig:set_product10}%

\begin{codeexercise}[\exname{TestFiniteSetRepresentationProduct}]
    Extend now the code you wrote for loading and saving sets to allow the format in \cref{fig:set_product,fig:set_product11,fig:set_product10}.
    We add another clause to the parsing algorithm:
    \begin{enumerate}
        \item If it has a field \fieldname{elements}, it is a finite set described with elements directly.
        \item If there is a field \fieldname{product}, it must be a list of sets, and the semantics is the product of those sets.
        \item Otherwise, it is an error -- for now; we will introduce many more ways to describe sets.
    \end{enumerate}
    Test your results using
    %: note this cannot be boilerplate
    \checkexercise{FiniteSetRepresentationProduct}
\end{codeexercise}
