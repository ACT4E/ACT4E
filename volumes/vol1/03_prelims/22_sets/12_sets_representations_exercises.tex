\sectionexercises{Representing sets}

As a first step, we are going to build together the support for sets.

\begin{marginfigure}
    \includesag{setoid-finiteset}

    \caption{UML inheritance diagram}
    \label{fig:Setoid-inheritance}
\end{marginfigure}

We define three interfaces:
\begin{itemize}
    \item \Setoid, for a generic set;
    \item \EnumerableSet, for a set that can enumerate its elements;
    \item \FiniteSet, for a set that has a finite set of elements.
\end{itemize}

They are defined in the package \str{act4e_interfaces} which is in the repository \str{ACT4E/ACT4E-exercises}.

\Cref{fig:Setoid-inheritance} shows their relation in a UML diagram.
The arrow means ``inherits from''.

\subsection*{Setoids}

\Cref{lst:Setoid} shows the interface for \Setoid.

\classlisting{Setoid}

\Setoid is declared ``generic'' in \TypeVar{E}; that represents the type of the elements.

The class \Setoid derives from \ABC, which means \emph{abstract base class}; it tells the interpreter that some class methods will have to be implemented by the subclasses.
This is the equivalent of the ``virtual'' methods in C++.
The methods that need to be implemented are marked by a decorator \pystr|@abstractmethod|.
For \Setoid, we ask that the implementer implements the \funcname{contains} function, and they can optionally implement \funcname{equal}.

This is the semantics of the first three methods:

\begin{itemize}
    \item The method \funcname{contains} checks if an element is part of this set.
    \item The method \funcname{equal} checks if two elements are the same.
          The default way to do this is to use Python's equality operator (which calls the \pystr|__equal__| method of the class of the first object); later we will see cases in which we might want to choose something different.
    \item The method \funcname{apart} checks that two elements are ``apart''.
          You can ignore this for the entire first volume, but it will become more relevant later when we talk more in detail about constructivism.
          \footnote{%
              See \href{https://en.wikipedia.org/wiki/Apartness_relation}{Apartness relation} on Wikipedia.
          }
\end{itemize}

There are other methods that have to do with serializing/deserializing the data:

\begin{itemize}
    \item The method \funcname{save} saves an object into a ``concrete representation'', indicated by the placeholder type \ConcreteRepr.
          We use this type to mean something that can be serialized to YAML.
    \item The method \funcname{load} does the inverse.
\end{itemize}

Note that YAML supports the following types: \pystr{int}, \pystr{bool}, \pystr{float}, \pystr{datetime}, \pystr{dict}, \pystr{list}.
Python values composed by these types and compositions are directly representable in YAML.
There are two exceptions to note:
\begin{itemize}
    \item Class instances;
    \item Tuples.
\end{itemize}
If you use internally those types, you need to come up with a way to represent the data.

For example, imagine that you are using internally a class \classname{Vector}:
%
\begin{minted}{python}
@dataclass
class Vector:
    x: int
    y: int
    z: int

a = V(1,2,3)
\end{minted}

You might choose either of these possible variations for serialization:

\begin{tabular}{ll}
    Serialize as array      &
    \begin{minipage}{4cm}
        \begin{minted}{python}
[1, 2, 3]
        \end{minted}
    \end{minipage} \\
    Serialize as dictionary &
    \begin{minipage}{4cm}
        \begin{minted}{python}
{'x': 1, 'y': 2, 'z': 3}
        \end{minted}
    \end{minipage}
\end{tabular}

The choice is up to you; and the choice is encoded in the load/save functions of the \Setoid interface.

\subsection*{Enumerable sets}

\Cref{lst:EnumerableSet} shows the interface for \EnumerableSet:

\classlisting{EnumerableSet}

The class inherits from \Setoid and adds the method \funcname{elements}.
The method returns a Python \Iterator: you can use it to get the elements contained in the \EnumerableSet.
Note that an iterator does not necessarily terminate.

\subsection*{Finite sets}

\Cref{lst:FiniteSet} shows the interface for \FiniteSet.

\classlisting{FiniteSet}

The additional method \funcname{size} returns the size of the set.
For a \FiniteSet, the iterator return \funcname{elements} terminates.

You will have to implement the \FiniteSet class as part of the exercise.

\subsection*{Representation for finite sets }

\begin{marginfigure}
    \begin{minted}{yaml}
elements: [a, b, c]
    \end{minted}
    \caption{Example shown in YAML format.}
    \label{fig:set1}
\end{marginfigure}

\begin{marginfigure}
    \begin{minted}{python}
{"elements": ["a", "b", "c"] }
    \end{minted}
    \caption{We show data formats in YAML because it is terse, but in the exercises you will receive the Python data structure directly.}
    \label{fig:as-python}
\end{marginfigure}

We have defined formats for all the structures to be used in the exercises.
The file format for \FiniteSet is shown in \cref{fig:set1}.
The file represents a dictionary with only one field called \fieldname{elements}, which contains a list of elements.
YAML can represent most primitive data format of Python, as well as lists and dictionaries.
We visualize the data samples in the book using YAML, but you never have to deal with YAML yourself.
You can expect to receive a Python data structure as in~\cref{fig:as-python}.

Throughout the exercises we will encounter many times classes that must load or save data.
We describe them through the interfaces of \classname{Loader}, \classname{Saver}, and (union of the two) \classname{Serializer}.
The two type parameters \TypeVar{X} and \TypeVar{R} correspond to the Python type that they serialize and to the resulting serialization format.
For now, you can ignore the argument \pystr{h: IOHelper}.

\classlisting{Loader}
\classlisting{Saver}
\classlisting{Serializer}

In particular, \classname{FiniteSetRepresentation} is a serializer of \classname{FiniteSet}.
The type \classname{Finite\-Set\_desc} is a type that describes the serialization format in \cref{fig:set1}.
We don't show it, but you can click through and see the definition in the development environment.

\classlisting{FiniteSetRepresentation}

In the listing above, for clarity, we wrote the signature of the methods \funcname{load} and \funcname{save};
however, these are implied by the fact that the class inherits from \classname{Serializer}.

\begin{codeexercise}[\exname{TestFiniteSetRepresentation}]
    \label{ex:setrepr}
    The first exercise is to implement the methods that read and write from this file format.
    You have to implement the interface \FiniteSetRepresentation shown in \cref{lst:FiniteSetRepresentation}.
    As part of the exercise, you will also have to implement a concrete subclass of \FiniteSet.

    Check your solution using:

    \checkexercise{FiniteSetRepresentation}

\end{codeexercise}

% \begin{longcode}
%     \centering
%     \caption{}\label{lst:FiniteSetRepresentation}
%     \classsource{FiniteSetRepresentation}{remove_comments=True}
% \end{longcode}

% %
% \begin{marginfigure}
%     \includesag{dirtree-relevant}
%     \caption{Relevant files for the moment}
%     \label{fig:dirtree-relevant}
% \end{marginfigure}

\subsection{Walk-through for first exercise}

We are going to solve this exercise together.

We assume that you have checked out the template repository as explained in the setup section.

% Of all the files in the repository, we only need the ones displayed in \cref{fig:dirtree-relevant}.
There is already a skeleton implemented in the template in the file

\files{act4e_solutions/sets_representation.py}

which contains the following:

\begin{longcode}
    \caption{}
    \visualizemodule{act4e_book_examples.initial}{}

    \label{lst:act4e_book_examples.initial}
\end{longcode}

We can start by checking if this is a valid solution.
Type this:

\checkexercise{FiniteSetRepresentation}

Here \exname{TestFiniteSetRepresentation} is the code name for the exercise.
You can check other exercises by changing the name.

This will fail; it will complain saying that some parts of the exercise were not implemented.

% Create a file called \files{first.py} in the \files|src/act4e_solutions| directory.
% This file will contain the implementation of the classes.

First, you need to add your implementation of \classname{FiniteSet}.
You can do this in \files{act4e_solutions/sets_representation.py} or create a separate file (called \files{act4e_solutions/my_finite_sets.py} for instance).
For the latter, don't forget to import the newly created class in \files{act4e_solutions/sets_representation.py} by adding the following line:
\begin{minted}{python}
    from .my_finite_sets import MyFiniteSet
\end{minted}
A possible skeleton is in \cref{lst:act4e_book_examples.empty}.
Note that what matters, is the class you are concretely implementing, and not the name you give to it.

\begin{longcode}
    \caption{}
    \visualizemodule{act4e_book_examples.empty}{}

    \label{lst:act4e_book_examples.empty}
\end{longcode}

At this point we need to implement the rest of the code.

For example, \cref{lst:act4e_book_examples.f1} is a valid implementation of \FiniteSet.

\begin{longcode}
    \caption{}
    \visualizemodule{act4e_book_examples.f1}{}
    \label{lst:act4e_book_examples.f1}
\end{longcode}

The loading and saving of the data is very simple.
To load just take the \fieldname{elements} field of the data structure and give it to \classname{MyFiniteSet}.
To save, reconstruct the list elements from the \classname{MyFiniteSet} instance by using the method \funcname{elements}, which returns an iterator.
Note that the \funcname{save} function you have to implement must work for all \FiniteSet instances, not just your particular implementation of \FiniteSet; therefore, you cannot access the \pystr{_elements} field directly.
An example of this is shown in \cref{lst:act4e_book_examples.f2}.

\begin{longcode}
    \caption{}
    \visualizemodule{act4e_book_examples.f2}{}
    \label{lst:act4e_book_examples.f2}
\end{longcode}

With this code, the tests should pass.
Try again to run:

\checkexercise{FiniteSetRepresentation}

Note that the types used by the function \funcname{save} of \classname{SolFiniteSetRepresentation} is \FiniteSet,
not \classname{MyFiniteSet}.
The method must be able to work for \emph{any} implementation of \FiniteSet,
not just yours.
In fact, the tester will try to call that function with a different implementation.

Note that the implementation above uses this line to get the elements:

% \begin{minted}{python}
%     all_elements = sorted(f.elements())
% \end{minted}

\begin{minted}{python}
    all_elements = [f.save(h, _) for _ in f.elements()] # ok
\end{minted}

This is correct because it is using the method \funcname{elements} that all implementations of \FiniteSet need to have.
What could be wrong is using code like the following:

% \begin{minted}{python}
%   all_elements = sorted(f._elements)
% \end{minted}

\begin{minted}{python}
    all_elements = [f.save(h, _) for _ in f._elements] # !!! not correct
\end{minted}

This code accesses the attribute \pystr|_elements| of the class \classname{MyFiniteSet}.
It will not work with other implementations.
In fact, the tests will fail.
