\section{Monoidal-space-time procedures}
\label{subsec:monoidal-space-time}
We continue the example in \cref{sec:ProcMod}.

Procedures need both computation (time) and memory (space).

\todographicsjira{535}{\alphubel: @Andrea: Simple graphics to accompany explanation.}
Time and space are somehow orthogonal.
%
Informally, consider two procedures that need time and memory given by~$\tupp{t_1,m_1}$ and~$\tupp{t_2, m_2}$.
If we compose them in series, we need to sum the times, but we can re-use the same memory.
We can bound the resource consumption by~$\tupp{t_1+t_2,\max(m_1, m_2)}$.
If instead we run them in parallel, we can save on the time, but we need separate memories, so that the consumption is~$\tupp{\max(t_1,t_2), m_1 + m_2}$.

We capture this more generally as follows.
We require both time and space to be monoidal \SY{lattices}~$\tupp{\TimeMonoidal, \mtimescatof{\TimeMonoidal}, \joinof{\TimeMonoidal}}$ and~$\tupp{\SpaceMonoidal, \mtimescatof{\SpaceMonoidal}, \joinof{\SpaceMonoidal}}$.
%
We will define series and parallel composition as follows:
\begin{equation}
    \begin{aligned}
        \tupp{t_1,m_1} \mthenof {\SpaceTime} \tupp{t_2,m_2}    & = \tupp{t_1 \mtimescatof{\TimeMonoidal} t_2, m_1 \joinof{\SpaceMonoidal} m_2}, \\
        \tupp{t_1,m_1} \mtimescatof{\SpaceTime} \tupp{t_2,m_2} & = \tupp{t_1 \joinof{\TimeMonoidal} t_2, m_1 \mtimescatof{\SpaceMonoidal} m_2}.
    \end{aligned}
\end{equation}
We use the \SY{join} operation~$\join$ to model the idea of~$\max$.

We now generalize the definition of~$\ProcMod$ into~$\ProcSTMod$.

\begin{definition}
    [Semicategory $\ProcSTMod$]
    \label{def:ProcSTMod}
    For given monoidal \SY{lattices}~$\tupp{\TimeMonoidal, \mtimescatof{\TimeMonoidal}, \joinof{\TimeMonoidal}}$ and~$\tupp{\SpaceMonoidal, \mtimescatof{\SpaceMonoidal}, \joinof{\SpaceMonoidal}}$, the \SY{semicategory} $\ProcSTMod$ consists of the following constituents:
    \begin{enumerate}
        \item \emph{Objects}: The objects are poset-sized sets.
        \item \emph{Morphisms}: A morphism
              \begin{equation}
                  \mora \colon \Obja \mtoin\ProcSTMod \Obja
              \end{equation}
              between the two objects
              \begin{equation}
                  \Obja = \tupp{\setA, \Sigma_{\setA}, \sizefun_{\setA}}
                  \qqand
                  \Objb = \tupp{\setB, \Sigma_{\setA}, \sizefun_{\setB}}
              \end{equation}
              is a tuple
              \begin{equation}
                  \tupp{\mora_e, \sizetran, \timefun, \spacefun },
              \end{equation}
              where:
              \begin{enumerate}
                  \item $\mora_e \colon \setA \sto \setB$ is the function computed;
                  \item $\sizetran\colon \Sigma_{\setA} \toinPos \Sigma_{\setB}$ is a \SY{monotone function} that keeps track of how the size changes.
                  \item $\timefun\colon \Sigma_{\setA} \toinPos \TimeMonoidal$ is a \SY{monotone function} that gives computation time as a function of instance size;
                  \item $\spacefun\colon \Sigma_{\setA} \toinPos \SpaceMonoidal$ is a \SY{monotone function} that gives memory needed as a function of instance size.
              \end{enumerate}

        \item \emph{Composition}: The composition of
              \begin{equation}
                  \tupp{\mora_1, \sizetran_1,  \timefun_1, \spacefun_1 }
                  \qqand
                  \tupp{\morb_2, \sizetran_2,  \timefun_2, \spacefun_2 }
              \end{equation}
              is given by
              \begin{equation}
                  \tupp{
                      \mora_{1;2},
                      \sizetran_{1;2},
                      \timefun_{1,2},
                      \spacefun_{1,2}
                  },
              \end{equation}
              where
              \begin{equation}
                  \mora_{1;2} = \mora_1 \mthen \morb_2,
              \end{equation}
              \begin{equation}
                  \sizetran_{1;2} = \sizetran_1 \mthen \sizetran_2,
              \end{equation}
              \begin{equation}
                  \defmapperiodset{
                      \timefun_{1,2}
                  }{
                      \Sigma_{\setA}
                  }{
                      \TimeMonoidal
                  }{
                      \sigma_{\setA}
                  }{
                      \timefun_1(\sigma_{\setA}) \mtimescatof{\TimeMonoidal} \timefun_2(\sizetran_1(\sigma_{\setA}))
                  }
              \end{equation}
              \begin{equation}
                  \defmapperiodset{
                      \spacefun_{1,2}
                  }{
                      \Sigma_{\setA}
                  }{
                      \SpaceMonoidal
                  }{
                      \sigma_{\setA}
                  }{
                      \spacefun_1(\sigma_{\setA}) \joinof{\SpaceMonoidal} \spacefun_2(\sigma_{\setA})
                  }
              \end{equation}
    \end{enumerate}
\end{definition}

We can also give~$\ProcSTMod$ the structure of a stacking category as follows:

\begin{lemma}\label{lem:ProcSTMod-stacking}
    $\ProcSTMod$ is a stacking \SY{semicategory} as follows.
    For two objects
    \begin{equation}
        \Obja = \tupp{\setA, \Sigma_{\setA}, \sizefun_{\setA}}
        \qqand
        \Objb = \tupp{\setB, \Sigma_{\setB}, \sizefun_{\setB}}
    \end{equation}
    we define the combined object~$\Obja \mtimescatob \Objb$ by combining the sets and functions
    \begin{equation}
        \Obja \mtimescatob \Objb = \tupp{
            \cObj {\setA,\setB},
            \cObj {\Sigma_{\setA}, \Sigma_{\setA}},
            \sizefun_{\setA\setB}
        },
    \end{equation}
    where
    \begin{equation}
        \defmapperiodset{
            \sizefun_{\setA\setB}
        }{
            \cObj {\setA, \setB}
        }{
            \cObj {\Sigma_{\setA}, \Sigma_{\setA}}
        }{
            \tup{a,b}
        }{
            \tup{
                \sizefun_{\setA}(a),
                \sizefun_{\setA}(b)
            }
        }
    \end{equation}

    For two morphisms
    \begin{equation}
        \mora_1 \colon \Obja_1 \mto \Objb_1
        \qqand
        \mora_2 \colon \Obja_2 \mto \Objd_2,
    \end{equation}
    % where the four objects involved are:
    % \begin{align}
    %     \Obja &= \tupp{\setA, \Sigma_{\setA}, \sizefun_{\setA}} \\
    %     \Objb &= \tupp{\setB, \Sigma_{\setB}, \sizefun_{\setB}} \\
    %     \Objc &= \tupp{\setC, \Sigma_{\setC}, \sizefun_{\setC}} \\
    %     \Objd &= \tupp{\setD, \Sigma_{\setD}, \sizefun_{\setD}}
    % \end{align}
    represented as follows:
    \begin{align}
        \mora_1 & = \tupp{\mora^e_1, \sizetran_1, \timefun_1,
        \spacefun_{1} } \\
        \mora_2 & = \tupp{\mora^e_2, \sizetran_2, \timefun_2, \spacefun_{2} }
    \end{align}
    we define the parallel stack as
    \begin{equation}
        \mora_1 \mtimescatmor \mora_2 = \tupp{
        \mora^e_{1\otimes2},
        \sizetran_{1\otimes2},
        \timefun_{1\otimes2},
        \spacefun_{1\otimes2}
        },
    \end{equation}
    where
    \begin{equation}
        \mora_{1\otimes2} = \tupp{\mora_1, \morb_2},
    \end{equation}
    \begin{equation}
        \sizetran_{1\otimes2} = \tupp{\sizetran_1, \sizetran_2},
    \end{equation}
    \begin{equation}
        \defmapperiodset{
            \timefun_{1\otimes 2}
        }{
            \cObj {\Sigma_{\setA}, \Sigma_{\setB}}
        }{
            \TimeMonoidal
        }{
            \tupp{\sigma_{\setA}, \sigma_{\setB}}
        }{
            \timefun_1(\sigma_{\setA}) \joinof{\TimeMonoidal} \timefun_2(\sigma_{\setB})
        }
    \end{equation}
    \begin{equation}
        \defmapperiodset{
            \spacefun_{1\otimes2}
        }{
            \cObj {\Sigma_{\setA}, \Sigma_{\setB}}
        }{
            \SpaceMonoidal
        }{
            \sigma_{\setA}
        }{
            \spacefun_1(\sigma_{\setA}) \mtimescatof{\SpaceMonoidal} \spacefun_2(\sigma_{\setB})
        }
    \end{equation}
\end{lemma}

\begin{lemma}
    For generic monoidal \SY{lattices}~$\tupp{\TimeMonoidal, \mtimescatof{\TimeMonoidal}, \joinof{\TimeMonoidal}}$ and $\tupp{\SpaceMonoidal, \mtimescatof{\SpaceMonoidal}, \joinof{\SpaceMonoidal}}$, the \SY{semicategory} $\ProcSTMod$ is \emph{not} a \SY{functorial stacking semicategory}.
\end{lemma}

\todojira{625}{describe when it is (some commutation property)}
