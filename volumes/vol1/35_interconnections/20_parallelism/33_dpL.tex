% !TEX root = chapter-standalone.tex

\section{The category \cCat{\DP}}
\begin{definition}[The category \cCat{\DP}]
    The category~$\cCat{\DP}$ is:
    \begin{enumerate}
        \item \emph{Objects:}
              posets of tuples.
        \item \emph{Morphisms:}
              A morphism from~$\posA =\cObj{\posA_1,\ldots, \posA_m}$ to ~$\posB = \cObj{\posB_1,\ldots, \posB_m}$ is design problem:
              \begin{equation*}
                  \adp\colon \cObj{\posA\op, \posB} \toinPos \Bool.
              \end{equation*}
        \item \emph{Composition:}
              Composition is the usual composition of design problems.
        \item \emph{Identities:}
              The identity morphism on an object~$\posA=\cObj{\posA_1,\ldots,\posA_n}$ is given by the identity design problem~$\catid_\posA$.
    \end{enumerate}
\end{definition}
\begin{remark}
    In other words, \cCat{\DP} is the subcategory of \DP in which objects are of the form presented in \cref{eq:posetoftuples}.
\end{remark}

Analogously to what we did for~$\cCat{\Set}$ and~$\cCat{\Pos}$, one can define a multiplication operation for~$\cCat{\DP}$.
Given two design problems
\begin{equation*}
    \begin{aligned}
        \adpa\colon \cObj{\posA\op, \posC} & \toinPos \Bool \\
        \adpb\colon \cObj{\posB\op, \posD} & \toinPos \Bool,
    \end{aligned}
\end{equation*}
one can define
\begin{equation}
    \label{eq:dpmulti}
    \adpa \cproddp \adpb \colon \cObj{\posA\op, \posB\op,\posC,\posD}\toinPos \Bool
\end{equation}
where
\begin{equation*}
    (\adpa \cproddp \adpb)  (\tup{\posAnel{}\opel,\posBnel{}\opel,\posCnel{},\posDnel{}})
    \definedas\adpa(\tup{\posAnel{}\opel,\posCnel{}})\booland
    \adpb(\tup{\posBnel{}\opel,\posDnel{}}).
\end{equation*}

We now consider the stacking operation on objects we considered for~$\cCat{\Pos}$, and the stacking operation on morphism defined as
\begin{equation*}
    \defmapcomma{\mtimescatmor}{\Mor_{\cCat{\DP}} \cartprod \Mor_{\cCat{\DP}}}{\mto}{\Mor_{\cCat{\DP}}}{\tup{\adpa,\adpb}}{\adpa \cproddp \adpb},
\end{equation*}

\begin{lemma}
    \cCat{\DP}, equipped with the aforementioned stacking operations on objects and morphisms, is associative stacking.
\end{lemma}

\begin{proof}
    We show that~$\cCat{\DP}$ is an associative stacking semicategory.
    We first show that it is a stacking category, by first showing that the stacking operations indeed fulfill \cref{def:simple-stacking-semi-cat}, and then showing the compatibility condition.
    The stacking operation on objects fulfills \cref{def:simple-stacking-semi-cat}, since, given two posets of tuples it returns a poset of tuples.
    To show that the stacking operation on morphism fulfills \cref{def:simple-stacking-semi-cat}, we need to show that given design problems~$\adpa,\adpb$, the morphism~$\adpa \mtimescatmor \adpb$ is a design problem.
    This is easy to show, by leveraging the fact that~$\adpa$ and~$\adpb$ are design problems.
    We know that
    \begin{equation*}
        \prfcomma{\tup{\posAnel{}\opel,\posBnel{}\opel,\posCnel{},\posDnel{}} \posleqof{\cObj{\posA\op, \posB\op,\posC,\posD}} \tup{{\posAnel{}'}\opel,{\posBnel{}'}\opel,\posCnel{}',\posDnel{}'}}
        {(\posAnel{}\opel \posleqof{\posA\op} {\posAnel{}'}\opel) \booland (\posBnel{}\opel \posleqof{\posB\op} {\posBnel{}'}\opel)\booland (\posCnel{}\posleqof{\posC}\posCnel{}')\booland (\posDnel{}\posleqof{\posD}\posDnel{}')}
    \end{equation*}
    and that~$\booland$ is a monotone operator.
    Therefore,~$\adpa \cproddp \adpb$ is a design problem.
    Furthermore, the two stacking operations are compatible:
    \begin{equation*}
        \prfperiod{\adpa\colon \cObj{\posA\op, \posC} \toinPos \Bool}
        {\adpb\colon \cObj{\posB\op, \posD}\toinPos \Bool}
        {\adpa \cproddp \adpb \colon \cObj{\posA\op, \posB\op,\posC,\posD}\toinPos \Bool}
    \end{equation*}

    \begin{comment}
    For brevity, we write~$\posAnel{}=\tup{\posAnel{1},\ldots, \posAnel{m}}$,~$\posBnel{}=\tup{\posBnel{1},\ldots, \posBnel{n}}$,~$\posCnel{}=\tup{\posCnel{1},\ldots, \posCnel{o}}$, and~$\posDnel{}=\tup{\posDnel{1},\ldots, \posDnel{t}}$.
    One has:
    \begin{equation*}
        \prfperiod{
        \posAnel{}\tupconcat \posBnel{}\posleqof{\cObj{\posA_1, \ldots, \posA_m, \posB_1, \ldots, \posB_n}} \posAnel{}'\tupconcat \posBnel{}'
        }
        {\prftree{(\posAnel{} \posleqof{\cObj{\posA_1,\ldots, \posA_m}} \posAnel{}') \booland (\posBnel{} \posleqof{\cObj{\posB_1,\ldots, \posB_n}} \posBnel{}')}
        {\prftree{(\adpa(\posAnel{}\opel,\posCnel{})\posgeqof{\Bool} \adpa({\posAnel{}'}\opel,\posCnel{}))
                \booland
                (\adpb(\posBnel{}\opel,\posDnel{})\posgeqof{\Bool} \adpb({\posBnel{}'}\opel,\posDnel{}))}
            {
                \prftree{
                    (\adpa({\posAnel{}}\opel,\posCnel{})\booland \adpb(\posBnel{}\opel,\posDnel{}))
                    \posgeqof{\Bool}
                    (\adpa({\posAnel{}'}\opel,\posCnel{})\booland \adpb({\posBnel{}'}\opel,\posDnel{}))
                }
                {(\adpa \cprod \adpb)((\posAnel{}\tupconcat \posBnel{})\opel,\posCnel{}\tupconcat \posDnel{})\posgeqof{\Bool}
                    (\adpa \cprod \adpb)((\posAnel{}'\tupconcat \posBnel{}')\opel,\posCnel{}\tupconcat \posDnel{})} }
            }
        }
    \end{equation*}
    For the second iteration, one has:
    \begin{equation*}
        \prfperiod{
        \posCnel{}\tupconcat \posDnel{}\posleqof{\cObj{\posC_1, \ldots, \posC_o, \posD_1, \ldots, \posD_t}} \posCnel{}'\tupconcat \posDnel{}'
        }
        {\prftree{(\posCnel{} \posleqof{\cObj{\posC_1,\ldots,\posC_o}} \posCnel{}') \booland (\posDnel{}\posleqof{\cObj{\posD_1,\ldots, \posD_t}} \posDnel{}')}
        {\prftree{(\adpa(\posAnel{}\opel,\posCnel{})\posleqof{\Bool}
                \adpa(\posAnel{}\opel,\posCnel{}'))
                \booland
                (\adpb(\posBnel{}\opel,\posDnel{})\posleqof{\Bool}
                \adpb(\posBnel{}\opel,\posDnel{}'))}
            {
                \prftree{
                    (\adpa(\posAnel{}\opel,\posCnel{})\booland \adpb(\posBnel{}\opel,\posDnel{}))
                    \posleqof{\Bool}
                    (\adpa(\posAnel{}\opel,\posCnel{}')\booland \adpb(\posBnel{}\opel,\posDnel{}'))
                }
                {(\adpa \cprod \adpb)((\posAnel{}\tupconcat \posBnel{})\opel,\posCnel{}\tupconcat \posDnel{})
                    \posleqof{\Bool}
                    (\adpa \cprod \adpb)((\posAnel{}\tupconcat \posBnel{})\opel,\posCnel{}'\tupconcat \posDnel{}')} }
            }
        }
    \end{equation*}
    Therefore,~$\adpa \cprod \adpb$ is really a design problem.
    \end{comment}
    Associativity can be shown following what we did for~$\cObj{\Set}$.
\end{proof}

\begin{lemma}[\cCat{\DP} is functorial stacking]
    \cCat{\DP} is functorial stacking.
\end{lemma}

\begin{proof}
    Consider
    \begin{equation*}
        \begin{aligned}
            \adpa\colon \posA\op \acprod \posC & \toinPos \Bool \\
            \adpb\colon \posB\op \acprod \posD & \toinPos \Bool \\
            \adpc\colon \posC\op \acprod \posE & \toinPos \Bool \\
            \adpd\colon \posD\op \acprod \posF & \toinPos \Bool
        \end{aligned}
    \end{equation*}
    We want to prove
    \begin{equation*}
        (\adpa \mthen \adpc) \mtimescatmor (\adpb \mthen \adpd)=(\adpa \mtimescatmor \adpb) \mthen (\adpc \mtimescatmor \adpd).
    \end{equation*}
    %For brevity, in the following we write
    %\begin{align*}
    %    \posAnel{} & =\tup{\posAnel{1},\ldots, \posAnel{i}}, &
    %    \posBnel{} & =\tup{\posBnel{1},\ldots, \posBnel{l}} \\
    %    \posCnel{} & =\tup{\posCnel{1},\ldots, \posCnel{m}}, &
    %    \posDnel{} & =\tup{\posDnel{1},\ldots, \posDnel{n}} \\
    %    \posEnel{} & =\tup{\posEnel{1},\ldots, \posEnel{o}}, &
    %    \posFnel{} & =\tup{\posFnel{1},\ldots, \posFnel{v}}
    %\end{align*}
    Let's start from the left-hand side.
    One has
    \begin{equation*}
        (\adpa \mthen \adpc)(\posAnel{}\opel,\posEnel{})=\bigvee_{\posCnel{}\in \posC}
        \adpa(\posAnel{}\opel, \posCnel{}) \booland \adpc(\posCnel{}\opel,\posEnel{})
    \end{equation*}
    and
    \begin{equation*}
        \begin{aligned}
            (\adpb \mthen \adpd)(\posBnel{}\opel,\posFnel{})=\bigvee_{\posDnel{}\in \posD}
            \adpb(\posBnel{}\opel, \posDnel{}) \booland \adpd(\posDnel{}\opel\posFnel{})
        \end{aligned}
    \end{equation*}
    Therefore, we know
    \begin{equation*}
        \begin{aligned}
             & ((\adpa \mthen \adpc)\mtimescatmor (\adpb \mthen \adpd))
            ((\posAnel{}\tupconcat \posBnel{})\opel,\posEnel{}\tupconcat \posFnel{}) \\
             & =\bigvee_{\posCnel{}\in \posC}
            \adpa(\posAnel{}\opel, \posCnel{}) \booland \adpc(\posCnel{}\opel,\posEnel{}) \booland
            \bigvee_{\posDnel{}\in \posD} \adpb(\posBnel{}\opel, \posDnel{}) \booland \adpd(\posDnel{}\opel,\posFnel{}).
        \end{aligned}
    \end{equation*}

    On the other hand, one has
    \begin{equation*}
        (\adpa \mtimescatmor \adpb)((\posAnel{}\tupconcat \posBnel{})\opel, \posCnel{}\tupconcat \posDnel{})
        =\adpa(\posAnel{}\opel,\posCnel{}) \booland \adpb(\posBnel{}\opel,\posDnel{})
    \end{equation*}
    and
    \begin{equation*}
        (\adpc \mtimescatmor \adpd)((\posCnel{}\tupconcat \posDnel{})\opel, \posEnel{}\tupconcat \posFnel{})
        =\adpc(\posCnel{}\opel,\posEnel{}) \booland \adpd(\posDnel{}\opel,\posFnel{})
    \end{equation*}
    Therefore, we know
    \begin{equation*}
        \begin{aligned}
             & ((\adpa \mtimescatmor \adpb)\mthen (\adpc \mtimescatmor \adpd))((\posAnel{}\tupconcat \posBnel{})\opel,\posEnel{}\tupconcat \posFnel{}) \\
             & =\bigvee_{\posCnel{}\tupconcat \posDnel{}\in \cObj{\posC,\posD}}
            (\adpa \mtimescatmor \adpb)((\posAnel{}\tupconcat \posBnel{})\opel, \posCnel{}\tupconcat \posDnel{})
            \booland (\adpc \mtimescatmor \adpd)((\posCnel{}\tupconcat \posDnel{})\opel, \posEnel{}\tupconcat \posFnel{}) \\
             & =\bigvee_{\posCnel{}\tupconcat \posDnel{}\in \cObj{\posC,\posD}}
            \adpa(\posAnel{}\opel,\posCnel{}) \booland \adpb(\posBnel{}\opel,\posDnel{})
            \booland
            \adpc(\posCnel{}\opel,\posEnel{}) \booland \adpd(\posDnel{}\opel,\posFnel{}) \\
             & =\bigvee_{\posCnel{}\in \posC}
            \adpa(\posAnel{}\opel, \posCnel{}) \booland \adpc(\posCnel{}\opel,\posEnel{}) \booland
            \bigvee_{\posDnel{}\in \posD} \adpb(\posBnel{}\opel, \posDnel{}) \booland \adpd(\posDnel{}\opel,\posFnel{}),
        \end{aligned}
    \end{equation*}
    proving the statement for any posets~$\posA,\posB,\posC,\posD,\posE,\posF$ (and hence, also for posets of tuples).

\end{proof}