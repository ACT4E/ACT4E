% !TEX root = chapter-standalone.tex

\section{The category~$\DPL$}
\begin{definition}[The category \DPL]
    The category~$\DPL$ is:
    \begin{enumerate}
        \item \emph{Objects:}
              posets of tuples.
        \item \emph{Morphisms:}
              A morphism from~$\posA =\cObj{\posA_1,\ldots, \posA_m}$ to ~$\posB = \cObj{\posB_1,\ldots, \posB_m}$ is design problem:
              \begin{equation}
                  \adp\colon \cObj{\posA\op, \posB} \toinPos \Bool.
              \end{equation}
        \item \emph{Composition:}
              Composition is the usual composition of design problems.
        \item \emph{Identities:}
              The identity morphism on an object~$\posA=\cObj{\posA_1,\ldots,\posA_n}$ is given by the identity design problem~$\catid_\posA$.
    \end{enumerate}
\end{definition}
\begin{remark}
    In other words, \DPL is the subcategory of \DP in which objects are of the form presented in \cref{eq:posetoftuples}.
\end{remark}

Analogously to what we did for~$\SetL$ and~$\PosL$, one can define a multiplication operation for~$\DPL$.
Given two design problems
\begin{equation}
    \begin{aligned}
        \adpa\colon \cObj{\posA\op, \posC} & \toinPos \Bool \\
        \adpb\colon \cObj{\posB\op, \posD} & \toinPos \Bool,
    \end{aligned}
\end{equation}
one can define
\begin{equation}
    \label{eq:dpmulti}
    \adpa \cproddp \adpb \colon \cObj{\posA\op, \posB\op,\posC,\posD}\toinPos \Bool
\end{equation}
where
\begin{equation}
    (\adpa \cproddp \adpb)  (\tup{\posAnel{}\opel,\posBnel{}\opel,\posCnel{},\posDnel{}})
    \definedas\adpa(\tup{\posAnel{}\opel,\posCnel{}})\booland
    \adpb(\tup{\posBnel{}\opel,\posDnel{}}).
\end{equation}

We now consider the stacking operation on objects we considered for~$\PosL$, and the stacking operation on morphism defined as
\begin{equation}
    \defmapcomma{\mtimescatmor}{\Mor_{\DPL} \cartprod \Mor_{\DPL}}{\mto}{\Mor_{\DPL}}{\tup{\adpa,\adpb}}{\adpa \cproddp \adpb},
\end{equation}

\begin{lemma}
    \DPL, equipped with the aforementioned stacking operations on objects and morphisms, is associative stacking.
\end{lemma}

\begin{proof}
    We show that~$\DPL$ is an associative stacking semicategory.
    We first show that it is a stacking category, by first showing that the stacking operations indeed fulfill \cref{def:simple-stacking-semi-cat}, and then showing the compatibility condition.
    The stacking operation on objects fulfills \cref{def:simple-stacking-semi-cat}, since, given two posets of tuples it returns a poset of tuples.
    To show that the stacking operation on morphism fulfills \cref{def:simple-stacking-semi-cat}, we need to show that given design problems~$\adpa,\adpb$, the morphism~$\adpa \mtimescatmor \adpb$ is a design problem.
    This is easy to show, by leveraging the fact that~$\adpa$ and~$\adpb$ are design problems.
    We know that
    \begin{equation}
        \prfcomma{\tup{\posAnel{}\opel,\posBnel{}\opel,\posCnel{},\posDnel{}} \posleqof{\cObj{\posA\op, \posB\op,\posC,\posD}} \tup{{\posAnel{}'}\opel,{\posBnel{}'}\opel,\posCnel{}',\posDnel{}'}}
        {(\posAnel{}\opel \posleqof{\posA\op} {\posAnel{}'}\opel) \booland (\posBnel{}\opel \posleqof{\posB\op} {\posBnel{}'}\opel)\booland (\posCnel{}\posleqof{\posC}\posCnel{}')\booland (\posDnel{}\posleqof{\posD}\posDnel{}')}
    \end{equation}
    and that~$\booland$ is a monotone operator.
    Therefore,~$\adpa \cproddp \adpb$ is a design problem.
    Furthermore, the two stacking operations are compatible:
    \begin{equation}
        \prfperiod{\adpa\colon \cObj{\posA\op, \posC} \toinPos \Bool}
        {\adpb\colon \cObj{\posB\op, \posD}\toinPos \Bool}
        {\adpa \cproddp \adpb \colon \cObj{\posA\op, \posB\op,\posC,\posD}\toinPos \Bool}
    \end{equation}

    \begin{comment}
    For brevity, we write~$\posAnel{}=\tup{\posAnel{1},\ldots, \posAnel{m}}$,~$\posBnel{}=\tup{\posBnel{1},\ldots, \posBnel{n}}$,~$\posCnel{}=\tup{\posCnel{1},\ldots, \posCnel{o}}$, and~$\posDnel{}=\tup{\posDnel{1},\ldots, \posDnel{t}}$.
    We have:
    \begin{equation}
        \prfperiod{
        \posAnel{}\tupconcat \posBnel{}\posleqof{\cObj{\posA_1, \ldots, \posA_m, \posB_1, \ldots, \posB_n}} \posAnel{}'\tupconcat \posBnel{}'
        }
        {\prftree{(\posAnel{} \posleqof{\cObj{\posA_1,\ldots, \posA_m}} \posAnel{}') \booland (\posBnel{} \posleqof{\cObj{\posB_1,\ldots, \posB_n}} \posBnel{}')}
        {\prftree{(\adpa(\posAnel{}\opel,\posCnel{})\posgeqof{\Bool} \adpa({\posAnel{}'}\opel,\posCnel{}))
                \booland
                (\adpb(\posBnel{}\opel,\posDnel{})\posgeqof{\Bool} \adpb({\posBnel{}'}\opel,\posDnel{}))}
            {
                \prftree{
                    (\adpa({\posAnel{}}\opel,\posCnel{})\booland \adpb(\posBnel{}\opel,\posDnel{}))
                    \posgeqof{\Bool}
                    (\adpa({\posAnel{}'}\opel,\posCnel{})\booland \adpb({\posBnel{}'}\opel,\posDnel{}))
                }
                {(\adpa \cprod \adpb)((\posAnel{}\tupconcat \posBnel{})\opel,\posCnel{}\tupconcat \posDnel{})\posgeqof{\Bool}
                    (\adpa \cprod \adpb)((\posAnel{}'\tupconcat \posBnel{}')\opel,\posCnel{}\tupconcat \posDnel{})} }
            }
        }
    \end{equation}
    For the second iteration, we have:
    \begin{equation}
        \prfperiod{
        \posCnel{}\tupconcat \posDnel{}\posleqof{\cObj{\posC_1, \ldots, \posC_o, \posD_1, \ldots, \posD_t}} \posCnel{}'\tupconcat \posDnel{}'
        }
        {\prftree{(\posCnel{} \posleqof{\cObj{\posC_1,\ldots,\posC_o}} \posCnel{}') \booland (\posDnel{}\posleqof{\cObj{\posD_1,\ldots, \posD_t}} \posDnel{}')}
        {\prftree{(\adpa(\posAnel{}\opel,\posCnel{})\posleqof{\Bool}
                \adpa(\posAnel{}\opel,\posCnel{}'))
                \booland
                (\adpb(\posBnel{}\opel,\posDnel{})\posleqof{\Bool}
                \adpb(\posBnel{}\opel,\posDnel{}'))}
            {
                \prftree{
                    (\adpa(\posAnel{}\opel,\posCnel{})\booland \adpb(\posBnel{}\opel,\posDnel{}))
                    \posleqof{\Bool}
                    (\adpa(\posAnel{}\opel,\posCnel{}')\booland \adpb(\posBnel{}\opel,\posDnel{}'))
                }
                {(\adpa \cprod \adpb)((\posAnel{}\tupconcat \posBnel{})\opel,\posCnel{}\tupconcat \posDnel{})
                    \posleqof{\Bool}
                    (\adpa \cprod \adpb)((\posAnel{}\tupconcat \posBnel{})\opel,\posCnel{}'\tupconcat \posDnel{}')} }
            }
        }
    \end{equation}
    Therefore,~$\adpa \cprod \adpb$ is really a design problem.
    \end{comment}
    Associativity can be shown following what we did for~$\cObj{\Set}$.
\end{proof}

\begin{lemma}[\DPL is functorial stacking]
    \DPL, equipped with the aforementioned stacking operations on objects and morphisms, is functorial stacking.
\end{lemma}

\begin{proof}
    Consider
    \begin{equation}
        \begin{aligned}
            \adpa\colon \cObj{\posA\op, \posC} & \toinPos \Bool \\
            \adpb\colon \cObj{\posB\op, \posD} & \toinPos \Bool \\
            \adpc\colon \cObj{\posC\op, \posE} & \toinPos \Bool \\
            \adpd\colon \cObj{\posD\op, \posF} & \toinPos \Bool
        \end{aligned}
    \end{equation}
    We want to prove that
    \begin{equation}
        (\adpa \mthen \adpc)
        \mtimescatmor (\adpb \mthen \adpd)=(\adpa \mtimescatmor \adpb) \mthen (\adpc \mtimescatmor \adpd).
    \end{equation}
    %For brevity, in the following we write
    %\begin{align*}
    %    \posAnel{} & =\tup{\posAnel{1},\ldots, \posAnel{i}}, &
    %    \posBnel{} & =\tup{\posBnel{1},\ldots, \posBnel{l}} \\
    %    \posCnel{} & =\tup{\posCnel{1},\ldots, \posCnel{m}}, &
    %    \posDnel{} & =\tup{\posDnel{1},\ldots, \posDnel{n}} \\
    %    \posEnel{} & =\tup{\posEnel{1},\ldots, \posEnel{o}}, &
    %    \posFnel{} & =\tup{\posFnel{1},\ldots, \posFnel{v}}
    %\end{align*}
    We start from the left-hand side.
    We have
    \begin{equation}
        (\adpa \mthen \adpc)(\posAnel{}\opel,\posEnel{})
        =\bigvee_{\posCnel{}\setin \posC}
        \adpa(\posAnel{}\opel, \posCnel{}) \booland \adpc(\posCnel{}\opel,\posEnel{})
    \end{equation}
    and
    \begin{equation}
        \begin{aligned}
            (\adpb \mthen \adpd)(\posBnel{}\opel,\posFnel{})
            =\bigvee_{\posDnel{}\setin \posD}
            \adpb(\posBnel{}\opel, \posDnel{}) \booland \adpd(\posDnel{}\opel\posFnel{})
        \end{aligned}
    \end{equation}
    Therefore, we know
    \begin{equation}
        \begin{aligned}
             & ((\adpa \mthen \adpc)\mtimescatmor (\adpb \mthen \adpd))
            ((\posAnel{}\tupconcat \posBnel{})\opel,\posEnel{}\tupconcat \posFnel{}) \\
             & =\bigvee_{\posCnel{}\setin \posC}
            \adpa(\posAnel{}\opel, \posCnel{}) \booland \adpc(\posCnel{}\opel,\posEnel{}) \booland
            \bigvee_{\posDnel{}\setin \posD} \adpb(\posBnel{}\opel, \posDnel{}) \booland \adpd(\posDnel{}\opel,\posFnel{}).
        \end{aligned}
    \end{equation}

    On the other hand, we have
    \begin{equation}
        (\adpa \mtimescatmor \adpb)
        ((\posAnel{}\tupconcat \posBnel{})\opel, \posCnel{}\tupconcat \posDnel{})
        =\adpa(\posAnel{}\opel,\posCnel{}) \booland \adpb(\posBnel{}\opel,\posDnel{})
    \end{equation}
    and
    \begin{equation}
        (\adpc \mtimescatmor \adpd)
        ((\posCnel{}\tupconcat \posDnel{})\opel, \posEnel{}\tupconcat \posFnel{})
        =\adpc(\posCnel{}\opel,\posEnel{}) \booland \adpd(\posDnel{}\opel,\posFnel{})
    \end{equation}
    Therefore, we know
    \begin{equation}
        \begin{aligned}
             & ((\adpa \mtimescatmor \adpb)\mthen (\adpc \mtimescatmor \adpd))((\posAnel{}\tupconcat \posBnel{})\opel,\posEnel{}\tupconcat \posFnel{}) \\
             & =\bigvee_{\posCnel{}\tupconcat \posDnel{}\setin \cObj{\posC,\posD}}
            (\adpa \mtimescatmor \adpb)((\posAnel{}\tupconcat \posBnel{})\opel, \posCnel{}\tupconcat \posDnel{})
            \booland (\adpc \mtimescatmor \adpd)((\posCnel{}\tupconcat \posDnel{})\opel, \posEnel{}\tupconcat \posFnel{}) \\
             & =\bigvee_{\posCnel{}\tupconcat \posDnel{}\setin \cObj{\posC,\posD}}
            \adpa(\posAnel{}\opel,\posCnel{}) \booland \adpb(\posBnel{}\opel,\posDnel{})
            \booland
            \adpc(\posCnel{}\opel,\posEnel{}) \booland \adpd(\posDnel{}\opel,\posFnel{}) \\
             & =\bigvee_{\posCnel{}\setin \posC}
            \adpa(\posAnel{}\opel, \posCnel{}) \booland \adpc(\posCnel{}\opel,\posEnel{}) \booland
            \bigvee_{\posDnel{}\setin \posD} \adpb(\posBnel{}\opel, \posDnel{}) \booland \adpd(\posDnel{}\opel,\posFnel{}),
        \end{aligned}
    \end{equation}
    proving the statement for any posets~$\posA,\posB,\posC,\posD,\posE,\posF$ (and hence, also for posets of tuples).

\end{proof}


\begin{example}
    After the X101 spontaneously combusted in low Earth orbit, the astronauts at Jeb's Spaceship Parts go on strike.
    They demand that the engineers take into account safety and living conditions on the future X102.
    As long as the propulsion and life support systems of the X102 do not interact, we can simply tensor the two design problems representing these systems into one, big co-design problem (\cref{fig:examplemonoidal}).
    \begin{figure}[h!]
        \centering
        \includesag{50_engine_tensor_1_2}
        \caption{Example of tensor of design problems. }
        \label{fig:examplemonoidal}
    \end{figure}
\end{example}
