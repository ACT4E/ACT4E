% !TEX root = chapter-standalone.tex

\section{Functorial stacking semicategories}
\label{sec:functorial-stacking}

\begin{marginfigure}
    \centering
    $(\mora \mtimescatmor \morb )
        \mthen (\morc \mtimescatmor \mord )$

    \vspace{3mm}
    \includesag{commuting_stacking_eff}

    $=$

    \vspace{3mm}
    \includesag{commuting_stacking_eff_bis}
    %\includegraphics[width=6.5cm]{effects8}
    \vspace{3mm}
    $(\mora \mthen \morc ) \mtimescatmor (\morb \mthen \mord )$

    \caption{Commutation of stacking and composition in a functorial stacking \SY{semicategory}. }
    \label{fig:stacking-functorial}
\end{marginfigure}

\begin{ctdefinition}[Functorial stacking semicategory]
    \label{def:functorial-stacking-semi-cat}
    A \maindef{functorial stacking semicategory} is a stacking \SY{semicategory} where the two stacking operations~$\mtimescatob$ and~$\mtimescatmor$ are the two components of a \SY{semifunctor} \begin{equation}
        \mtimescat\colon \CatC \Ctimes \CatC \to \CatC.
    \end{equation}
    Concretely, and in infix notation, this means that
    \begin{equation}
        (\mora \mthen \morc )
        \mtimescatmor (\morb \mthen \mord )
        =
        (\mora \mtimescatmor \morb )
        \mthen (\morc \mtimescatmor \mord )
    \end{equation}
    for all morphisms~$\mora, \morb, \morc$, and $\mord$ where respectively $\mora$ and $\morc$, and $\morb$ and $\mord$ are composable.
\end{ctdefinition}

%More in detail, we have that for any~$n \geq 2$, there is a semifunctor
%%
%\begin{equation}
%    \mtimescat^{(n)}\colon \underbrace {\CatC \times \CatC \times \cdots \times \CatC}_{\text{$n$ times}} \to \CatC.
%\end{equation}
%
This describes a sort of commutativity property: we can either first compose horizontally and then vertically, or vice versa, and we obtain the same morphism~(\cref{fig:stacking-functorial}).

This property is somewhat strong.
We give several examples (\SetL, \PosL, \RelL, \DPL), and then several counterexamples.

\subsection{Examples}

\begin{example}[\SetL is a functorial stacking semicategory]
    \label{ex:setfunstack}
    We want to show that~\SetL is a \SY{functorial stacking semicategory}.

    Consider four morphisms
    \begin{equation}
        \begin{aligned}
            \mora\colon \setA \mto \setB, & \quad \morc\colon \setB \mto \setC, \\
            \morb\colon \setD \mto \setE, & \quad \mord\colon \setE \mto \setF.
            \\
        \end{aligned}
    \end{equation}
    We want to show that
    \begin{equation}
        (\mora \mtimescatmor \morb )
        \mthen (\morc \mtimescatmor \mord )
        =
        (\mora \mthen \morc ) \mtimescatmor (\morb \mthen \mord ),
    \end{equation}
    We show this by showing that, for any $\setAel\tupconcat \setDel\setin \setA\cprod\setD$:
    \begin{equation}
        \begin{aligned}
            ((\mora \mtimescatmor \morb )\mthen (\morc \mtimescatmor \mord ))(\setAeln{}\tupconcat \setDeln{})
             & = (\morc \mtimescatmor \mord)(\mora(\setAeln{})\tupconcat \morb(\setDeln{})) \\
             & =\morc(\mora(\setAeln{}))\tupconcat \mord(\morb(\setDeln{})) \\
             & =(\mora \mthen \morc)(\setAeln{})\tupconcat (\morb\mthen \mord)(\setDeln{}) \\
             & =((\mora \mthen \morc ) \mtimescatmor (\morb \mthen \mord ))(\setAeln{}\tupconcat \setDeln{}).
        \end{aligned}
    \end{equation}
\end{example}

\begin{lemma}
    \PosL, equipped with the aforementioned stacking operations on objects and morphisms, is \SY{functorial stacking semicategory}.
\end{lemma}
%
\begin{proof}
    The proof is analogous to the one for \SetL in \cref{ex:setfunstack}.
\end{proof}

\begin{gradedexercise}[\exname{RelFunStack}]
    \label{ex:RelFunStack}
    Prove that the structure defined in \cref{ex:relassocstack} makes~\RelL a \SY{functorial stacking semicategory}.
\end{gradedexercise}

\solutionof{RelFunStack}

\begin{lemma}[\DPL is a functorial stacking semicategory]\label{lem:DPL-functorial-stacking}
    \DPL, equipped with the aforementioned stacking operations on objects and morphisms, is \SY{functorial stacking semicategory}.
\end{lemma}

\begin{proof}
    Consider
    \begin{equation}
        \begin{aligned}
            \adpa\colon \posAop\Ptimes \posC     & \toinPos \Bool \\
            \adpb\colon \posB\posop\Ptimes \posD & \toinPos \Bool \\
            \adpc\colon \posC\posop\Ptimes \posE & \toinPos \Bool \\
            \adpd\colon \posD\posop\Ptimes \posF & \toinPos \Bool
        \end{aligned}
    \end{equation}
    We want to prove that
    \begin{equation}
        (\adpa \dpthen \adpc)
        \mtimescatmor (\adpb \dpthen \adpd)=(\adpa \mtimescatmor \adpb) \dpthen (\adpc \mtimescatmor \adpd).
    \end{equation}
    %For brevity, in the following we write
    %\begin{align*}
    %    \posAnel{} & =\tup{\posAnel{1},\ldots, \posAnel{i}}, &
    %    \posBnel{} & =\tup{\posBnel{1},\ldots, \posBnel{l}} \\
    %    \posCnel{} & =\tup{\posCnel{1},\ldots, \posCnel{m}}, &
    %    \posDnel{} & =\tup{\posDnel{1},\ldots, \posDnel{n}} \\
    %    \posEnel{} & =\tup{\posEnel{1},\ldots, \posEnel{o}}, &
    %    \posFnel{} & =\tup{\posFnel{1},\ldots, \posFnel{v}}
    %\end{align*}
    We start from the left-hand side.
    We have
    \begin{equation}
        (\adpa \dpthen \adpc)(\posAnel{}\opel,\posEnel{})
        =\bigvee_{\posCnel{}\setin \posC}
        \adpa(\posAnel{}\opel, \posCnel{}) \booland \adpc(\posCnel{}\opel,\posEnel{})
    \end{equation}
    and
    \begin{equation}
        \begin{aligned}
            (\adpb \dpthen \adpd)(\posBnel{}\opel,\posFnel{})
            =\bigvee_{\posDnel{}\setin \posD}
            \adpb(\posBnel{}\opel, \posDnel{}) \booland \adpd(\posDnel{}\opel\posFnel{})
        \end{aligned}
    \end{equation}
    Therefore, we know
    \begin{equation}
        \begin{aligned}
             & ((\adpa \dpthen \adpc)\mtimescatmor (\adpb \dpthen \adpd))
            ((\posAnel{}\tupconcat \posBnel{})\opel,\posEnel{}\tupconcat \posFnel{}) \\
             & =\bigvee_{\posCnel{}\setin \posC}
            \adpa(\posAnel{}\opel, \posCnel{}) \booland \adpc(\posCnel{}\opel,\posEnel{}) \booland
            \bigvee_{\posDnel{}\setin \posD} \adpb(\posBnel{}\opel, \posDnel{}) \booland \adpd(\posDnel{}\opel,\posFnel{}).
        \end{aligned}
    \end{equation}

    On the other hand, we have
    \begin{equation}
        (\adpa \mtimescatmor \adpb)
        ((\posAnel{}\tupconcat \posBnel{})\opel, \posCnel{}\tupconcat \posDnel{})
        =\adpa(\posAnel{}\opel,\posCnel{}) \booland \adpb(\posBnel{}\opel,\posDnel{})
    \end{equation}
    and
    \begin{equation}
        (\adpc \mtimescatmor \adpd)
        ((\posCnel{}\tupconcat \posDnel{})\opel, \posEnel{}\tupconcat \posFnel{})
        =\adpc(\posCnel{}\opel,\posEnel{}) \booland \adpd(\posDnel{}\opel,\posFnel{})
    \end{equation}
    Therefore, we know
    \begin{equation}
        \begin{aligned}
             & ((\adpa \mtimescatmor \adpb)\dpthen (\adpc \mtimescatmor \adpd))((\posAnel{}\tupconcat \posBnel{})\opel,\posEnel{}\tupconcat \posFnel{}) \\
             & =\bigvee_{\posCnel{}\tupconcat \posDnel{}\setin \cObj{\posC,\posD}}
            (\adpa \mtimescatmor \adpb)((\posAnel{}\tupconcat \posBnel{})\opel, \posCnel{}\tupconcat \posDnel{})
            \booland (\adpc \mtimescatmor \adpd)((\posCnel{}\tupconcat \posDnel{})\opel, \posEnel{}\tupconcat \posFnel{}) \\
             & =\bigvee_{\posCnel{}\tupconcat \posDnel{}\setin \cObj{\posC,\posD}}
            \adpa(\posAnel{}\opel,\posCnel{}) \booland \adpb(\posBnel{}\opel,\posDnel{})
            \booland
            \adpc(\posCnel{}\opel,\posEnel{}) \booland \adpd(\posDnel{}\opel,\posFnel{}) \\
             & =\bigvee_{\posCnel{}\setin \posC}
            \adpa(\posAnel{}\opel, \posCnel{}) \booland \adpc(\posCnel{}\opel,\posEnel{}) \booland
            \bigvee_{\posDnel{}\setin \posD} \adpb(\posBnel{}\opel, \posDnel{}) \booland \adpd(\posDnel{}\opel,\posFnel{}),
        \end{aligned}
    \end{equation}
    proving the statement for any \SY{posets}~$\posA,\posB,\posC,\posD,\posE,\posF$ (and hence, also for \SY{posets} of tuples).

\end{proof}

\subsection{Counter-examples}

\Effects is an example of a stacking category that is not functorial.

\begin{lemma}
    \label{lem:effects-not-functorial}
    \Effects is \emph{not} a \SY{functorial stacking semicategory}.
\end{lemma}

\begin{proof}
    In general, we have
    \begin{equation}
        (\mora \mtimescatmor \morb )
        \mthen (\morc \mtimescatmor \mord )
        \neq
        (\mora \mthen \morc ) \mtimescatmor (\morb \mthen \mord ).
    \end{equation}
    This is shown graphically in \cref{fig:effects-non-functorial}.
\end{proof}

\begin{figure*}[h]
    \centering
    \hfill
    \subfloat[\label{fig:effects7}$(\mora \mtimescatmor \morb )
            \mthen (\morc \mtimescatmor \mord )$]{
        %\includegraphics[width=6.5cm]{effects7}
        \includesag{stacking_tup_counterproof}
    }
    \hfill
    \subfloat[\label{fig:effects9} $(\mora \mthen \morc ) \mtimescatmor (\morb \mthen \mord )$]{
        %\includegraphics[width=6.5cm]{effects9}
        \includesag{stacking_tup_counterproof_bis}
    }
    \hfill
    \caption{Proof that \Effects is not a \SY{functorial stacking} category by showing that
        the two morphisms above have different representations in~\SetL.}
    \label{fig:effects-non-functorial}
\end{figure*}

\todotextjira{751}{\alphubel  @GZ: There is a typo in the above diagrams -- U and Z are switched from where they should be placed.
    Also, the right hand diagram should have *two* boxes with dotted lines, not just one.
}

% \begin{comment}
% \devel{
%
%     \begin{equation}
%         \begin{aligned}
%             \mora\colon \cObj{\setAn{1}, \ldots,\setAn{m}} & \mto \cObj{\setBn{1}, \ldots, \setBn{n}}, \\
%             \morb\colon \cObj{\setDn{1}, \ldots,\setDn{o}} & \mto \cObj{\setEn{1}, \ldots, \setEn{p}}, \\
%             \morc\colon \cObj{\setBn{1}, \ldots,\setBn{n}} & \mto \cObj{\setCn{1}, \ldots, \setCn{q}}, \\
%             \mord\colon \cObj{\setEn{1}, \ldots,\setEn{p}} & \mto \cObj{\setFn{1}, \ldots, \\setFn{r}},
%         \end{aligned}
%     \end{equation}
%     to which maps~$\mape,\mapf,\mapg,\maph$ are associated.
%
%     We want to show that
%     \begin{equation}
%         (\mora \mtimescat \morb )
%         \mthen (\morc \mtimescat \mord )
%         =
%         (\mora \mthen \morc ) \mtimescat (\morb \mthen \mord ),
%     \end{equation}
%     and we do it by showing that the map associated with the left-hand side of the equation corresponds to the one on the right-hand side.
%     We know the maps associated to~$(\mora \mtimescat \morb )$ and~$(\morc \mtimescat \mord )$, which are
%     \begin{equation}
%         \cohm_{\setA,\setD}\then (\mape \funcprod \mapg)\then \cohm_{\setB,\setE},
%     \end{equation}
%     and
%     \begin{equation}
%         \cohm_{\setB,\setE}\then (\mapf \funcprod \maph)\then \cohm_{\setC,\setF},
%     \end{equation}
%     respectively.
%     The map associated to~$(\mora \mtimescat \morb )
%         \mthen (\morc \mtimescat \mord )$ is therefore
%     \begin{equation}
%         \label{eq:setL_functorial_a}
%         \cohm_{\setA,\setD}\then (\mape \funcprod \mapg)\then \cohm_{\setB,\setE}\then \cohm_{\setB,\setE}\then (\mapf \funcprod \maph)\then \cohm_{\setC,\setF}.
%     \end{equation}
%     On the other hand, the map associated to~$(\mora \mthen \morc )$ is~$\mape\then \mapf$, and the map associated to~$(\morb \mthen \mord)$ is~$\mapg\then \maph$.
%     Therefore, the map associated to~$(\mora \mthen \morc ) \mtimescat (\morb \mthen \mord )$ is
%     \begin{equation}
%         \cohm_{\setA,\setD}\then ((\mape\then \mapf)\funcprod (\mapg\then \maph))\then \cohm_{\setC,\setD}
%     \end{equation}
%
%     \todotext{Now need to finish by showing equivalence of maps}
% }
% \end{comment}

\begin{example}
    We want to show that \Moore, equipped with the defined stacking operations, is almost a \SY{functorial stacking semicategory},
    but not quite.
    Consider four Moore machines:
    \begin{equation*}
        \mora\colon \prin_\mora \mto \prout_\mora,\quad \morb\colon \prin_\morb \mto \prout_\morb, \quad \morc\colon \prout_\mora \mto \prout_\morc,\quad \mord\colon \prout_\morb \mto \prout_\mord.
    \end{equation*}
    We want to check if the equation
    \begin{equation*}
        (\mora \mthen \morc)
        \mtimescatmor (\morb\mthen \mord)=(\mora\mtimescatmor \morb)\mthen (\morc\mtimescatmor \mord)
    \end{equation*}
    holds.
    Let's start from the left-hand side.
    First, we have:
    \begin{equation*}
        \begin{aligned}
            \mora \mthen \morc & =\tup{\prin_\mora, \prst_\mora \cprod \prst_\morc, \prout_\morc, \prdyn_{\mora\mthen \morc},\prreadout_{\mora\mthen \morc}, \prstart_\mora\tupconcat \prstart_\morc}, \\
            \morb \mthen \mord & =\tup{\prin_\morb, \prst_\morb \cprod \prst_\mord, \prout_\mord, \prdyn_{\morb\mthen \mord},\prreadout_{\morb\mthen \mord}, \prstart_\morb\tupconcat \prstart_\mord},
        \end{aligned}
    \end{equation*}
    with
    \begin{equation*}
        \defmapcomma{\prdyn_{\mora\mthen \morc}}
        {\prin_\mora\cprod \prst_\mora \cprod \prst_\morc}
        {\sto}
        {\prst_\mora \cprod \prst_\morc}
        {\prinel_\mora\tupconcat \prstel_\mora \tupconcat \prstel_\morc}
        {\prdyn_\mora(\prinel_\mora \tupconcat \prstel_\mora)\tupconcat \prdyn_\morc(\prreadout_\mora(\prstel_\mora)\tupconcat \prstel_\morc)}
    \end{equation*}
    %
    \begin{equation*}
        \defmapcomma{\prdyn_{\morb\mthen \mord}}
        {\prin_\morb\cprod \prst_\morb \cprod \prst_\mord}
        {\sto}
        {\prst_\morb \cprod \prst_\mord}
        {\prinel_\morb\tupconcat \prstel_\morb \tupconcat \prstel_\mord}
        {\prdyn_\morb(\prinel_\morb \tupconcat \prstel_\morb)\tupconcat \prdyn_\mord(\prreadout_\morb(\prstel_\morb)\tupconcat \prstel_\mord)}
    \end{equation*}
    %
    \begin{equation*}
        \defmapcomma{\prreadout_{\mora\mthen \morc}}
        {\prst_\mora \cprod \prst_\morc}
        {\sto}
        {\prout_\morc}
        {\prstel_\mora \tupconcat \prstel_\morc}
        {\prreadout_\morc(\prstel_\morc)}
    \end{equation*}
    and
    \begin{equation*}
        \defmapperiod{\prreadout_{\morb\mthen \mord}}
        {\prst_\morb \cprod \prst_\mord}
        {\sto}
        {\prout_\mord}
        {\prstel_\morb \tupconcat \prstel_\mord}
        {\prreadout_\mord(\prstel_\mord)}
    \end{equation*}

    Furthermore:
    \begin{widepar}
        \begin{equation*}
            (\mora \mthen \morc)\mtimescatmor (\morb \mthen \mord)=\tup{\prin_\mora\cprod \prin_\morb, \prst_\mora \cprod \prst_\morc\cprod \prst_\morb \cprod \prst_\mord, \prout_\morc\cprod \prout_\mord,
                \prdyn_{(\mora\mthen \morc)\mtimescatmor(\morb\mthen \mord)}, \prreadout_{(\mora\mthen \morc)\mtimescatmor(\morb\mthen \mord)}, \prstart_\mora\tupconcat \prstart_\morc\tupconcat \prstart_\morb\tupconcat \prstart_\mord},
        \end{equation*}
    \end{widepar}
    with
    \begin{widepar}
        \begin{equation*}
            \defmapcomma{\prdyn_{(\mora\mthen \morc)\mtimescatmor(\morb\mthen \mord)}}
            {\prin_\mora\cprod \prin_\morb\cprod \prst_\mora \cprod \prst_\morc\cprod \prst_\morb \cprod \prst_\mord}
            {\sto}
            {\prst_\morc\cprod \prst_\morb \cprod \prst_\mord}
            {\prinel_\mora\tupconcat \prinel_\morb \tupconcat \prstel_\mora \tupconcat \prstel_\morc \tupconcat \prstel_\morb \tupconcat \prstel_\mord}
            {\underbrace{\prdyn_{\mora\mthen \morc}(\prinel_\mora\tupconcat \prstel_\mora \tupconcat \prstel_\morc)\tupconcat \prdyn_{\morb\mthen \mord}(\prinel_\morb\tupconcat \prstel_\morb \tupconcat \prstel_\mord)}_{(1)}}
        \end{equation*}
    \end{widepar}
    where
    \begin{equation*}
        (1)=\prdyn_\mora(\prinel_\mora \tupconcat \prstel_\mora)\tupconcat \prdyn_\morc(\prreadout_\mora(\prstel_\mora)\tupconcat \prstel_\morc) \tupconcat
        \prdyn_\morb(\prinel_\morb \tupconcat \prstel_\morb)\tupconcat \prdyn_\mord(\prreadout_\morb(\prstel_\morb)\tupconcat \prstel_\mord),
    \end{equation*}
    and
    \begin{equation*}
        \defmapcomma{\prreadout_{(\mora\mthen \morc)\mtimescatmor(\morb\mthen \mord)}}
        {\prst_\mora \cprod \prst_\morc\cprod \prst_\morb \cprod \prst_\mord}
        {\sto}
        {\prout_\morc\cprod \prout_\mord}
        {\prstel_\mora \tupconcat \prstel_\morc \tupconcat \prstel_\morb \tupconcat \prstel_\mord}
        {\underbrace{\prreadout_{\mora\mthen \morc}(\prstel_\mora \tupconcat \prstel_\morc)\tupconcat \prreadout_{\morb\mthen \mord}(\prstel_\morb \tupconcat \prstel_\mord)}_{(2)}}
    \end{equation*}
    where
    \begin{equation*}
        (2)=\prreadout_\morc(\prstel_\morc)\tupconcat \prreadout_\mord(\prstel_\mord).
    \end{equation*}
    On the other hand, we have:
    \begin{equation*}
        \begin{aligned}
            \mora \mtimescatmor \morb & =\tup{\prin_\mora \cprod \prin_\morb, \prst_\mora \cprod \prst_\morb, \prout_\mora \cprod \prout_\morb, \prdyn_{\mora\mtimescatmor \morb},\prreadout_{\mora\mtimescatmor \morb}, \prstart_\mora\tupconcat \prstart_\morb}, \\
            \morc \mtimescatmor \mord & =\tup{\prin_\morc \cprod \prin_\mord, \prst_\morc \cprod \prst_\mord, \prout_\morc \cprod \prout_\mord, \prdyn_{\morc\mtimescatmor \mord},\prreadout_{\morc\mtimescatmor \mord}, \prstart_\morc\tupconcat \prstart_\mord},
        \end{aligned}
    \end{equation*}
    with
    \begin{equation*}
        \defmapcomma{\prdyn_{\mora \mtimescatmor \morb}}{\prin_\mora \cprod \prin_\morb \cprod \prst_\mora \cprod \prst_\morb}
        {\sto}{\prst_\mora \cprod \prst_\morb}
        {\prinel_\mora \tupconcat \prinel_\morb \tupconcat \prstel_\mora \tupconcat \prstel_\morb}
        {\prdyn_\mora(\prinel_\mora \tupconcat \prstel_\mora)\tupconcat \prdyn_\morb(\prinel_\morb \tupconcat \prstel_\morb)}
    \end{equation*}
    %
    \begin{equation*}
        \defmapcomma{\prdyn_{\morc \mtimescatmor \mord}}{\prin_\morc \cprod \prin_\mord \cprod \prst_\morc \cprod \prst_\mord}
        {\sto}{\prst_\morc \cprod \prst_\mord}
        {\prinel_\morc \tupconcat \prinel_\mord \tupconcat \prstel_\morc \tupconcat \prstel_\mord}
        {\prdyn_\morc(\prinel_\morc \tupconcat \prstel_\morc)\tupconcat \prdyn_\mord(\prinel_\mord \tupconcat \prstel_\mord)}
    \end{equation*}
    %
    \begin{equation*}
        \defmapcomma{\prreadout_{\mora \mtimescatmor \morb}}
        {\prst_\mora \cprod \prst_\morb}{\sto}{\prout_\mora \cprod \prout_\morb}
        {\prstel_\mora \tupconcat \prstel_\morb}{\prreadout_\mora(\prstel_\mora)\tupconcat \prreadout_\morb(\prstel_\morb)}
    \end{equation*}
    and
    \begin{equation*}
        \defmapperiod{\prreadout_{\morc \mtimescatmor \mord}}
        {\prst_\morc \cprod \prst_\mord}{\sto}{\prout_\morc \cprod \prout_\mord}
        {\prstel_\morc \tupconcat \prstel_\mord}{\prreadout_\morc(\prstel_\morc)\tupconcat \prreadout_\mord(\prstel_\mord)}
    \end{equation*}

    Furthermore:
    \begin{widepar}
        \begin{equation*}
            (\mora \mtimescatmor \morb)\mthen (\morc \mtimescatmor \mord)=\tup{\prin_\mora\cprod \prin_\morb, \prst_\mora \cprod \prst_\morb\cprod \prst_\morc \cprod \prst_\mord, \prout_\morc\cprod \prout_\mord,
                \prdyn_{(\mora\mtimescatmor \morb)\mtimescatmor(\morc\mtimescatmor \mord)}, \prreadout_{(\mora\mtimescatmor \morb)\mthen(\morc\mtimescatmor \mord)}, \prstart_\mora\tupconcat \prstart_\morb\tupconcat \prstart_\morc\tupconcat \prstart_\mord},
        \end{equation*}
    \end{widepar}
    with
    \begin{widepar}
        \begin{equation*}
            \defmapcomma{\prdyn_{(\mora\mtimescatmor \morb)\mthen(\morc\mtimescatmor \mord)}}
            {\prin_\mora\cprod \prin_\morb\cprod \prst_\mora \cprod \prst_\morb\cprod \prst_\morc \cprod \prst_\mord}
            {\sto}
            {\prst_\mora \cprod \prst_\morb\cprod \prst_\morc \cprod \prst_\mord}
            {\prinel_\mora \tupconcat \prinel_\morb\tupconcat \prstel_\mora \tupconcat \prstel_\morb \tupconcat \prstel_\morc \tupconcat \prstel_\mord}
            {\underbrace{\prdyn_{\mora \mtimescatmor \morb}(\prinel_\mora \tupconcat \prinel_\morb \tupconcat \prstel_\mora \tupconcat \prstel_\morb)
                    \tupconcat \prdyn_{\morc\mtimescatmor \mord}(\prreadout_{\mora \mtimescatmor\morb}(\prstel_\mora \tupconcat \prstel_\morb)\tupconcat \prstel_\morc \tupconcat \prstel_\mord)}_{(3)}}
        \end{equation*}
    \end{widepar}
    with
    \begin{widepar}
        \begin{equation*}
            \begin{aligned}
                (3) & =\prdyn_\mora(\prinel_\mora \tupconcat \prstel_\mora)\tupconcat \prdyn_\morb(\prinel_\morb \tupconcat \prstel_\morb)
                \tupconcat \prdyn_{\morc\mtimescatmor \mord}(\prreadout_\mora(\prstel_\mora)\tupconcat \prreadout_\morb(\prstel_\morb)\tupconcat \prstel_\morc \tupconcat \prstel_\mord) \\
                    & =\prdyn_\mora(\prinel_\mora \tupconcat \prstel_\mora)\tupconcat \underbrace{\prdyn_\morb(\prinel_\morb \tupconcat \prstel_\morb)}_{(*)}
                \tupconcat \underbrace{\prdyn_{\morc}(\prreadout_\mora(\prstel_\mora)\tupconcat \prstel_\morc)}_{(**)}\tupconcat \prdyn_\mord(\prreadout_\morb(\prstel_\morb)\tupconcat \prstel_\mord)
            \end{aligned}
        \end{equation*}
    \end{widepar}
    and
    \begin{equation*}
        \defmapcomma{\prreadout_{(\mora\mtimescatmor \morb)\mthen(\morc\mtimescatmor \mord)}}
        {\prst_\mora \cprod \prst_\morb\cprod \prst_\morc \cprod \prst_\mord}
        {\sto}
        {\prout_\morc\cprod \prout_\mord}
        {\prstel_\mora \tupconcat \prstel_\morb \tupconcat \prstel_\morc \tupconcat \prstel_\mord}
        {\prreadout_{\morc\mtimescatmor \mord}(\prstel_\morc \tupconcat \prstel_\mord)=\prreadout_\morc(\prstel_\morc)\tupconcat \prreadout_\mord(\prstel_\mord)}
    \end{equation*}
    As one can see from the expression for (3), the two terms ($*$) and ($**$) are switched compared to (1).
    Apart from this switch (and the corresponding switch in the signatures of the dynamics maps), we can see that there is a moral correspondence between the Moore machines in the functorial stacking axiom.

\end{example}

\begin{example}
    We want to show that \LTI, equipped with the defined stacking operations, is almost a \SY{functorial stacking semicategory}, but not quite.
    Given morphisms~$\mora\colon \styleobj{l}\mto \styleobj{m}$,~$\morc\colon \styleobj{m}\mto \styleobj{n}$,~$\morb\colon \styleobj{o}\mto \styleobj{p}$,~$\mord\colon \styleobj{p}\mto \styleobj{q}$, we would need to have
    \begin{equation*}
        (\mora \mthen \morc)
        \mtimescatmor (\morb\mthen \mord)=(\mora\mtimescatmor \morb)\mthen (\morc\mtimescatmor \mord).
    \end{equation*}
    This, however, is not true.
    Let's see this by looking at the first matrix component of the LTI system.
    On one hand we have:
    \begin{equation}\label{eq:checking-LTI-functorial-stacking-1}
        \mat{A}_{(\mora \mthen \morc)\mtimescatmor (\morb\mthen \mord)}=
        \begin{bmatrix}
            \mat{A}_\mora              & \mat{0}       & \mat{0}                    & \mat{0}       \\
            \mat{B}_\morc\mat{C}_\mora & \mat{A}_\morc & \mat{0}                    & \mat{0}       \\
            \mat{0}                    & \mat{0}       & \mat{A}_\morb              & \mat{0}       \\
            \mat{0}                    & \mat{0}       & \mat{B}_\mord\mat{C}_\morb & \mat{A}_\mord
        \end{bmatrix}.
    \end{equation}
    On the other hand we have:
    \begin{equation}\label{eq:checking-LTI-functorial-stacking-2}
        \mat{A}_{(\mora\mtimescatmor \morb)\mthen (\morc\mtimescatmor \mord)}=
        \begin{bmatrix}
            \mat{A}_\mora               & \mat{0}                     & \mat{0}       & \mat{0}       \\
            \mat{0}                     & \mat{A}_\morb               & \mat{0}       & \mat{0}       \\
            \mat{B}_\morc \mat{C}_\mora & \mat{0}                     & \mat{A}_\morc & \mat{0}       \\
            \mat{0}                     & \mat{B}_\mord \mat{C}_\morb & \mat{0}       & \mat{A}_\mord
        \end{bmatrix}.
    \end{equation}
    These two are different, and will therefore describe different systems.
    However, the two matrices just differ by two permutations, which can be expressed via an invertible linear transformation~$\mat{T}$ as follows:
    \begin{equation}\label{eq:checking-LTI-functorial-stacking-3}
        \mat{A}_{(\mora\mtimescatmor \morb)\mthen (\morc\mtimescatmor \mord)}=
        \underbrace{\begin{bmatrix}
                1 & 0 & 0 & 0 \\
                0 & 0 & 1 & 0 \\
                0 & 1 & 0 & 0 \\
                0 & 0 & 0 & 1
            \end{bmatrix}}_{\mat{T}}\cdot
        \mat{A}_{(\mora \mthen \morc)\mtimescatmor (\morb\mthen \mord)}
        \cdot
        \begin{bmatrix}
            1 & 0 & 0 & 0 \\
            0 & 0 & 1 & 0 \\
            0 & 1 & 0 & 0 \\
            0 & 0 & 0 & 1
        \end{bmatrix}.
    \end{equation}
    It turns out that $(\mora \mthen \morc)\mtimescatmor (\morb\mthen \mord)$ and~$(\mora\mtimescatmor \morb)\mthen (\morc\mtimescatmor \mord)$ are equivalent systems (\cref{def:equivalence_lti}), even though they are not equal.
    In particular, although \LTI is not a \SY{functorial stacking semicategory}, by \cref{lem:equivsystequivact}~$(\mora \mthen \morc)\mtimescatmor (\morb\mthen \mord)$ and~$(\mora\mtimescatmor \morb)\mthen (\morc\mtimescatmor \mord)$ have the same action, and hence \LTI is, in one sense, ``morally'' functorial.
\end{example}

\section{Functorial stacking categories}

\begin{ctdefinition}[Functorial stacking category]
    \label{def:functorial-stacking-cat}
    A \maindef{functorial stacking category} is a stacking \SY{category} where the two stacking operations~$\mtimescatob$ and~$\mtimescatmor$ are the two components of a \SY{functor} \begin{equation}
        \mtimescat\colon \CatC \Ctimes \CatC \to \CatC.
    \end{equation}
    In infix notation, this means that, in addition to the equation
    \begin{equation}
        (\mora \mthen \morc )
        \mtimescatmor (\morb \mthen \mord )
        =
        (\mora \mtimescatmor \morb )
        \mthen (\morc \mtimescatmor \mord )
    \end{equation}
    it is now also the case that $\mtimescat$ is compatible with identity morphisms:
    \begin{equation}\label{eq:functorial-stacking-condition}
        \catidat{\Obja} \mtimescatmor \catidat{\Objb} = \catidat{\Obja \mtimescatob \Objb}
    \end{equation}
    for all objects $\Obja$, $\Objb$ of $\CatC$.
\end{ctdefinition}

\begin{remark}
    Note that a functorial stacking category is \emph{not} the same thing as a functorial stacking semicategory where the semicategory in question happens to be a category.
\end{remark}

\todotext{What is a simple counterexample?}

\subsection{Examples}

This remark implies that having proved that \SetL, \PosL, \RelL, \DPL are functorial stacking \emph{semicategories}, we need to make an additional step to prove that they are also functorial stacking \emph{categories}.

\begin{exercise}[The usual suspects are functorial stacking categories]
    \label{ex:the-usual-suspects-are-functorial-stacking-categories}
    Prove that \SetL, \PosL, \RelL, \DPL are functorial stacking categories.
    Hint: You have to define the functor $\mtimescat$ and check that it satisfies the two equations in \cref{def:functorial-stacking-cat}.
\end{exercise}
\begin{solution}
    \todotext{Solution for \cref{ex:the-usual-suspects-are-functorial-stacking-categories}}
\end{solution}
