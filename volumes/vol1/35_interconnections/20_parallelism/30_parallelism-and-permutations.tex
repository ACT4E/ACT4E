% !TEX root = chapter-standalone.tex

\section{Parallelism and permutations}
\label{sec:parallelism-and-permutations}

\todotext{J: @J: write some brief intro words here}

\subsection{A strict monoidal category of permutations}

Recall that a \emph{permutation} of order $n \in \natnumbers$ is a bijective function from the set $\makeset{1,2, \dots , n}$ to itself.
For fixed $n \in \natnumbers$, the set of permutations of order $n$ has a group structure, where the composition operation is composition of functions.
We call this group $\Perms(n)$.
For the special case of $n = 0$, we interpret $\Perms(0)$ as containing the unique function from the empty set $\emptyset$ to itself; this function is bijective.

There are several typical notations for indicating permutations.
We will use the following one, and illustrate it by example.
If, for instance, $\permmap \in \Perms(3)$ is the permutation
\begin{align*}
    \makeset{1,2,3} & \to \makeset{1,2,3} \\
    1               & \mapsto 2 \\
    2               & \mapsto 3 \\
    3               & \mapsto 1
\end{align*}
then we indicate this by writing $\permmap = (3, 1, 2)$.
The way we think of this notation is that we start with $(1, 2, 3)$ and then apply $\permmap$ to each entry.
In other words, in general, our notation for some $\permmap \in \Perms(n)$ is $(\permmap(1), \dots, \permmap(n))$.

To help us talk about permuting inputs and output of morphisms in stacking semicategories, we make the following definitions.

\begin{definition}[Permutation category]\label{def:Permcat}
    The \emph{permutation category} $\Permcat$ is
    \begin{enumerate}
        \item \emph{Objects}: the natural numbers $\natnumbers$;
        \item \emph{Morphisms}: permutations in $\Perms(n)$, for all $n \in \natnumbers$.
        \item \emph{Composition}: composition of permutations;
        \item \emph{Identities}: identity functions (which are permutations). We will denote the identity permutation in $\Perms(n)$ by $1_n$. 
    \end{enumerate}
\end{definition}

\begin{definition}\label{def:Permcat-1}
    For any two objects $n, m \in \natnumbers$ of $\Permcat$, let
    \begin{equation}
        n \mtimescatob m \definedas n + m,
    \end{equation}
    and for any two morphisms $\permmap = (\permmap(1), \dots, \permmap(n))$, $\pi = (\pi(1), \dots, \pi(m))$ of $\Permcat$, let
    \begin{equation}
        \permmap \mtimescatmor \pi \definedas (\permmap(1), \dots, \permmap(n), \pi(1) + n, \dots, \pi(m) + n).
    \end{equation}
\end{definition}

\begin{lemma}
    The operations $\mtimescatob$ and $\mtimescatmor$ make $\Permcat$ into a functorial stacking category $\tup{\Permcat, \mtimescat}$.
\end{lemma}

\todotext{\alphubel: prove the lemma as the solution to a graded exercise}

\begin{lemma}
    $\tup{\Permcat, \mtimescat}$ is a strict monoidal category, with unit $\idmoncat$ given by $0 \in \natnumbers$.
\end{lemma}

\todotext{\alphubel: prove the lemma}


\subsection{Block permutations}

We will also need to describe permutations that permute ``blocks'' of elements of $\makeset{1, \dots, n}$. Suppose we are given natural numbers $k_1, \dots, k_r$ such that $k_1 + \dots + k_r = n$. We call this a partition of $n$ and we think of it as partitioning the set $\makeset{1, \dots, n}$ into blocks of size $k_j$, $1 \leq j \leq r$.

Given a permutation $\sigma \in  \Perms(r)$, there is a way to turn it into a \emph{block permutation} $\sigma_*(k_1, \dots, k_r) \in \Perms(r)$. 


We'll start with an example, then give a general formula. Suppose $n = 5$, $r=2$, and $k_1 = 3$ and $k_2 = 2$. Let $\sigma = (2, 1) \in \Perms(2)$. Then 
$$
\sigma_*(k_1, k_2) = \sigma_*(3,2) = (4,5,1,2,3) \in \Perms(5). 
$$
What is happening is that we start with $(1,2,3,4,5)$, we split it into the blocks $((1,2,3),(4,5))$ of length $3$ and $2$ respectively, we apply $\sigma$ to the blocks to get $((4,5),(1,2,3))$, and then we forget the subdivision into blocks, obtaining $(4,5,1,2,3)$. 

The general formula to compute $\sigma_*(k_1,\dots, k_r)$ is that, for each $j = 1, \dots, r$, in the sequence $(\sigma(1), \dots, \sigma(r))$ we replace $\sigma(j)$ with the sequence
$$
k_1 + \dots + k_{j-1} + 1, \quad k_1 + \dots + k_{j-1} + 2, \quad \dots, \quad k_1 + \dots + k_{j-1} + k_j.
$$

\subsection{Permuting wires}


Let~\CatC be an \SY{associative stacking} semicategory, and consider morphisms
\begin{equation}
    \mora \mtimescatmor \morb \colon \Obja \mtimescatob \Objb \mto \Objc \mtimescatob \Objd
\end{equation}
and
\begin{equation}
    \morc \mtimescatmor \mord \colon \Objd \mtimescatob \Objc \mto \Objf \mtimescatob \Obje.
\end{equation}
If~$\Objc \mtimescatob \Objd \neq \Objd \mtimescatob \Objc$, then the morphisms~$\mora \mtimescatmor \morb$ and~$\morc \mtimescatmor \mord$ are, in our model, technically not composable.
However, in some examples, we will in fact want to be able to compose such morphisms, because in those cases~$\Objc \mtimescatob \Objd$ and~$\Objd \mtimescatob \Objc$ are essentially equal, even if they aren't equal on the nose.

For example,~$\mora, \morb, \morc, \mord$ might be systems, represented graphically by boxes with wires for input and output.
The stacked system~$\mora \mtimescatmor \morb$ will have output wires for~$\Objc$ and $\Objd$, and the stacked system~$\morc \mtimescatmor \mord$ will have input wires for~$\Objd$ and~$\Objc$.
In some applications we are often indeed able to connect the one output wire labeled with~$\Objc$ to the input wire also labeled with~$\Objc$, and similarly for~$\Objd$.

To model this for stacking \SY{semicategories}, we introduce operations that correspond to crossing (or permuting) wires, both on the input and output sides of a morphism. For instance, if $\mora$ is a morphism that can be written as having the type
\begin{equation}\label{eq:wire-permutation-exa-1}
\mora \colon \Objan{1} \mtimescatob \Objan{2}  \mtimescatob \Objan{3} \mto \Objbn{1} \mtimescatob \Objbn{2}
\end{equation}
then we want to be able to use any permutation $\sigma \in \Perms(3)$ as a recipe to permute the input wires of $\mora$. Specifically, given for example $\sigma = (3, 1, 2) \in \Perms(3)$, we want a corresponding function 
\begin{equation}
\sourceperm{\sigma} \colon \HomSet{\CatC}{ \Objan{1} \mtimescatob \Objan{2} \mtimescatob \Objan{3}}{\Objbn{1} \mtimescatob \Objbn{2}} \to \HomSet{\CatC}{\Objan{3} \mtimescatob \Objan{1} \mtimescatob \Objan{2}}{\Objbn{1} \mtimescatob \Objbn{2}}
\end{equation}
which maps any morphism $\mora$ of the type \cref{eq:wire-permutation-exa-1} to a morphism that corresponds to $\mora$ with the its input wires permuted according to $\sigma$. 

One subtlety here is that, for instance, the representation of the source object of the morphism \cref{eq:wire-permutation-exa-1} as a three-fold stacking is not unique. For example, it could be the case that there exist objects $\Objcn{1}$ and $\Objcn{2}$ such that 
\begin{equation}\label{eq:wire-permutation-exa-two-different-reps-1}
\Objan{1} \mtimescatob \Objan{2}  \mtimescatob \Objan{3} = \Objcn{1} \mtimescatob \Objcn{2}. 
\end{equation}
In this case, $\mora$ can also be viewed as having the type
\begin{equation}
\mora \colon \Objcn{1} \mtimescatob \Objcn{2} \mto \Objbn{1} \mtimescatob \Objbn{2}, 
\end{equation}
and in this representation, it is no longer appropriate to permute the inputs of $\mora$ using a permutation in $\Perms(3)$ but rather one in $\Perms(2)$. 

Thus the representation of a morphism as a box with some number of input wires and some number of output wires is just one of potentially many different representations of the very same morphism and the application of a permutation to a morphism is always relative to a specific representation. 

One special case of situations like the one indicated in \cref{eq:wire-permutation-exa-two-different-reps-1} is when we use parentheses to group together an $n$-fold stacking of objects into ``blocks'' of size $k_1, \dots, k_r$. For example, given a stacking of objects
\begin{equation}\label{eq:wire-permutation-exa-two-different-reps-2}
\Objan{1} \mtimescatob \Objan{2}  \mtimescatob \Objan{3} \mtimescatob \Objan{4} \mtimescatob \Objan{5}
\end{equation}
we can use parentheses, as below, to think of \cref{eq:wire-permutation-exa-two-different-reps-1} as a stacking of just \emph{two} objects:
\begin{equation}\label{eq:wire-permutation-exa-two-different-reps-3}
(\Objan{1} \mtimescatob \Objan{2}  \mtimescatob \Objan{3}) \mtimescatob (\Objan{4} \mtimescatob \Objan{5}).
\end{equation}
In other words, there are objects $\Objcn{1} = \Objan{1} \mtimescatob \Objan{2}  \mtimescatob \Objan{3}$ and $\Objcn{2} = \Objan{4} \mtimescatob \Objan{5}$ such that 
\begin{equation}
\Objan{1} \mtimescatob \Objan{2}  \mtimescatob \Objan{3} \mtimescatob \Objan{4} \mtimescatob \Objan{5} = \Objcn{1} \mtimescatob \Objcn{2}. 
\end{equation}

\section{Symmetric stacking semicategories}
\label{sec:symmetric-stacking-semicategories}


\begin{marginfigure}
    \centering
    \includesag{parallelism_symmetric-stacking-source-perm}
    %\includegraphics[scale=0.1]{parallelism_symmetric-stacking-source-perm}
    \caption{A diagram for a source permutation map.}
    \label{fig:symmetric-stacking-left-perm}
\end{marginfigure}

\begin{marginfigure}
    \centering
    \includesag{parallelism_symmetric-stacking-target-perm}
    %\includegraphics[scale=0.1]{parallelism_symmetric-stacking-target-perm}
    \caption{A diagram for a target permutation map.}
\end{marginfigure}

\begin{marginfigure}
    \centering
    \includesag{parallelism_symmetric-stacking-source-perm-evaluated}
    %\includegraphics[scale=0.1]{parallelism_symmetric-stacking-source-perm-evaluated}
    \caption{A source permutation applied to a morphism $\mora \colon \Obja \mto \Objb$ whose source has a factorization $\Obja = \Objan{1} \mtimescatob \Objan{2}  \mtimescatob \Objan{3}$ and whose target has a factorization $\Objb = \Objbn{1} \mtimescatob \Objbn{2}  \mtimescatob \Objbn{3}$.}
    \label{fig:symmetric-stacking-left-perm-evaluated}
\end{marginfigure}

\begin{marginfigure}
    \centering
    \includesag{parallelism_symmetric-stacking-target-perm-evaluated}
    %\includegraphics[scale=0.1]{parallelism_symmetric-stacking-target-perm-evaluated}
    \caption{The target permutation using the same permutation as in \cref{fig:symmetric-stacking-left-perm} and applied to the same morphism.}
    \label{fig:symmetric-stacking-target-perm}
\end{marginfigure}

\begin{ctdefinition}[Symmetric stacking semicategory]
    \label{def:symmetric-stacking-category}
    A \maindef{symmetric stacking semicategory} is an \SY{associative stacking} \SY{semicategory}~\CatC with:

    \constit

    \begin{itemize}
        \item Functions
              \begin{equation}
                  \sourceperm{\permmap} \colon \HomSet{\CatC}{\mtimescatob_{i=1}^n \Objan{i}}{\Objb} \to \HomSet{\CatC}{\mtimescatob_{i=1}^n \Obja_{\permmap^{-1}(i)}}{\Objb}
              \end{equation}
              and
              \begin{equation}
                  \targetperm{\permmap} \colon \HomSet{\CatC}{\Obja}{\mtimescatob_{i=1}^n \Objbn{i}} \to \HomSet{\CatC}{\Obja}{\mtimescatob_{i=1}^n \Objb_{\permmap(i)}}
              \end{equation}
              for every~$\permmap \setin \Perms(n)$,~$n \geq 1$.
              We call these functions \emph{source permutations} and \emph{target permutations}, respectively.
    \end{itemize}

    \condit

    \begin{itemize}

      

        \item \emph{Compatibility with permutation composition:}

              The equations
              \begin{equation}
                  \label{eq:perm-compatibility-with-perm-comp}
                  \sourceperm{\permmap} \mthen \sourceperm{\pi} = \sourceperm{(\pi\mthen\permmap)}
                  \quad \text{ and } \quad
                  \targetperm{\permmap} \mthen \targetperm{\pi} = \targetperm{(\permmap \mthen \pi)}
              \end{equation}
              hold for all~$\permmap, \pi \setin \Perms(n)$,~$n \geq 2$.
              
        \item \emph{Compatibility with permutation identities:}

              For any $n \in \natnumbers$, if $\permmap = 1_n$ is the identity permutation in $\Perms(n)$, then 
              \begin{equation}
                  \label{eq:perm-compatibility-with-perm-identity-1}
                  \sourceperm{(1_n)} \colon \HomSet{\CatC}{\mtimescatob_{i=1}^n \Objan{i}}{\Objb} \to \HomSet{\CatC}{\mtimescatob_{i=1}^n \Obja_{i}}{\Objb}
              \end{equation}
              and 
              \begin{equation}
                  \label{eq:perm-compatibility-with-perm-identity-2}
                  \targetperm{(1_n)} \colon \HomSet{\CatC}{\Obja}{\mtimescatob_{i=1}^n \Objbn{i}} \to \HomSet{\CatC}{\Obja}{\mtimescatob_{i=1}^n \Objb_i}
              \end{equation}
              are the identity functions. 
              
         \item \emph{Compatibility with block permutations:}
         
         For any $n \in \natnumbers$ and any partition $n = k_1 + \dots + k_r$, if $\Objcn{1}, \dots, \Objcn{r}$ are equal to the $r$ factors in a ``partitioned'' stacking of the form
         \begin{align*}
\Obja = (\Objan{1} \mtimescatob \dots \mtimescatob \Objan{k_1}) & \mtimescatob (\Objan{k_1 + 1} \mtimescatob \dots \mtimescatob \Objan{k_1 + k_2}) \  \mtimescatob \\ & \dots \mtimescatob (\Objan{k_1 + \dots + k_{r-1} +1} \mtimescatob \dots \mtimescatob \Objan{n})
\end{align*}
 then for any $\sigma \in \Perms(r)$, the source permutation map $\sourceperm{\sigma}$ with respect to this $r$-fold stacking is equal to the source permutation map $\sourceperm{(\sigma_*(k_1, \dots, k_r))}$ with respect to the $n$-fold stacking
 \begin{equation*}
\Obja = \Objan{1} \mtimescatob \dots \mtimescatob \Objan{n}.
\end{equation*}
(Here, $\sigma_*(k_1, \dots, k_r)$ is the block permutation induced by $\sigma$ and the partition $n = k_1 + \dots + k_r$.)

The analogous statement for target permutation maps is also required to hold. 

                  
        \item \emph{Compatibility with semicategory composition:}

              For all $\mora \setin \HomSet{\CatC}{\Obja}{\mtimescatob_{i=1}^n \Objbn{i}}$ and $\morb \setin \HomSet{\CatC}{\mtimescatob_{i=1}^n \Objb_{\permmap(i)}}{\Objc}$
              \begin{equation}
                  \label{eq:perm-compatibility-with-composition}
                  \targetperm{\permmap} (\mora) \mthen \morb = \mora \mthen \sourceperm{\permmap}(\morb).
              \end{equation}

        \item \emph{Compatibility with stacking:}

              For all $\mora \in \HomSet{\CatC}{\mtimescatob_{i=1}^n \Objan{i}}{\Objbn{1}}$, $\morb \in \HomSet{\CatC}{\mtimescatob_{i=n+1}^{n+m} \Objan{i}}{\Objbn{2}}$,
              \begin{equation}
                  \sourceperm{\permmap}(\mora) \mtimescatmor \sourceperm{\pi}(\morb) = \sourceperm{(\permmap \mtimescat \pi)}(\mora \mtimescatmor \morb)
              \end{equation}
              holds for all $\permmap \in \Perms(n), \pi \in \Perms(m)$, where $\mtimescat$ is the stacking operation in $\Permcat$.

              Similarly, for all $\mora \in \HomSet{\CatC}{\Objan{1}}{\mtimescatob_{i=1}^n \Objbn{i}} $ and $\morb \in \HomSet{\CatC}{\Objan{2}}{\mtimescatob_{i=n+1}^{n+m} \Objbn{i}}$,
              \begin{equation}
                  \targetperm{\permmap}(\mora) \mtimescatmor \targetperm{\pi}(\morb) = \sourceperm{(\permmap \mtimescat \pi)}(\mora \mtimescatmor \morb)
              \end{equation}
              holds for all $\permmap \in \Perms(n), \pi \in \Perms(m)$.

        \item \emph{Sliding:}

              Given~$\moran{i} \colon \Objan{i} \mto \Objbn{i}$,~$1 \leq i \leq n$, it holds that
              \begin{equation}
                  \label{eq:perm-compatibility-with-stacking-1}
                  \targetperm{\permmap} ( \mtimescatmor_{i=1}^n \moran{i} ) = \sourceperm{\permmap}( \mtimescatmor_{i=1}^n \mora_{\permmap(i)} )
              \end{equation}
              and
              \begin{equation}
                  \label{eq:perm-compatibility-with-stacking-2}
                  \sourceperm{\permmap} ( \mtimescatmor_{i=1}^n \moran{i} ) = \targetperm{\permmap} ( \mtimescatmor_{i=1}^n \mora_{\permmap^{-1}(i)} ).
              \end{equation}

    \end{itemize}
\end{ctdefinition}

\todotext{@J: make figures to illustrate compatibility with stacking...}

\todotext{J: @J: also I think we need/should say something about how block permutations related to their non-block forms... how is this dealt with for classical symmetric monoidal categories? coherence? perhaps call this property something like ``compatibility with refinement''...}

\todotext{@J: check if this definition is compatible with the definition of a symmetric \SY{strict monoidal category}...}

In terms of diagrams, the condition of compatibility with composition \cref{eq:perm-compatibility-with-composition} is illustrated in terms of diagrams in \cref{fig:symmetric-stacking-comp-compat}.

\begin{figure*}[h]
    \centering
    \subfloat[\label{fig:symmetric-stacking-comp-compat-1}$\targetperm{\permmap} (\mora) \mthen \morb$]{
        \includesag{parallelism_symmetric-stacking-comp-compat-1}
        %\includegraphics[scale=0.1]{parallelism_symmetric-stacking-comp-compat-1}
    } \qquad \qquad
    \subfloat[\label{fig:symmetric-stacking-comp-compat-2}$\mora \mthen \sourceperm{\permmap}(\morb)$]{
        \includesag{parallelism_symmetric-stacking-comp-compat-2}
        %\includegraphics[scale=0.1]{parallelism_symmetric-stacking-comp-compat-2}
    }
    \caption{Compatibility with composition. }
    \label{fig:symmetric-stacking-comp-compat}
\end{figure*}

In \cref{fig:compatibility-with-stacking} the first equation \cref{eq:perm-compatibility-with-stacking-1} for compatibility with stacking is illustrated diagrammatically.

\begin{figure*}[h]
    \centering
    \subfloat[\label{fig:compatibility-with-stacking-1}$\targetperm{\permmap} ( \mtimescatmor_{i=1}^n \moran{i} )$]{
        \includesag{parallelism_compatibility-with-stacking-1}
        %\includegraphics[scale=0.1]{parallelism_compatibility-with-stacking-1}
    } \qquad \qquad
    \subfloat[\label{fig:compatibility-with-stacking-2}$\sourceperm{\permmap}(  \mtimescatmor_{i=1}^n \mora_{\permmap(i)}) $]{
        \includesag{parallelism_compatibility-with-stacking-2}
        %\includegraphics[scale=0.1]{parallelism_compatibility-with-stacking-2}
    }
    \caption{Sliding. }
    \label{fig:compatibility-with-stacking}
\end{figure*}

\cref{fig:compatibility-perm-comp} illustrates the first equation \cref{eq:perm-compatibility-with-perm-comp} for compatibility with permutation composition.

\begin{figure}[h]
    \centering
    \subfloat[\label{fig:compatibility-perm-comp-1}$\sourceperm{\permmap} \mthen \sourceperm{\pi}$]{
        \includesag{parallelism_compatibility-perm-comp-1}
        %\includegraphics[scale=0.1]{parallelism_compatibility-perm-comp-1}
    } \qquad \qquad
    \subfloat[\label{fig:compatibility-perm-comp-2}$\sourceperm{(\pi\mthen\permmap)} $]{
        \includesag{parallelism_compatibility-perm-comp-2}
        %\includegraphics[scale=0.1]{parallelism_compatibility-perm-comp-2}
    }
    \caption{Compatibility with composition. }
    \label{fig:compatibility-perm-comp}
\end{figure}

%\begin{figure*}[b]
%    %\includegraphics[width=8cm]{symmetric}
%    \centering
%    \subfloat[]{
%        \includesag{symmetric_stacking}
%    }
%    \subfloat[]{
%        \includesag{symmetric_stacking_bis}
%    }
%    \caption{
%        Illustration of \cref{eq:symmetric-condition}.
%    }
%    \label{fig:stacking-symmetric}
%\end{figure*}

\todotext{\alphubel: spell out Moore as an example}

\todotext{\alphubel: spell out proper LTI as an example}

\begin{example}
    \SetL is symmetric in a straightforward manner.
\end{example}

\todotext{\alphubel: explain this example}

\begin{lemma}
    \label{lem:effects-not-symmetric}
    \Effects is not symmetric.
\end{lemma}

\todotext{\alphubel: prove this lemma}

\todographicsjira{431}{\alphubel: @Andrea: Add figure for this lemma, in the same style as \cref{fig:effects-non-functorial} }

\todojira{699}{\alphubel: Example of \LTI with $d=0$ a symmetric semicat}

\devel{
    \begin{ctdefinition}[Commutative stacking semicategory]
        \label{def:commutative-stacking-semicat}
        A \maindef{commutative stacking semicategory} is a \SY{stacking semicategory} $\tup{\CatC, \mtimescatob, \mtimescatmor}$ with

        \condit

        \begin{enumerate}
            \item \emph{Symmetry}:
                  \begin{equation}
                      \Obja \mtimescatob \Objb = \Objb \mtimescatob \Obja
                  \end{equation}
                  for all object $\Obja, \Objb \setin \Ob_\CatC$.
        \end{enumerate}
    \end{ctdefinition}

    \todotext{J: @JL: do we need any more assumptions/constituents/conditions? check, because we are not assuming functorial stacking!!}

    \todotext{J: @J: given an example}

}
% \devel{

%     \section{Strict monoidal semicategories}

%     \begin{ctdefinition}\label{def:strict-monoidal-semicat}
%         A \emph{strict monoidal semicategory} is a functorial stacking semicategory $\tup{\CatC, \mtimescat}$ with

%         \constit

%         \begin{itemize}
%             \item an object $\idmoncat \setin \Obof{\CatC}$, called the \emph{monoidal unit}
%         \end{itemize}

%         \condit

%         \begin{itemize}
%             \item For any object $\Obja$ of \CatC,
%                   \begin{equation}
%                       \Obja \mtimescatob \idmoncat = \Obja \qquad \text{and} \qquad  \idmoncat \mtimescatob \Obja = \Obja.
%                   \end{equation}
%             \item The monoidal unit $\idmoncat$ has an identity morphism $\catid_\idmoncat$, and for any morphism $\mora \colon \Obja \mto \Objb$,
%                   \begin{equation}
%                       \mora \mtimescatmor \catid_\idmoncat = \mora \qquad \text{and} \qquad \catid_\idmoncat \mtimescat  \mora = \mora.
%                   \end{equation}
%         \end{itemize}

%     \end{ctdefinition}

%     \todotext{@JL: write def of symmetric strict monoidal semicategory}

% }

\devel{
 \section{Symmetric stacking categories}
 \label{sec:symmetric-stacking-categories}

    \todotext{J: @J: fill this subsection}

    \begin{ctdefinition}
        \label{def:sym-stacking-cat}
        A \emph{symmetric stacking category} is an \SY{associative stacking category} $\tup{\CatC, \mtimescatob, \mtimescatmor}$ with

        \constit

        \begin{enumerate}
            \item For any two objects $\Obja, \Objb \setin \Ob_\CatC$ there exists an isomorphism
                  \begin{equation}
                      \permmap_{\Obja, \Objb} \colon \Obja \mtimescatob \Objb \mto \Objb \mtimescatob \Obja,
                  \end{equation}
                  called the \emph{braiding}.
        \end{enumerate}

        \condit

        \begin{enumerate}
            \item \emph{Naturality}: For any morphisms $\mora \colon \Obja \mto \Objc$, $\morb \colon \Objb \mto \Objd$, the diagram
                   \begin{equation}\label{eq:naturality-square-symm-stacking-cat}
                  \middlesag{naturality-square-symm-stacking-cat}
              \end{equation}
                  commutes.
            \item \emph{Compatibility with nesting}:  
           \begin{equation}\label{eq:hexagon-identity-symm-stacking-cat}
                  \middlesag{hexagon-identity-symm-stacking-cat}
              \end{equation}
                             
            \item \emph{Symmetry}: For all $\Obja, \Objb \setin \Ob_\CatC$,
                  \begin{equation}
                      \permmap_{\Obja, \Objb} \mthen \permmap_{\Objb, \Obja} = \catid_{\Obja \mtimescatob \Objb}.
                  \end{equation}
        \end{enumerate}

    \end{ctdefinition}
   


    
    We note that the braidings $\permmap_{\Obja, \Objb}$ of a symmetric stacking category induce source and target permutation operations as in the \cref{def:symmetric-stacking-category} of symmtric stacking semicatory. To see how this works, recall that every permutation can be written in a (non-unique) way as a composition of transpositions. 
    
        \begin{lemma}
    Every symmetric stacking category $\tup{\CatC, \mtimescatob, \mtimescatmor, \permmap}$, when equipped with the source and target permutation operations induced by the braidings $\permmap_{\Obja, \Objb}$, is a symmetric stacking semicategory.  
    \end{lemma}
    
        \todotext{J: @JL: is this lemma true like this, or do we need any more assumptions/constituents/conditions for the definition of symmetric stacking category? check, because we are not assuming functorial stacking!!}

    \todotext{J: @JL: make two example of symmetric strict monoidal \SY{semicategory} using natural numbers, once with addition and once with multiplication}

    \begin{ctdefinition}[Commutative stacking category]
        \label{def:commutative-stacking-cat}
        A \maindef{commutative stacking category} is a \SY{symmetric stacking category} $\tup{\CatC, \mtimescatob, \mtimescatmor}$ with

        \condit

        \begin{enumerate}
            \item \emph{Commuatativity}:
                  \begin{equation}
                      \Obja \mtimescatob \Objb = \Objb \mtimescatob \Obja
                  \end{equation}
                  for all object $\Obja, \Objb \setin \Ob_\CatC$.
        \end{enumerate}
    \end{ctdefinition}

    \todotext{J: @JL: do we need any more assumptions/constituents/conditions? check, because we are not assuming functorial stacking!!}
    


    \todotext{J: @J: given an example}

    \subsection{Symmetric strict monoidal categories}
    
    

    \todotext{define this concept and discuss examples}
    
    \begin{ctdefinition}[Symmetric strict monoidal category]
        \label{def:symmetric-strict-monoidal-cat}
        A \maindef{symmetric strict monoidal category} is a \SY{strict monoidal category} $\tup{\CatC, \mtimescat, \idmoncat}$ which is also a symmetric stacking category. This means that $\CatC$ is equipped with braidings 
        \begin{equation}
                      \permmap_{\Obja, \Objb} \colon \Obja \mtimescat \Objb \mto \Objb \mtimescat \Obja                  \end{equation}
                  which satisfy the conditions of naturality, compatibility with nesting, and symmetry. 
    \end{ctdefinition}


}
