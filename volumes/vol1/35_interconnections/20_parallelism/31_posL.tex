% !TEX root = chapter-standalone.tex

\section{The Category~$\cCat{\Pos}$}

We define a category analogous to~$\cCat{\Set}$, but its objects are ``posets of tuples''.

Given posets~$\posA_1,\ldots, \posA_n$ we define
\begin{equation*}
    \cObj{\posA_1,\ldots, \posA_n}\coloneqq \tup{\cObj{\posAsetn{1},\ldots, \posAsetn{n}}, \posleqof{\cObj{\posA_1,\ldots, \posA_n}}},
\end{equation*}
where~$\cObj{\posAsetn{1},\ldots, \posAsetn{n}}$ is a set of tuples and~$\tup{\posAnel{1},\ldots, \posAnel{n}}\posleqof{\cObj{\posA_1,\ldots, \posA_n}}\tup{\posAnel{1}',\ldots, \posAnel{n}'}$ if and only if~$\posAnel{i}\posleqof{\posA_i} \posAnel{i}'$ for all~$i\in \{1,\ldots, n\}$.
%
%\begin{equation*}
%    \prfdouble{\tup{\posAnel{1},\ldots, \posAnel{n}}\posleqof{\cObj{\posA_1,\ldots, \posA_n}}\tup{\posAnel{1}',\ldots, \posAnel{n}'}}
%    {\posAnel{1} \posleqof{\posA_1}\posAnel{1}' \booland \ldots \booland \posAnel{n} \posleqof{\posA_n} \posAnel{n}'}
%\end{equation*}

Analogously to what we did for \cCat{\Set}, one can define a multiplication operation in \cCat{\Pos}.
Given~$\cObj{\posA_1,\ldots, \posA_m}$ and~$\cObj{\posB_1,\ldots, \posB_n}$, one has
\begin{widepar}
    \begin{equation}
        \label{eq:multposstack}
        \begin{aligned}
            \cObj{\posA_1,\ldots, \posA_m}\cprod \cObj{\posB_1,\ldots, \posB_n} & \definedas \tup{\cObj{\posAsetn{1},\ldots, \posAsetn{m}} \cprod \cObj{\posBsetn{1},\ldots, \posBsetn{n}}, \posleqof{\cObj{\posA_1,\ldots, \posA_m}\cprod \cObj{\posB_1,\ldots, \posB_n}}} \\
                                                                                & =\tup{\cObj{\posAsetn{1},\ldots, \posAsetn{m},\posBsetn{1},\ldots, \posBsetn{n}}, \posleqof{\cObj{\posA_1,\ldots, \posA_m}\cprod \cObj{\posB_1,\ldots, \posB_n}}},
        \end{aligned}
    \end{equation}
\end{widepar}
where~$\tup{\posAnel{1},\ldots, \posAnel{m},\posBnel{1},\ldots, \posBnel{n}} \posleqof{\cObj{\posA_1,\ldots, \posA_m}\cprod \cObj{\posB_1,\ldots, \posB_n}} \tup{\posAnel{1}',\ldots, \posAnel{m}',\posBnel{1}',\ldots, \posBnel{n}'}$ if and only if~$\posAnel{i}\posleqof{\posA_i}\posAnel{i}'$ and~$\posBnel{j}\posleqof{\posB_j}\posBnel{j}'$ for all~$i\in \{1,\ldots, m\}$,~$j\in \{1,\ldots, n\}$.

The resulting poset of tuples is written as~$\cObj{\posA_1,\ldots, \posA_m,\posB_1,\ldots, \posB_n}$.

\begin{definition}[The category~$\cCat{\Pos}$]
    \label{def:PosL}
    The category~$\cCat{\Pos}$ is:
    \begin{enumerate}
        \item \emph{Objects:} posets of tuples.
        \item \emph{Morphisms:}
              Monotone functions between posets of tuples.
        \item \emph{Composition:}
              Composition is the usual composition of functions.
        \item \emph{Identities:}
              Identity functions.
    \end{enumerate}
\end{definition}

We now want to show that one can define a structure for which~$\cCat{\Pos}$ is associative stacking.
To do so, we define the stacking operation on objects as the multiplication operation~$\cprod$ defined in \cref{eq:multposstack}.

The stacking operation on morphisms is defined as
\begin{equation*}
    \defmapcomma{\mtimescatmor}{\Mor_{\cCat{\Pos}} \cartprod \Mor_{\cCat{\Pos}}}{\mto}{\Mor_{\cCat{\Pos}}}{\tup{\mora,\morb}}{\mora \cprod \morb},
\end{equation*}
where~$(\mora \cprod \morb)(\tup{\posAnel{1},\ldots, \posAnel{m}} \tupconcat \tup{\posBnel{1},\ldots, \posBnel{n}})\definedas \mora(\tup{\posAnel{1},\ldots, \posAnel{m}})\tupconcat \morb(\tup{\posBnel{1},\ldots, \posBnel{n}})$.

\begin{lemma}[\cCat{\Pos} is associative stacking]
    \cCat{\Pos}, equipped with the aforementioned stacking operations on objects and morphisms, is associative stacking.
\end{lemma}

\begin{proof}
    We show that~$\cCat{\Pos}$ is an associative stacking semicategory.
    We first show that it is a stacking category.
    To show that the two stacking operations are compatible, we start from
    \begin{equation*}
        \prfperiod{\mora\colon \cObj{\posA_1,\ldots,\posA_m}\mto \cObj{\posC_1,\ldots,\posC_o}}
        {\morb\colon \cObj{\posB_1,\ldots,\posB_n}\mto \cObj{\posD_1,\ldots,\posD_t}}
        {\mora \cprod \morb \colon \cObj{\posA_1, \ldots, \posA_m, \posB_1, \ldots, \posB_n} \mto \cObj{\posC_1, \ldots, \posC_o, \posD_1, \ldots, \posD_t}}
    \end{equation*}
    %
    The crucial part to show is that~$\mora \cprod \morb$ is a monotone map.
    This is easy to show, by leveraging the monotonicity of~$\mora$ and~$\morb$.
    For brevity, in the following we write~$\posAnel{}=\tup{\posAnel{1},\ldots, \posAnel{m}}$,~$\posAnel{}'=\tup{\posAnel{1}',\ldots, \posAnel{m}'}$,~$\posBnel{}=\tup{\posBnel{1},\ldots, \posBnel{n}}$, and~$\posBnel{}'=\tup{\posBnel{1}',\ldots, \posBnel{n}'}$.
    One has
    \begin{equation*}
        \prfcomma{\posAnel{}\tupconcat \posBnel{} \posleqof{\cObj{\posA_1,\ldots, \posA_m,\posB_1,\ldots, \posB_n}} \posAnel{}'\tupconcat \posBnel{}'}
        {\prftree{
                \left(\posAnel{} \posleqof{\cObj{\posA_1,\ldots, \posA_m}} \posAnel{}'\right) \booland \left(\posBnel{} \posleqof{\cObj{\posB_1,\ldots, \posB_n}} \posBnel{}'\right)}
            {
                \prftree{
                    \left(\mora(\posAnel{}) \posleqof{\cObj{\posC_1,\ldots, \posC_o}} \mora(\posAnel{}')\right) \booland \left(\morb(\posBnel{})\posleqof{\cObj{\posD_1,\ldots, \posD_t}} \morb(\posBnel{}')\right)}
                {
                    \prftree{
                        {\mora(\posAnel{}) \tupconcat \morb(\posBnel{})  \posleqof{\cObj{\posC_1,\ldots, \posC_o, \posD_1,\ldots, \posD_t}} \mora(\posAnel{}') \tupconcat \morb(\posBnel{}')}}
                    {(\mora \cprod \morb)(\posAnel{}\tupconcat \posBnel{}) \posleqof{\cObj{\posC_1,\ldots, \posC_o,\posD_1,\ldots, \posD_t}} (\mora \cprod \morb)(\posAnel{}'\tupconcat \posBnel{}')
                    }}}
        }
    \end{equation*}
    which shows monotonicity.

    The proof of associativity is parallel to the proof for \cCat{\Set}.
\end{proof}

\begin{lemma}
    \cCat{\Pos} is functorial stacking.
\end{lemma}
\begin{proof}
    The proof is analogous to the one for \cCat{\Set} in \cref{ex:setfunstack}.
\end{proof}