% !TEX root = chapter-standalone.tex

\section{The category~\PosL}

We define a category analogous to~\SetL, but its objects are ``posets of tuples''.

Given posets~$\posA_1,\ldots, \posA_n$ we define the poset
\begin{equation}
    \label{eq:posetoftuples}
    \cObj{\posA_1,\ldots, \posA_n}\definedas \tup{\cObj{\posAsetn{1},\ldots, \posAsetn{n}}, \posleqof{\cObj{\posA_1,\ldots, \posA_n}}},
\end{equation}
where~$\cObj{\posAsetn{1},\ldots, \posAsetn{n}}$ is a set of tuples, and we use the product order:~$\tup{\posAnel{1},\ldots, \posAnel{n}}\posleqof{\cObj{\posA_1,\ldots, \posA_n}}\tup{\posAnel{1}',\ldots, \posAnel{n}'}$ if and only if~$\posAnel{i}\posleqof{\posA_i} \posAnel{i}'$ for all~$i\setin \makeset{1,\ldots, n}$.
\todotext{\alphubel: @Gioele: use prfdouble}
Analogously to what we did for \SetL, one can define a multiplication operation in \PosL.
Given~$\cObj{\posA_1,\ldots, \posA_m}$ and~$\cObj{\posB_1,\ldots, \posB_n}$, we have
\begin{widepar}
    \begin{equation}
        \label{eq:multposstack}
        \begin{aligned}
            \cObj{\posA_1,\ldots, \posA_m}\cprod \cObj{\posB_1,\ldots, \posB_n} & \definedas \tup{\cObj{\posAsetn{1},\ldots, \posAsetn{m}} \cprod \cObj{\posBsetn{1},\ldots, \posBsetn{n}}, \posleqof{\cObj{\posA_1,\ldots, \posA_m}\cprod \cObj{\posB_1,\ldots, \posB_n}}} \\
                                                                                & =\tup{\cObj{\posAsetn{1},\ldots, \posAsetn{m},\posBsetn{1},\ldots, \posBsetn{n}}, \posleqof{\cObj{\posA_1,\ldots, \posA_m}\cprod \cObj{\posB_1,\ldots, \posB_n}}},
        \end{aligned}
    \end{equation}
\end{widepar}
where~$\tup{\posAnel{1},\ldots, \posAnel{m},\posBnel{1},\ldots, \posBnel{n}} \posleqof{\cObj{\posA_1,\ldots, \posA_m}\cprod \cObj{\posB_1,\ldots, \posB_n}} \tup{\posAnel{1}',\ldots, \posAnel{m}',\posBnel{1}',\ldots, \posBnel{n}'}$ if and only if~$\posAnel{i}\posleqof{\posA_i}\posAnel{i}'$ and~$\posBnel{j}\posleqof{\posB_j}\posBnel{j}'$ for all~$i\setin \makeset{1,\ldots, m}$,~$j\setin \makeset{1,\ldots, n}$.
% Note that this construction is analogous to the product poset.
% The resulting poset of tuples is written as~$\cObj{\posA_1,\ldots, \posA_m,\posB_1,\ldots, \posB_n}$.

\begin{definition}
    [The category~\PosL]
    \label{def:PosL}
    The category~\PosL is the subcategory of \Pos where the objects are posets of tuples.
    % \begin{enumerate}
    %     \item \emph{Objects:} posets of the form presented in \cref{eq:posetoftuples}.
    %     \item \emph{Morphisms:}
    %           Monotone functions between posets of the form presented in \cref{eq:posetoftuples}.
    %     \item \emph{Composition:}
    %           Composition is the usual composition of functions.
    %     \item \emph{Identities:}
    %           Identity functions.
    % \end{enumerate}
\end{definition}

We now want to show that one can define a structure for which~\PosL is associative stacking.
To do so, we define the stacking operation on objects as the multiplication operation~$\cprod$ defined in \cref{eq:multposstack}.

The stacking operation on morphisms is defined as
\begin{equation}
    \defmapcomma{
        \mtimescatmor
    }{
        \Mor_{\PosL} \cartprod \Mor_{\PosL}
    }{
        \mto
    }{
        \Mor_{\PosL}
    }{
        \tup{\mora,\morb}
    }{
        \mora \cprod \morb
    }
\end{equation}
where~$(\mora \mtimescatmor \morb)(\tup{\posAnel{1},\ldots, \posAnel{m}} \tupconcat \tup{\posBnel{1},\ldots, \posBnel{n}})\definedas \mora(\tup{\posAnel{1},\ldots, \posAnel{m}})\tupconcat \morb(\tup{\posBnel{1},\ldots, \posBnel{n}})$.

\begin{lemma}[\PosL is associative stacking]
    \PosL, equipped with the aforementioned stacking operations on objects and morphisms, is associative stacking.
\end{lemma}

\begin{proof}
    % We show that~\PosL is an associative stacking semicategory.
    We first show that it is a stacking category, by showing that the stacking operations fulfill \cref{def:simple-stacking-semi-cat}, and then showing the compatibility condition.
    The stacking operation on objects fulfills \cref{def:simple-stacking-semi-cat}, since, given two posets of tuples it returns a poset of tuples.
    To show that the stacking operation on morphism fulfills \cref{def:simple-stacking-semi-cat}, we need to show that given monotone~$\mora,\morb$, the map~$\mapa \mtimescatmor \mapb$ is monotone.
    This is easy to show, by leveraging the monotonicity of~$\mora$ and~$\morb$.
    For brevity, in the following we write~$\posAnel{}=\tup{\posAnel{1},\ldots, \posAnel{m}}$,~$\posAnel{}'=\tup{\posAnel{1}',\ldots, \posAnel{m}'}$,~$\posBnel{}=\tup{\posBnel{1},\ldots, \posBnel{n}}$, and~$\posBnel{}'=\tup{\posBnel{1}',\ldots, \posBnel{n}'}$.
    We have
    \begin{equation}
        \prfcomma{\posAnel{}\tupconcat \posBnel{} \posleqof{\cObj{\posA_1,\ldots, \posA_m,\posB_1,\ldots, \posB_n}} \posAnel{}'\tupconcat \posBnel{}'}
        {\prftree{
                \left(\posAnel{} \posleqof{\cObj{\posA_1,\ldots, \posA_m}} \posAnel{}'\right) \booland \left(\posBnel{} \posleqof{\cObj{\posB_1,\ldots, \posB_n}} \posBnel{}'\right)}
            {
                \prftree{
                    \left(\mora(\posAnel{}) \posleqof{\cObj{\posC_1,\ldots, \posC_o}} \mora(\posAnel{}')\right) \booland \left(\morb(\posBnel{})\posleqof{\cObj{\posD_1,\ldots, \posD_t}} \morb(\posBnel{}')\right)}
                {
                    \prftree{
                        {\mora(\posAnel{}) \tupconcat \morb(\posBnel{})  \posleqof{\cObj{\posC_1,\ldots, \posC_o, \posD_1,\ldots, \posD_t}} \mora(\posAnel{}') \tupconcat \morb(\posBnel{}')}}
                    {(\mora \mtimescatmor \morb)(\posAnel{}\tupconcat \posBnel{}) \posleqof{\cObj{\posC_1,\ldots, \posC_o,\posD_1,\ldots, \posD_t}} (\mora \mtimescatmor \morb)(\posAnel{}'\tupconcat \posBnel{}')
                    }}}
        }
    \end{equation}
    which shows monotonicity.
    Furthermore, the two stacking operations are compatible:
    \begin{equation}
        \prfperiod{\mora\colon \cObj{\posA_1,\ldots,\posA_m}\mto \cObj{\posC_1,\ldots,\posC_o}}
        {\morb\colon \cObj{\posB_1,\ldots,\posB_n}\mto \cObj{\posD_1,\ldots,\posD_t}}
        {\mora \mtimescatmor \morb \colon \cObj{\posA_1, \ldots, \posA_m, \posB_1, \ldots, \posB_n} \mto \cObj{\posC_1, \ldots, \posC_o, \posD_1, \ldots, \posD_t}}
    \end{equation}
    %
    The proof of associativity is parallel to the proof for~\SetL.
\end{proof}
%
\begin{lemma}
    \PosL, equipped with the aforementioned stacking operations on objects and morphisms, is functorial stacking.
\end{lemma}
%
\begin{proof}
    The proof is analogous to the one for \SetL in \cref{ex:setfunstack}.
\end{proof}
