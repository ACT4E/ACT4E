% !TEX root = chapter-standalone.tex

\section{Stacking semicategories}
\label{sec:parallel-stacking}

\todotext{This is strange here, move to intro?}
So far we have seen how we can compose morphisms ``horizontally'':
%
\begin{equation}
    \prfperiod{
        \mora \colon \Obja \mto \Objb
    }{
        \morb\colon \Objb \mto \Objc
    }{
        \morab \colon \Obja \mto \Objc
    }
\end{equation}
%
There are other notions of composition that allow us to compose morphisms by ``stacking them vertically''.
Given two morphisms
%
\begin{align}
    \mora & \colon \Obja \mto \Objb, \\
    \morb & \colon \Objc \mto \Objd,
\end{align}
%
we will obtain by parallel stacking a morphism
%
\begin{align}
    (\mora\mtimescatmor \morb)
     & \colon (\Obja \mtimescatob \Objc) \mto (\Objb \mtimescatob \Objd),
\end{align}
%
where ``$\mtimescatmor$'' and ``$\mtimescatob$'' are operations to be defined.
Note that while in the case of sequential composition there was a compatibility condition to be defined, as the target of the first morphism must be the source of the second morphism, here instead we can stack arbitrary morphisms.

We also expect to be able to stack any number of morphisms.
Having a collection of morphisms
%
\begin{equation}
    \moran{i} \colon \Objan{i} \mto \Objbn{i}, \qquad 1 \leq i \leq n,
\end{equation}
%
we expect to be able to obtain the composed morphism
%
\begin{equation}
    (\mtimescatmor_{i=1}^n \moran{i} )
    \colon( \mtimescatob_{i=1}^n \Objan{i} )\mto (\mtimescatob_{i=1}^n \Objbn{i}).
\end{equation}

\subsection{Stacking semicategories}

\begin{marginfigure}
    \centering
    \includesag{parallelism-stacked-morphisms}
    %\includegraphics[scale=0.12]{parallelism_stacked-morphisms}
    \caption{Stacked morphisms}
    \label{fig:stacked-morphisms}
\end{marginfigure}

\begin{marginfigure}
    \centering
    \includesag{parallelism_stacked-morphisms-diagram}
    %\includegraphics[scale=0.17]{parallelism_stacked-morphisms-diagram}
    \caption{Stacking string diagrams}
    \label{fig:stacked-morphisms-diagram}
\end{marginfigure}

\begin{ctdefinition}[Stacking semicategory]
    \label{def:simple-stacking-semi-cat}
    A \maindef{stacking semicategory} is a \SY{semicategory}~\CatC with the following additional constituents and properties.

    \constit
    \begin{itemize}
        \item A stacking operation~$\mtimescatob \colon \ObC \cartprod \ObC \sto \ObC$.
        \item A stacking operation~$\mtimescatmor \colon \Mor_\CatC \cartprod \Mor_\CatC \sto \Mor_\CatC$.
    \end{itemize}

    \condit
    \begin{itemize}
        \item The two operations~$\mtimescatob$ and~$\mtimescatmor$ are compatible in the sense that
              %
              \begin{equation}
                  \prfperiod{
                      \moran{1} \colon \Objan{1} \mto \Objbn{1}
                      \qquad
                      \moran{2} \colon \Objan{2} \mto \Objbn{2}
                  }{
                      \moran{1} \mtimescatmor \moran{2} \colon  \Objan{1} \mtimescatob  \Objan{2} \mto \Objbn{1} \mtimescatob \Objbn{2}
                  }
              \end{equation}
    \end{itemize}
\end{ctdefinition}

In \cref{fig:stacked-morphisms} we have depicted a string diagram of two stacked morphisms.
Alternatively, in \cref{fig:stacked-morphisms-diagram} we depict the stacking of the string diagrams for $\moran{1}$ and $\moran{2}$, respectively, by stacking their diagrams vertically and drawing a box around them, merging their respective input and output terminals.
The outer box denotes $\moran{1} \mtimescatmor \moran{2}$; we think of \cref{fig:stacked-morphisms} as a ``black-boxed'' version of \cref{fig:stacked-morphisms-diagram}.

\begin{figure*}[tbh]
    \centering
    \begin{subfigure}{0.49\linewidth}
        \includesag{parallelism_associative-stacking-1}
        %\includegraphics[scale=0.15]{parallelism_associative-stacking-1}
        \caption{One way of stacking three morphisms}
        \label{fig:associative-stacking-1}
    \end{subfigure}
    %
    \begin{subfigure}{0.49\linewidth}
        \includesag{parallelism_associative-stacking-2}
        %\includegraphics[scale=0.15]{parallelism_associative-stacking-2}
        \caption{Another way of stacking three morphisms}
        \label{fig:associative-stacking-2}
    \end{subfigure}
    \caption{Stacking three morphisms.}
\end{figure*}

\todotext{Put examples here of stacking categories that are in the slides}
\section{Associative stacking (semi)categories}

\begin{ctdefinition}[Associative stacking semicategory]
    \label{def:assoc-stacking-semi-cat}
    An \maindef{associative stacking semicategory} is a \SY{stacking semicategory} $\tup{\CatC, \mtimescatob, \mtimescatmor}$ satisfying the following.

    \condit
    \begin{itemize}
        \item The stacking operation~$\mtimescatob$ makes the objects into a \SY{semigroup}.
        \item The stacking operation~$\mtimescatmor$ makes the morphisms into a \SY{semigroup}.
    \end{itemize}
\end{ctdefinition}

If a \SY{semicategory} is \SY{associative stacking}, then the two ways of stacking three morphisms -- as depicted in \cref{fig:associative-stacking-1} and \cref{fig:associative-stacking-2}, respectively -- give the same result.
For \SY{associative stacking} \SY{semicategories} we will use a simpler diagrammatic notation, where the diagrams in \cref{fig:associative-stacking-1} and \cref{fig:associative-stacking-2} instead look like the ones in \cref{fig:associative-stacking-1-new} and \cref{fig:associative-stacking-2-new}.
Since these two diagrams depict that same morphism, when it is convenient we will also simply depict them as in \cref{fig:triple-stacked} (and similarly for any number of stacked morphisms).
In particular, in an \SY{associative stacking} \SY{semicategory}, and stacking of two morphisms will be depicted as in \cref{fig:double-stacked-new}.

\begin{marginfigure}[]
    \centering
    \includesag{parallelism_associative-stacking-1-new}
    %\includegraphics[scale=0.15]{parallelism_associative-stacking-1-new}
    \caption{Associative stacking of three morphisms, in one order.}
    \label{fig:associative-stacking-1-new}
\end{marginfigure}

\begin{marginfigure}
    \centering
    \includesag{parallelism_associative-stacking-2-new}
    %\includegraphics[scale=0.15]{parallelism_associative-stacking-2-new}
    \caption{Associative stacking of three morphisms, in another order.}
    \label{fig:associative-stacking-2-new}
\end{marginfigure}

\begin{marginfigure}
    \centering
    \includesag{parallelism-triple-stacked}
    %\includegraphics[scale=0.15]{parallelism_triple-stacked}
    \caption{Our string diagram notation for a triple stack.}
    \label{fig:triple-stacked}
\end{marginfigure}

\begin{figure}[h!]
    \centering
    \includesag{parallelism-associative-stacking-two-new}
    %\includegraphics[scale=0.15]{parallelism_associative-stacking-two-new}
    \caption{Associative stacking of two morphisms.}
    \label{fig:double-stacked-new}
\end{figure}

\begin{remark}
    In an \SY{associative stacking} \SY{semicategory} it follows that we can stack any number of morphisms without needing to bracket using parentheses:
    \begin{equation}
        \prfperiod{
            \moran{i} \colon \Objan{i} \mto \Objbn{i}, \qquad 1 \leq i \leq n,
        }{
            \mtimescatmor_{i=1}^n \moran{i} \colon \mtimescatob_{i=1}^n \Objan{i} \mto \mtimescatob_{i=1}^n \Objbn{i}.
        }
    \end{equation}
\end{remark}

\begin{ctdefinition}[Associative stacking category]
    \label{def:assoc-stacking-cat}
    An \maindef{associative stacking category} is a \SY{associative stacking semicategory} $\tup{\CatC, \mtimescatob, \mtimescatmor}$ where $\CatC$ is in fact a category.
\end{ctdefinition}

\begin{example}\label{ex:assoc-stacking-semicat-integers-max}
    We let the integers $\wnumbers$ to be the set of objects of an associative stacking semicategory, and we say that there exists a unique morphism $\Obja \mto \Objb$ if and only if $\Obja \leq \Objb$.
    (We have already seen that this forms a semicategory; in fact, a category.) As our stacking operation for objects we set
    \begin{equation}
        \Obja \mtimescatob \Objb := \max(\Obja, \Objb)
    \end{equation}
    and for stacking morphisms we say that if $\mora \colon \Obja \mto \Objb$ and $\morb \colon \Objc \mto \Objd$ exist, then there exists a unique morphism
    \begin{equation}
        \mora \mtimescatmor \morb \colon \Obja \mtimescatob \Objc \mto \Objb \mtimescatob \Objd
    \end{equation}
    which corresponds to (and is consistent with) the inequality
    \begin{equation}
        \max(\Obja, \Objc) \leq \max(\Objb, \Objd).
    \end{equation}
\end{example}

\begin{example}\label{ex:assoc-stacking-semicat-lists-concat}
    Let $\setA$ be a non-empty set and consider a semicategory where the collection of objects is $ \listsof \setA$, the set of non-empty lists of elements of $\setA$.
    We can define a pre-order on $\listsof \setA$ by setting, for any lists $\Obja, \Objb$,
    \begin{equation}
        \Obja \leq \Objb \definedas \text{length}(\Obja) \leq \text{length}(\Objb).
    \end{equation}
    Then we view this pre-order as a semicategory, and define the following stacking operations.
    Given lists $\Obja, \Objb$, let $\Obja \mtimescatob \Objb$ be the concatenation of $\Obja$ and $\Objb$, and given morphisms $\mora \colon \Obja \mto \Objb$ and $\morb \colon \Objc \mto \Objd$ representing inequalities, we let $\mora \mtimescatmor \morb \colon \Obja \mtimescatob \Objc \mto \Objb \mtimescatob \Objd$ represent the inequality
    \begin{equation}
        \text{length}(\Obja \mtimescatob \Objc) \leq \text{length}(\Objb \mtimescatob \Objd).
    \end{equation}

\end{example}

\begin{lemma}
    \label{lem:SetL-is-associative-stacking}
    \SetL is  \SY{associative stacking} using the structure that arises from tuple concatenation.
    % by setting $\mtimescatob_{\SetL} \definedas \cprod$
    % and $\mtimescatmor_{\SetL} \definedas \cprod$
\end{lemma}
\begin{proof}
    % In this example we show that~\SetL is an  \SY{associative stacking} semicategory.
    % We first show that it is a stacking category.
    % To do so, we start by showing that the stacking operations fulfill \cref{def:simple-stacking-semi-cat}.
    For the stacking operation on objects $\mtimescatob$ we use the operation $\cprod$ defined in \cref{sec:cartcatset} which was referred to as the ``multiplication in \SetL'':
    \begin{align}
        \cObj{\setAn{1}, \dots, \setAn{m}} \mtimescatob \cObj{\setBn{1}, \dots, \setBn{n}} & \definedas \cObj{\setAn{1}, \dots, \setAn{m}} \cprod \cObj{\setBn{1}, \dots, \setBn{n}} \\
                                                                                           & = \cObj{\setAn{1}, \dots, \setAn{m}, \setBn{1}, \dots, \setBn{n}}.
    \end{align}
    It was shown there that this operation is associative.

    As for $\mtimescatmor$, we define it as follows:
    \begin{equation}
        \label{eq:mtimescatmor-SetL}
        \prfperiod{
            \mora\colon\setA\mtoin\SetL\setB
        }{
            \quad
        }{
            \morb\colon\setC\mtoin\SetL\setD
        }{
            \defmap{
                (\mora\mtimescatmor\morb )
            }{
                \setA \cprod \setC
            }{
                \mtoin\SetL
            }{
                \setB \cprod \setD
            }{
                \maketupconcat{\ela, \elc}
            }{
                \maketupconcat{\mora(\ela), \morb(\elc)}
            }
        }
    \end{equation}
    The two operations $\mtimescatob, \mtimescatmor$ so defined satisfy the compatibility conditions
    required by \cref{def:simple-stacking-semi-cat}.

    To show associativity, consider three morphisms
    \begin{equation}\label{eq:SetL-morphisms-to-associatively-stack}
        % \begin{aligned}
        \mora\colon\setA\mtoin\SetL\setB,\qquad
        \morb\colon\setC\mtoin\SetL\setD,\qquad
        \morc\colon\setE\mtoin\SetL\setF.
        % \end{aligned}
    \end{equation}
    We compute $\mora\mtimescatmor(\morb\mtimescatmor\morc)$ and $(\mora\mtimescatmor\morb)\mtimescatmor\morc$ following the recipe \cref{eq:mtimescatmor-SetL} to obtain
    \begin{equation}\label{eq:SetL-morphisms-associative-stack-check-1}
        \defmapcomma{
            \parslight{\mora\mtimescatmor\morb}\mtimescatmor\morc
        }{
            \parslight{\setA \cprod \setC} \cprod \setE
        }{
            \mtoin\SetL
        }{
            \parslight{\setB \cprod \setD} \cprod \setF
        }{
            \maketupconcat{\parslight{\maketupconcat{\ela, \elc}}, \ele}
        }{
            \maketupconcat{\parslight{\maketupconcat{\mora(\ela), \morb(\elc)}}, \morc(\ele) }
        }
    \end{equation}
    \begin{equation}\label{eq:SetL-morphisms-associative-stack-check-2}
        \defmapperiod{
            \mora\mtimescatmor\parslight{\morb\mtimescatmor\morc}
        }{
            \setA \cprod \parslight{\setC \cprod \setE}
        }{
            \mtoin\SetL
        }{
            \setB \cprod \parslight{\setD \cprod \setF}
        }{
            \maketupconcat{\ela, \parslight{\maketupconcat{\elc, \ele}}}
        }{
            \maketupconcat{\mora(\ela), \parslight{\maketupconcat{\morb(\elc), \morc(\ele)}}}
        }
    \end{equation}
    Notice that the operations $\cprod$ and $\tupconcat$ are associative; therefore, we can remove all the light parentheses that appear in the formulas.
    This implies that both functions are equal to
    \begin{equation}\label{eq:SetL-morphisms-associative-stack-check-3}
        \defmapperiod{
            \mora\mtimescatmor\morb\mtimescatmor\morc
        }{
            \setA \cprod \setC \cprod \setE
        }{
            \mtoin\SetL
        }{
            \setB \cprod \setD \cprod \setF
        }{
            \maketupconcat{\ela, \elc, \ele}
        }{
            \maketupconcat{\mora(\ela), \morb(\elc), \morc(\ele)}
        }
    \end{equation}
    % \begin{equation}
    %     \defmapperiod{
    %         \mtimescatob
    %     }{
    %         \Obof{\SetL} \cartprod \Obof{\SetL}
    %     }{
    %         \mto
    %     }{
    %         \Obof{\SetL}
    %     }{
    %         \tup{\cObj{\setAn{1},\ldots, \setAn{n}}, \cObj{\setBn{1},\ldots,\setBn{m}}}
    %     }{
    %         \cObj{\setAn{1},\ldots, \setAn{n}, \setBn{1},\ldots,\setBn{m}}
    %     }
    % \end{equation}
    % The stacking operation on morphisms is defined as
    % \begin{equation}
    %     \defmapcomma{
    %         \mtimescatmor
    %     }{
    %         \Mor_{\SetL} \cartprod \Mor_{\SetL}
    %     }{
    %         \mto
    %     }{
    %         \Mor_{\SetL}
    %     }{
    %         \tup{\mora,\morb}
    %     }{
    %         \mora \cprod \morb
    %     },
    % \end{equation}
    % where~$(\mora \cprod \morb)(\tup{\setAeln{1},\ldots, \setAeln{m}} \tupconcat \tup{\setBel_1,\ldots, \setBel_n})\definedas \mora(\tup{\setAeln{1},\ldots, \setAeln{m}})\tupconcat \morb(\tup{\setBel_1,\ldots, \setBel_n})$.
    % This is indeed a map between sets.
    % The two operations are compatible, because
    % \begin{widepar}
    %     \begin{equation}
    %         \prfperiod{
    %             \mora\colon \cObj{\setAn{1},\ldots,\setAn{n}}\mto \cObj{\setBn{1},\ldots,\setBn{m}}
    %         }{
    %             \morb\colon \cObj{\setCn{1},\ldots,\setCn{o}}\mto \cObj{\setDn{1},\ldots,\setDn{p}}
    %         }{
    %             \mora \mtimescatmor \morb \colon \cObj{\setAn{1}, \ldots, \setAn{n}, \setCn{1}, \ldots, \setCn{o}} \mto \cObj{\setBn{1}, \ldots, \setBn{m}, \setDn{1}, \ldots, \setDn{p}}
    %         }
    %     \end{equation}
    % \end{widepar}

    % We now show associativity.
    % We have already shown in \cref{sec:cartcatset} that~$\cprod$ satisfies the properties of a \SY{semigroup} operation.
    % For the operation on morphisms, consider
    % \begin{equation}
    %     \begin{aligned}
    %         \mora\colon \cObj{\setAn{1},\ldots,\setAn{m}} & \mto \cObj{\setBn{1}, \ldots, \setBn{n}}, \\
    %         \morb\colon \cObj{\setCn{1},\ldots,\setCn{o}} & \mto \cObj{\setDn{1},\ldots,\setDn{p}}, \\
    %         \morc\colon \cObj{\setEn{1},\ldots,\setEn{q}} & \mto \cObj{\setFn{1},\ldots,\setFn{r}},
    %     \end{aligned}
    % \end{equation}
    % For brevity, we write~$\setAeln{}=\tup{\setAeln{1},\ldots, \setAeln{m}}$,~$\setCeln{}=\tup{\setCeln{1},\ldots, \setCeln{o}}$, and~$\setEeln{}=\tup{\setEeln{1},\ldots,\setEeln{q}}$.
    % We have
    % \begin{align}
    %     ((\mora \cprod \morb)\cprod \morc)(\tup{\setAeln{}, \setCeln{},\setEeln{}})
    %      & =(\mora(\setAeln{})\tupconcat \morb(\setCeln{}))\tupconcat \morc(\setEeln{}) \\
    %      & =\mora(\setAeln{})\tupconcat \morb(\setCeln{})\tupconcat \morc(\setEeln{}) \\
    %      & =\mora(\setAeln{})\tupconcat (\morb(\setCeln{})\tupconcat \morc(\setEeln{})) \\
    %      & =(\mora \cprod (\morb\cprod \morc))(\tup{\setAeln{}, \setCeln{},\setEeln{}})
    % \end{align}
    % for all~$\tup{\setAeln{}, \setCeln{},\setEeln{}}\setin \cObj{\setAn{1},\ldots,\setAn{m},\setCn{1},\ldots,\setCn{o},\setEn{1},\ldots,\setEn{q}}$.

\end{proof}

% \begin{comment}
% \todotext{The example below is perhaps deprecated if we no longer use Set* as a main character in our story}

% \begin{example}
%     \SetL is an  \SY{associative stacking} semicategory.
%     We first show that it is a stacking category.
%     The stacking operation on objects is defined as list concatenation:
%     \begin{equation}
%         \defmapperiod{\mtimescatob}{\Ob_{\SetL} \cartprod \Ob_{\SetL}}{\mto}{\Ob_{\SetL}}{\tup{\Tupcatt{\setAn{1}}{\ldots}{ \setAn{n}}, \Tupcatt{\setBn{1}}{\ldots}{\setBn{m}}}}{\Tupcatt{\setAn{1}}{\ldots}{\setAn{n}} \listconcat \Tupcatt{\setBn{1}}{\ldots}{\setBn{m}}}
%     \end{equation}
%     The stacking operation on morphisms is defined as
%     \begin{equation}
%         \defmapperiod{\mtimescatmor}{\Mor_{\SetL} \cartprod \Mor_{\SetL}}{\mto}{\Mor_{\SetL}}{\tup{\mora,\morb}}{\more},
%     \end{equation}
%     which, given~$\mora\colon \Tupcatt{\setAn{1}}{\ldots}{\setAn{n}}\mto \Tupcatt{\setBn{1}}{\ldots}{\setBn{m}}$ (given by a map~$\mapc$) and~$\Tupcatt{\setCn{1}}{\ldots}{\setCn{o}}\mto \Tupcatt{\setDn{1}}{\ldots}{\setDn{p}}$ (given by a map~$\mapd$) is given by a function
%     \begin{equation}
%         \mape \definedas \cohm_{\setA,\setC}\then (\mapc\funcprod \mapd) \then \cohm_{\setB,\setD},
%     \end{equation}
%     which has signature
%     \begin{widepar}
%         \begin{equation}
%             \setAn{1}\cartprod (\setA_2\cartprod (\ldots \cartprod (\setAn{n} \cartprod (\setCn{1} \cartprod(\setC_2 \cartprod (\ldots \cartprod \setCn{o}))))))
%             \to
%             \setBn{1}\cartprod (\setB_2\cartprod (\ldots \cartprod (\setBn{m} \cartprod (\setDn{1} \cartprod (\setD_2 \cartprod(\ldots \cartprod \setDn{p})))))).
%         \end{equation}
%     \end{widepar}
%     The two operations are compatible, because
%     \begin{widepar}
%         \begin{equation}
%             \prfperiod{\mora\colon \Tupcatt{\setAn{1}}{\ldots}{\setAn{n}}\mto \Tupcatt{\setBn{1}}{\ldots}{\setBn{m}}}
%             {\morb\colon \Tupcatt{\setCn{1}}{\ldots}{\setCn{o}}\mto \Tupcatt{\setDn{1}}{\ldots}{\setDn{p}}}
%             {\more\colon \Tupca{\setAn{1}\setconcat \ldots \setconcat \setAn{n} \setconcat \setCn{1} \setconcat \ldots \setconcat \setCn{o}} \mto \Tupca{\setBn{1}\setconcat \ldots \setconcat \setBn{m} \setconcat \setDn{1} \setconcat \ldots \setconcat \setDn{p}}}
%         \end{equation}
%     \end{widepar}
%     Note that using the coherence morphisms is needed for the compatibility conditions to hold.

%     We now show associativity.
%     We have already shown in \cref{sec:semigroups} that the concatenation of lists satisfies the properties of a \SY{semigroup} operation.
%     Showing associativity of the operation on the morphisms is more cumbersome.
%     Consider morphisms
%     \begin{equation}
%         \begin{aligned}
%             \mora\colon \Tupcatt{\setAn{1}}{\ldots}{\setAn{m}} & \mto \Tupcatt{\setBn{1}}{\ldots}{\setBn{n}}, \\
%             \morb\colon \Tupcatt{\setCn{1}}{\ldots}{\setCn{o}} & \mto \Tupcatt{\setDn{1}}{\ldots}{\setDn{p}}, \\
%             \morc\colon \Tupcatt{\setEn{1}}{\ldots}{ \\setEn{q}} & \mto \Tupcatt{\\setFn{1}}{\ldots}{\\setFn{r}},
%         \end{aligned}
%     \end{equation}
%     to which maps~$\mapd,\mape,\mapf$ are associated.

%     We have:

%     \begin{center}
%         \begin{tikzpicture}
%             \node at (0,0){
%                 \begin{tikzcd}[every arrow/.append style={-Triangle, draw=morphisms}, column sep=large]
%                     (\mora \mtimescatmor \morb)
%                     \mtimescatmor \morc                                                                                                                                                                      & \mora \mtimescatmor (\morb \mtimescatmor \morc) \\
%                     \tupset{((\setLA \listconcat \setLC)\listconcat \setLE)}\arrow[d,"\cohm_{\setLA\listconcat \setLC, \setLE}^{-1}"]\arrow[r, equal]                                                        & \tupset{(\setLA \listconcat (\setLC\listconcat \setLE))}\arrow[d] \\
%                     \tupset{(\setLA\listconcat \setLC)}\cartprod \tupset{(\setLE)}\arrow[d, "\cohm_{\tupset{(\setLA)}, \tupset{(\setLC)}}^{-1} \funcprod \catid_{\tupset{(\setLC)}}"]                         & \tupset{(\setLA)}\cartprod \tupset{(\setLC \listconcat \setLE)}\arrow[d] \\
%                     (\tupset{(\setLA)}\cartprod \tupset{(\setLC)})\cartprod \tupset{(\setLE)}\arrow[r, "\alpha"]\arrow[d, "(\mapd \funcprod \mape)\funcprod \mapf"]                                          & \tupset{(\setLA)}\cartprod (\tupset{(\setLC)}\cartprod \tupset{(\setLE)})\arrow[d, "\mapd \funcprod (\mape\funcprod \mapf)"] \\
%                     (\tupset{(\setLB)}\cartprod \tupset{(\setLD)})\cartprod \tupset{(\setLF)}\arrow[r, "\alpha"]\arrow[d, "\cohm_{\tupset{(\setLB)}, \tupset{(\setLD)}}\funcprod \catid_{\tupset{(\setLF)}}"] & \tupset{(\setLB)}\cartprod (\tupset{(\setLD)}\cartprod \tupset{(\setLF)})\arrow[d] \\
%                     \tupset{(\setLB\listconcat \setLD)}\cartprod \tupset{(\setLF)}\arrow[d,"\cohm_{\setLB\listconcat \setLD, \setLF}"]                                                                       & \tupset{(\setLB)} \cartprod \tupset{(\setLD \listconcat\setLF)}\arrow[d] \\
%                     \tupset{((\setLB \listconcat \setLD)\listconcat \setLF)}\arrow[r, equal]                                                                                                                 & \tupset{(\setLB \listconcat (\setLD\listconcat \setLF))}
%                 \end{tikzcd}
%             };
%         \end{tikzpicture}
%     \end{center}
%     \todo{finish diagram above}
% \end{example}
% \end{comment}

%
%\begin{definition}
%    An  \SY{associative stacking} semicategory is called \emph{commutative} if its two stacking operations make the collections of objects and morphisms, respectively, into commutative semigroups.
%\end{definition}

\subsection{One-object associative stacking semicategories}

\todotext{Maybe remove this subsection? or move later when talk about functorial}
Consider a special kind of a stacking semicategory $\tup{\CatC, \mtimescatob, \mtimescatmor}$ where the semicategory $\CatC$ has only one object (call it $\Obja$, say).

In this special case, we have $\mtimescatob_{i=1}^n \Objan{i} = \Obja$ for any $n \setin \natnumbers$.
The only hom-set is $\Hom_\CatC(\Obja, \Obja)$ and this is equipped with the stacking operation
\begin{equation}
    \mtimescatmor \colon \Hom_\CatC(\Obja, \Obja) \cartprod \Hom_\CatC(\Obja, \Obja) \to \Hom_\CatC(\Obja, \Obja)
\end{equation}
which makes $\Hom_\CatC(\Obja, \Obja)$ into a semigroup.
In other words, this means that an associative stacking semicategory with one object may equivalently be described as set together with two operations -- serial composition and stacking -- that equip said set with two semigroup structures.

\begin{example}
    The integers $\wnumbers$, equipped with addition and multiplication as serial composition and stacking respectively, specify an associative stacking category with one object.
    Alternatively, we may also choose multiplication as our serial composition, and addition as our stacking.
\end{example}

\subsection{The \SY{semicategory} \Effects}

We now construct a non-trivial \SY{semicategory} that will serve as an example of a stacking \SY{semicategory} that is associative but, as we will show later, is not functorial.

There are two types of computation: ``functional'', or ``pure'', or free of side effects, and \emph{effectful}.
In functional programming, functions are very much like mathematical functions: they need an input and produce and output.
They don't interfere with other functions.

Effectful procedures, instead, can ``change the world'': for example, printing a page, sending an email, or placing an order of pizza.
The order in which effectful procedures are evaluated might change the result.
For example, the result of the sequence of operations
%
\begin{enumerate}
    \item Order a pizza;
    \item Cancel the last order;
\end{enumerate}
%
is different from the result of the sequence of operations
%
\begin{enumerate}
    \item Cancel the last order;
    \item Order a pizza;
\end{enumerate}

A very elegant way to treat side effects mathematically is using \emph{linear types}~\cite{Wadler90lineartypes}.
We will mention those in a successive part on linear logic.
For now, we stick to a simple treatment.

\begin{marginfigure}
    \centering
    \subfloat[\label{fig:effects1}
        A morphism~$\mora\colon \Obja \mtoin{\Effects} \Objb$ in \Effects.
    ]{
        \rule{1cm}{0pt}\includesag{morphism_eff}\rule{1cm}{0pt}
    }\\
    \subfloat[\label{fig:effects2}
        Its representation in \SetL as a morphism
        $\repreff{\mora}\colon \cObj{\Obja,\EfW} \mtoin{\SetL} \cObj{\Objb, \EfW}$.
    ]{
        \rule{1cm}{0pt}\includesag{morphism_tup}\rule{1cm}{0pt}
    }
    \caption{}
    \label{fig:effects12}
\end{marginfigure}

We are going to define a category \Effects.
The idea is to add another variable that represents ``the world'' that can be affected.
An effectful function
%
\begin{equation}\label{eq:Eff-morphism}
    \mora\colon \Obja \mtoin{\Effects} \Objb,
\end{equation}
%
which could have some unknown side effects on the world, can be represented by a pure function
\begin{equation}
    \repreff{\mora}\colon \Obja \cartprod \EfW \mtoin{\Set} \Objb \cartprod \EfW,
\end{equation}\label{eq:Eff-rep-morphism-Set}
or, in other words, as a morphism
\begin{equation}\label{eq:Eff-rep-morphism-SetL}
    \repreff{\mora}\colon \cObj{\Obja,\EfW} \mtoin{\SetL} \cObj{\Objb, \EfW},
\end{equation}
%
where~$\EfW$ is the set of all possible worlds~(\cref{fig:effects12}).

The second input to~$\repreff{\mora}$ is the state of the world before the execution of the function.
The second output of~$\repreff{\mora}$ is the state of the world after the execution of the function.

We can now interconnect different effectful functions, with some precautions.
We cannot ``split the world'', by creating a function of type~$\EfW \to \EfW \cartprod \EfW$.
We will re-state this formally when we get to linear logic.

\begin{marginfigure}
    \centering
    \subfloat[\label{fig:effects3}
        Composition in \Effects.
    ]{
        \includesag{morphism_eff_comp}
        %\includegraphics[width=4.5cm]{effects3}
    }\\
    \subfloat[\label{fig:effects3b}
        Its representation in \SetL.
    ]{
        \includesag{morphism_tup_comp}
        %\includegraphics[width=4.5cm]{effects3b}
    }
    \caption{}
    \label{fig:effect-composition}
\end{marginfigure}

We can extend usual function composition to composition of effectful functions as in~\cref{fig:effect-composition}.
The second effectful function operates on the world after it was possibly modified by the first effectful function.

We have all the ingredients to define the category \Effects of effectful computation.

\begin{definition}[Category of effectful procedures \Effects]
    \SYNDEF{category of sets and functions with side effects}
    \label{def:Effects}
    Fix a set~$\EfW$ of all possible worlds.
    The category~$\Effects$ is defined by the following:
    \begin{itemize}
        \item \emph{Objects}: same as the objects of \SetL;
        \item \emph{Morphisms}: a morphism~$\mora\colon \Obja \mtoin{\Effects} \Objb$ is a morphism
              \begin{equation}
                  \repreff{\mora}\colon \cObj{\Obja, \EfW} \mtoin{\SetL} \cObj{\Objb, \EfW}.
              \end{equation}
        \item \emph{Composition}: The composition of~$\mora\colon \Obja \mtoin{\Effects} \Objb$ and~$\morb\colon \Objb \mtoin{\Effects} \Objc$ is the morphism~$\morab\colon \Obja \mtoin{\Effects} \Objc$ with~$\repreff{\morab}$ given by
              \begin{equation}
                  \repreff{\mora \mthenof \Effects \morb}
                  = \repreff{\mora} \mthenof{\SetL} \repreff{\morb}
              \end{equation}
              as illustrated in \cref{fig:effect-composition}.
    \end{itemize}
\end{definition}

\begin{marginfigure}
    \centering
    \subfloat[\label{fig:effects4}
        Stacking in \Effects]{
        \includesag{stacking_eff}
        %\includegraphics[width=4.5cm]{effects4}
    }

    \subfloat[\label{fig:effects5} Its representation in \SetL]{
        %\includegraphics[width=4.5cm]{effects5}
        \includesag{stacking_tup}
    }
    \caption{}
    \label{fig:effect-stacking}
\end{marginfigure}

We can now make \Effects into a stacking \SY{semicategory} by deciding how to evaluate a stack of functions.
We cannot evaluate them in parallel.
We need to decide on a sequence.
For example, top to bottom.
This is shown in~\cref{fig:effect-stacking}.

\begin{lemma}
    \label{lem:effects-is-stacking}
    \Effects is an  \SY{associative stacking} category using the evaluation rule as in~\cref{fig:effect-stacking}.
\end{lemma}

\todotextjira{415}{\bernina: @Andrea: proof.
    Need to show \SY{semigroup}.
}

\section{Examples of associative stacking \SY{semicategories}}

\subsection{\Moore is associative stacking}
When considering Moore machines, we can define stacking operations and show that \Moore forms a stacking \SY{semicategory} (\cref{def:simple-stacking-semi-cat}).
The objects of \Moore are objects of \SetL, and therefore the stacking operation for objects corresponds to the ``multiplication in \SetL'', denoted by $\cprod$.

The operation on morphisms ``stacks'' Moore machines onto each other.
Formally:

\begin{equation}\label{eq:moore-stacking-prftree}
    \prfcomma{\mora\colon \prin_\mora \mtoin{\Moore} \prout_\mora}{\mora\colon \prin_\morb \mtoin{\Moore} \prout_\morb}
    {\mora \mtimescatmor \morb=\tup{\prin_\mora \cprod \prin_\morb, \prst_\mora \cprod \prst_\morb,\prout_\mora \cprod \prout_\morb, \prdyn_{\mora \mtimescatmor \morb},\prreadout_{\mora \mtimescatmor \morb}, \prstart_\mora \tupconcat \prstart_\morb}}
\end{equation}
with
\begin{equation*}\label{eq:moore-stacking-dyn}
    \defmapcomma{\prdyn_{\mora \mtimescatmor \morb}}{\prin_\mora \cprod \prin_\morb \cprod \prst_\mora \cprod \prst_\morb}
    {\sto}{\prst_\mora \cprod \prst_\morb}{\prinel_\mora \tupconcat \prinel_\morb \tupconcat \prstel_\mora \tupconcat \prstel_\morb}
    {\prdyn_\mora(\prinel_\mora \tupconcat \prstel_\mora)\tupconcat \prdyn_\morb(\prinel_\morb \tupconcat \prstel_\morb)}
\end{equation*}
and
\begin{equation*}\label{eq:moore-stacking-ro}
    \defmapperiod{\prreadout_{\mora \mtimescatmor \morb}}
    {\prst_\mora \cprod \prst_\morb}{\sto}{\prout_\mora \cprod \prout_\morb}
    {\prstel_\mora \tupconcat \prstel_\morb}{\prreadout(\prstel_\mora)\tupconcat \prreadout(\prstel_\morb)}
\end{equation*}
While we have already proved that the operation $\cprod$ is associative, it is also easy to see that the stacking of Moore machines is associative.
Therefore, \Moore equipped with the described stacking operations forms an \SY{associative stacking} \SY{semicategory}.

\subsection{LTI is associative stacking}
When considering LTI systems, we can define stacking operations and show that \LTI forms a stacking \SY{semicategory} (\cref{def:simple-stacking-semi-cat}).
The stacking operation on objects is just addition on the natural numbers:
\begin{equation}\label{eq:LTI-stacking-objects}
    \defmapperiod{
        \mtimescatob
    }{
        \Obof\LTI \cartprod \Obof\LTI
    }{
        \to
    }{
        \Obof\LTI
    }{
        \tup{\styleobj{l},\styleobj{m}}
    }{
        \styleobj{l}+\styleobj{m}
    }
\end{equation}
On the other hand, the operation on morphisms ``stacks'' the LTI systems onto each other\footnote{For the control engineers out there: the resulting LTI system will have a Relative Gain Array (RGA) matrix corresponding to the identity matrix.
}.
Formally:
\begin{equation}\label{eq:LTI-stacking-prftree}
    \prfperiod{
        \mora \colon \styleobj{l}\mtoin\LTI \styleobj{m}
    }{
        \morb \colon \styleobj{n}\mtoin\LTI \styleobj{o}
    }{
        \mora\mtimescatmor\morb = \genericlti{} \colon
        \styleobj{l+n}\mtoin\LTI \styleobj{m+o}
    }
\end{equation}
% \begin{equation}
%     \defmapcomma{
%         \mtimescatmor
%     }{
%         \Mor_\LTI \cartprod \Mor_\LTI
%     }{
%         \to
%     }{
%         \Mor_\LTI
%     }{
%         \tup{\genericlti{\mora},\genericlti{\morb}}
%     }{
%         \genericlti{}
%     }
% \end{equation}
with
\begin{equation}\label{eq:LTI-stacking-mor1}
    \prstart=\begin{bmatrix}
        \prstart_\mora \\
        \prstart_\morb
    \end{bmatrix},\
    \mat{A}=\begin{bmatrix}
        \mat{A}_\mora & \mat{0}       \\
        \mat{0}       & \mat{A}_\morb
    \end{bmatrix},\
    \mat{B}=\begin{bmatrix}
        \mat{B}_\mora & \mat{0}       \\
        \mat{0}       & \mat{B}_\morb
    \end{bmatrix},
    %  \
    % \mat{B}=\begin{bmatrix}
    %     \mat{B}_\mora & \mat{0}       \\
    %     \mat{0}       & \mat{B}_\morb
    % \end{bmatrix},\
    % \mat{C}=\begin{bmatrix}
    %     \mat{C}_\mora & \mat{0}       \\
    %     \mat{0}       & \mat{C}_\morb
    % \end{bmatrix},\
    % \mat{D}=\begin{bmatrix}
    %     \mat{D}_\mora & \mat{0}       \\
    %     \mat{0}       & \mat{D}_\morb
    % \end{bmatrix}
\end{equation}
\begin{equation}\label{eq:LTI-stacking-mor2}
    % \prstart=\begin{bmatrix}
    %     \prstart_\mora \\
    %     \prstart_\morb
    % \end{bmatrix},\
    % \mat{A}=\begin{bmatrix}
    %     \mat{A}_\mora & \mat{0}       \\
    %     \mat{0}       & \mat{A}_\morb
    % \end{bmatrix}, \
    % \mat{B}=\begin{bmatrix}
    %     \mat{B}_\mora & \mat{0}       \\
    %     \mat{0}       & \mat{B}_\morb
    % \end{bmatrix},\
    \mat{C}=\begin{bmatrix}
        \mat{C}_\mora & \mat{0}       \\
        \mat{0}       & \mat{C}_\morb
    \end{bmatrix},\
    \mat{D}=\begin{bmatrix}
        \mat{D}_\mora & \mat{0}       \\
        \mat{0}       & \mat{D}_\morb
    \end{bmatrix}
\end{equation}

% Clearly, the morphism given by~$\genericlti{}$ satisfies the compatibility condition for stacking semicategories:
% if~$\genericlti{\mora}$ is~$\styleobj{l}\mto \styleobj{m}$ and~$\genericlti{\morb}$ is~$\styleobj{n}\mto \styleobj{o}$,~$\genericlti{}$ is~$\styleobj{l}+\styleobj{n}\mto \styleobj{m}+\styleobj{o}$.
Given that the resulting LTI system is described by diagonal block matrices, it is evident that the defined operations are \SY{associative}, and therefore \LTI is an \SY{associative stacking} \SY{semicategory}.

\begin{gradedexercise}[\exname{StackingLTI}]
    \label{ex:StackingLTI}

    Consider the category of finite-dimensional linear time-invariant systems defined in \linkifexists{def:LTICat} with the stacking defined above.

    Your task:
    supposing that morphisms~$\mora\colon \styleobj{l}\mto \styleobj{m}$,~$\morc\colon \styleobj{m}\mto \styleobj{n}$,~$\morb\colon \styleobj{o}\mto \styleobj{p}$,~$\mord\colon \styleobj{p}\mto \styleobj{q}$ are given, compute the matrices
    \begin{equation}
        \mat{A}_{(\mora \mthen \morc)\mtimescatmor (\morb\mthen \mord)}
    \end{equation}
    and
    \begin{equation}
        \mat{A}_{(\mora\mtimescatmor \morb)\mthen (\morc\mtimescatmor \mord)}
    \end{equation}
    associated with the morphisms $(\mora \mthen \morc)\mtimescatmor (\morb\mthen \mord)$ and $(\mora\mtimescatmor \morb)\mthen (\morc\mtimescatmor \mord)$, respectively.
\end{gradedexercise}

\solutionof{StackingLTI}
