% !TEX root = chapter-standalone.tex

\section{Parallel stacking}
\label{sec:parallel-stacking}

So far we have seen how we can compose morphisms ``horizontally``:
%
\begin{equation}
    \prfperiod{
        \mora \colon \Obja \mto \Objb
    }{
        \morb\colon \Objb \mto \Objc
    }{
        \mora \mthen \morb \colon \Obja \mto \Objc
    }
\end{equation}
%
There are other notions of composition that allow us to compose morphisms by ``stacking them vertically``.
Given two morphisms
%
\begin{align}
    \mora & \colon \Obja \mto \Objb, \\
    \morb & \colon \Objc \mto \Objd,
\end{align}
%
we will obtain by parallel stacking a morphism
%
\begin{align}
    (\mora\mtimescat \morb)
     & \colon (\Obja \mtimescat \Objc) \mto (\Objb \mtimescat \Objd),
\end{align}
%
where ``$\mtimescat$`` is a stacking operation to be defined.
Note that while in the case of sequential composition there was a compatibility condition to be defined, as the target of the first morphism must be the source of the secon morphism, here instead we can stack arbitrary morphisms.

We also expect to be able to stack any number of morphisms.
Having a collection of morphisms
%
\begin{equation}
    \mora_i \colon \Obja_i \mto \Objb_i, \qquad 1 \leq i \leq n,
\end{equation}
%
we expect to be able to obtain the composed morphism
%
\begin{equation}
    (\mtimescat_{i=1}^n  \mora_i )
    \colon( \mtimescat_{i=1}^n  \Obja_i )\mto (\mtimescat_{i=1}^n  \Objb_i).
\end{equation}

\subsection{Types of stacking operations}

There are various properties that one can consider for this stacking operation.
The ones that that we will consider in this chapter are:
%
\begin{enumerate}
    \item \emph{Stacking semicategory} (\cref{def:stacking-semi-cat}): a semicategory in which  it is possible to stack two morphisms.
    \item \emph{Associative stacking semicategory} (\cref{def:stacking-semi-cat}): a semicategory in which the stacking operation is associative and makes objects and morphisms into a semigroup.
    \item \emph{Functorial stacking semicategory} (\cref{def:functorial-stacking-semi-cat}): a stacking semicategory in which the stacking operation is also a functor.
    \item \emph{Symmetric stacking semicategory}: a stacking semicategory in which there is a series of symmetry isomorphisms that can permute the objects in a stack.
\end{enumerate}
%
In the next part we will talk about \emph{monoidal categories} (\cref{def:monoidal-cat}), which can be seen as a generalization of associative stacking semicategories where the stacking operation is not required to be associative ``on the nose'', but rather only up to isomorphism.

\begin{remark}
    [Choices in definitions~$\star$]
    Of all these definitions, the only `classical' one is that of \emph{monoidal category}, and its specializations, such as strict monoidal category, braided monoidal category, and symetric monoidal category.
    We will look at all of those in~\cref{sec:parallelism-mon-cat}.

    We define the three non-classical notions mentioned above for the following reasons:
    \begin{itemize}
        \item Using the strictification construction of \SetL most of the monoidal categories are strict; we can ask that the composition induces semigroups of morphisms.
              We will not need to define unitors and associators.
              In fact, we do not need to define natural transformations.
              \todojira{641}{J: I'm not understanding what this comment is trying to say.}
        \item There are important cases of semicategories without identities with a stacking operation that do not fit the notion of monoidal category.
              An example is discrete-time linear systems.
              For these categories we also want to consider appropriate traces.
        \item There are important examples in which there is a way to stack morphisms but the stacking is not functorial.
              For example, we will describe a category of effectful computation with side effects.
    \end{itemize}
\end{remark}

\subsection{Stacking semicategories}

\begin{ctdefinition}[Stacking semicategory]
    \label{def:simple-stacking-semi-cat}
    A stacking semicategory is a semicategory~$\CatC$ with the following additional constituents and properties.

    \constit
    \begin{itemize}
        \item A stacking operation~$\mtimescatob \colon \Ob_\CatC \cartprod \Ob_\CatC \to \Ob_\CatC$.
        \item A stacking operation~$\mtimescatmor \colon \Mor_\CatC \cartprod \Mor_\CatC \to \Mor_\CatC$.
    \end{itemize}

    \condit
    \begin{itemize}
        \item The two operations~$\mtimescatob$ and~$\mtimescatmor$ are compatible in the sense that
              %
              \begin{equation}
                  \prfperiod{
                      \mora_1 \colon \Obja_1 \mto \Objb_1
                      \qquad
                      \mora_2 \colon \Obja_2 \mto \Objb_2
                  }{
                      \mora_1 \mtimescatmor \mora_2 \colon  \Obja_1 \mtimescatob  \Obja_2 \mto \Objb_1 \mtimescatob \Objb_2.
                  }
              \end{equation}
    \end{itemize}
\end{ctdefinition}

\begin{ctdefinition}[Associative stacking semicategory]
    \label{def:stacking-semi-cat}
    An associative stacking semicategory is a stacking semicategory satisfying the following.

    \condit
    \begin{itemize}
        \item The stacking operation~$\mtimescatob$ makes the objects into a semigroup.
        \item The stacking operation~$\mtimescatmor$ makes the morphisms into a semigroup.
    \end{itemize}
\end{ctdefinition}

\begin{remark}
    In an associative stacking semicategory it follows that we can stack any number of morphisms without needing to bracket using parentheses:
    \begin{equation}
        \prfperiod{
            \mora_i \colon \Obja_i \mto \Objb_i, \qquad 1 \leq i \leq n,
        }{
            \mtimescatmor_{i=1}^n \mora_i \colon  \mtimescatob_{i=1}^n \Obja_i \mto \mtimescatob_{i=1}^n \Objb_i.
        }
    \end{equation}
\end{remark}

\devel{
\begin{example}
    \SetL  is an associative stacking semicategory.
    We first show that is is a stacking category.
    The stacking operation on objects is defined as list concatenation:
    \begin{equation*}
    \defmapperiod{\mtimescatob}{\Ob_{\SetL} \cartprod \Ob_{\SetL}}{\mto}{\Ob_{\SetL}}{\tup{\Tupcatt{\setA_1}{\ldots}{ \setA_n}, \Tupcatt{\setB_1}{\ldots}{\setB_m}}}{\Tupcatt{\setA_1}{\ldots}{\setA_n} \listconcat \Tupcatt{\setB_1}{\ldots}{\setB_m}}
    \end{equation*}
    The stacking operation on morphisms is defined as
    \begin{equation*}
    \defmapperiod{\mtimescatmor}{\Mor_{\SetL} \cartprod \Mor_{\SetL}}{\mto}{\Mor_{\SetL}}{\tup{\mora,\morb}}{\more},
    \end{equation*}
    which, given~$\mora\colon \Tupcatt{\setA_1}{\ldots}{\setA_n}\mto \Tupcatt{\setB_1}{\ldots}{\setB_m}$ (given by a map~$\mapc$) and~$\Tupcatt{\setC_1}{\ldots}{\setC_o}\mto \Tupcatt{\setD_1}{\ldots}{\setD_p}$ (given by a map~$\mapd$) is given by a function
    \begin{equation*}
        \mape \definedas \cohm_{\setA,\setC}\then (\mapc\funcprod \mapd) \then \cohm_{\setB,\setD},
    \end{equation*}
    which has signature
    \begin{widepar}
    \begin{equation*}
    \setA_1\cartprod (\setA_2\cartprod (\ldots \cartprod (\setA_n \cartprod (\setC_1 \cartprod(\setC_2 \cartprod (\ldots \cartprod \setC_o))))))
    \to
    \setB_1\cartprod (\setB_2\cartprod (\ldots \cartprod (\setB_m \cartprod (\setD_1 \cartprod (\setD_2 \cartprod(\ldots \cartprod \setD_p)))))).
    \end{equation*}
    \end{widepar}
    The two operations are compatible, because
    \begin{widepar}
    \begin{equation*}
    \prfperiod{\mora\colon \Tupcatt{\setA_1}{\ldots}{\setA_n}\mto \Tupcatt{\setB_1}{\ldots}{\setB_m}}
    {\morb\colon \Tupcatt{\setC_1}{\ldots}{\setC_o}\mto \Tupcatt{\setD_1}{\ldots}{\setD_p}}
    {\more\colon \Tupca{\setA_1\setconcat \ldots \setconcat \setA_n \setconcat \setC_1 \setconcat \ldots \setconcat \setC_o} \mto \Tupca{\setB_1\setconcat \ldots \setconcat \setB_m \setconcat \setD_1 \setconcat \ldots \setconcat \setD_p}}
    \end{equation*}
    \end{widepar}
    Note that using the coherence morphisms, introduced in \cref{sec:SetL}, is needed for the compatibility conditions to hold. 

    We now show associativity. 
    We have already shown in \cref{sec:semigroups} that the concatenation of lists satisfies the properties of a semigroup operation.
    Showing associativity of the operation on the morphisms is more cumbersome.
    Consider morphisms
    \begin{equation*}
    \begin{aligned}
        \mora\colon \Tupcatt{\setA_1}{\ldots}{\setA_m}&\mto \Tupcatt{\setB_1}{\ldots}{\setB_n},\\
        \morb\colon \Tupcatt{\setC_1}{\ldots}{\setC_o}&\mto \Tupcatt{\setD_1}{\ldots}{\setD_p},\\
        \morc\colon \Tupcatt{\setE_1}{\ldots}{\setE_q}&\mto \Tupcatt{\setF_1}{\ldots}{\setF_r},
    \end{aligned}    
    \end{equation*}
    to which maps~$\mapd,\mape,\mapf$ are associated.
    We first look at the map associated to~$(\mora \mtimescatmor \morb)\mtimescatmor \morc$.
    We know that the map associated to~$\mora \mtimescatmor \morb$ is
    \begin{equation*}
        \cohm_{\setA,\setC}\then (\mapd\funcprod \mape) \then \cohm_{\setB,\setD},
    \end{equation*}
    and therefore the map associated to~$(\mora \mtimescatmor \morb)\mtimescatmor \morc$ is
    \begin{equation*}
        \cohm_{\setA\listconcat\setC, \setE}\then ((\cohm_{\setA,\setC}\then (\mapd\funcprod \mape) \then \cohm_{\setB,\setD})\funcprod \mapf) \then \cohm_{\setB\listconcat \setD, \setF},
    \end{equation*}
    We then look at the map associated to~$\mora (\mtimescatmor \morb\mtimescatmor \morc)$.
    We know that the map associated to~$\morb \mtimescatmor \morc$ is
    \begin{equation}
        \label{eq:assoc_listconcat_a}
        \cohm_{\setC,\setE}\then (\mape\funcprod \mapf) \then \cohm_{\setD,\setF},
    \end{equation}
    and therefore the map associated to~$\mora \mtimescatmor (\morb\mtimescatmor \morc)$ is
    \begin{equation}
        \label{eq:assoc_listconcat_b}
        \cohm_{\setA, \setC\listconcat\setE}\then (\mapd \funcprod (\cohm_{\setC,\setE}\then (\mape\funcprod \mapf) \then \cohm_{\setD,\setF})) \then \cohm_{\setB, \setD\listconcat \setF}.
    \end{equation}
    \cref{eq:assoc_listconcat_a} and \cref{eq:assoc_listconcat_b} are equivalent.
    \todotext{Explictly show? Pretty long and heavy.}
\end{example}
}

\begin{definition}
    An associative stacking semicategory is called \emph{commutative} if its two stacking operations makes the collections of objects and morphisms, respectively, into commutative semigroups.
\end{definition}

\subsection{The semicategory \Effects}

Let's now construct a non-trivial semicategory that will serve as an example of a stacking semicategory that is not functorial.

There are two types of computation: ``functional'', or ``pure'', or free of side-effects, and \emph{effectful}.
In functional programming, functions are very much like mathematical functions: they need an input and produce and output.
They don't interfer with other functions.

Effectful procedures,  instead, can ``change the world'': for example, printing a page, sending an email, or placing an order of pizza.
The order in which effectful procedures are evaluated might change the result.
For example, the result of the sequence of operations
%
\begin{enumerate}
    \item Order a pizza;
    \item Cancel the last order.
\end{enumerate}
%
is different than the result of the sequence of operations
%
\begin{enumerate}
    \item Cancel the last order;
    \item Order a pizza.
\end{enumerate}

A very elegant way to treat side-effects mathematically is using \emph{linear types}~\cite{Wadler90lineartypes}.
We will mention those in a successive part on linear logic.
For now, let's have a simple treatment.

\begin{marginfigure}
    \centering
    \subfloat[\label{fig:effects1}
        A morphism~$\mora\colon \Obja \mtoin{\Effects} \Objb$ in \Effects.
    ]{
        \includesag{morphism_eff}
        %\includegraphics[width=4.5cm]{effects1}
    }\\
    \subfloat[\label{fig:effects2}
        Its representation in \SetL as a morphism
        $\mora_e\colon  \Tupcat \Obja   \EfW \mtoin{\SetL}   \Tupcat  \Objb \EfW.
        $]{
        \includesag{morphism_tup}
        %\includegraphics[width=4.5cm]{effects2}
    }
    \caption{}
    \label{fig:effects12}
\end{marginfigure}

We are going to define a category \Effects.
The idea is to add another variable that represents ``the world'' that can be affected.
An effectful function
%
\begin{equation}
    \mora\colon \Obja \mtoin{\Effects} \Objb,
\end{equation}
%
which could have some unknown side-effects on the world, can be represented by a pure function
\begin{equation}
    \mora_e\colon  \Obja  \times \EfW \mtoin{\Set}   \Objb \times \EfW,
\end{equation}
or, in other words, as a morphism
\begin{equation}
    \mora_e\colon  \Tupcat \Obja   \EfW \mtoin{\SetL}   \Tupcat  \Objb \EfW,
\end{equation}
%
where~$\EfW$ is the set of all possible worlds~(\cref{fig:effects12}).

The second input to~$\mora_e$ is the state of the world before the execution of the function.
The second output of~$\mora_e$ is the state of the world after the execution of the function.

We can now interconnect different effectful functions, with some precautions.
We cannot ``split the world'', by creating a function of type~$\EfW \to  \EfW \times \EfW$.
We will re-state this formally when we get to linear logic.

\begin{marginfigure}
    \centering
    \subfloat[\label{fig:effects3}
        Composition in \Effects.
    ]{
        \includesag{morphism_eff_comp}
        %\includegraphics[width=4.5cm]{effects3}
    }\\
    \subfloat[\label{fig:effects3b}
        Its representation in \SetL.
    ]{
        \includesag{morphism_tup_comp}
        %\includegraphics[width=4.5cm]{effects3b}
    }
    \caption{}
    \label{fig:effect-composition}
\end{marginfigure}

We can extend usual function composition to composition of effectful functions as in~\cref{fig:effect-composition}.
The second effectful function operates on the world after it was possibly modified by the first effectful function.

We have all the ingredients to define the category \Effects of effectful computation.

\begin{definition}[Category of effectful procedures \Effects]
    Fix a set ~$\EfW$ of all possible worlds.
    The category $\Effects=  \Effects_\EfW$ is defined by the following:
    \begin{itemize}
        \item \emph{Objects}: same as the objects of \SetL;
        \item \emph{Morphisms}: a morphism~$\mora\colon \Obja \mtoin{\Effects} \Objb$ is a morphism
              \begin{equation}
                  \mora_e\colon \Tupcat \Obja \EfW \mtoin{\SetL} \Tupcat \Objb \EfW.
              \end{equation}
        \item \emph{Composition}: The composition of~$\mora\colon \Obja \mtoin{\Effects} \Objb$ and~$\morb\colon \Objb \mtoin{\Effects} \Objc$ is the morphism~$\morab\colon \Obja \mtoin{\Effects} \Objb$ with~$(\morab)_e$ given by
              \begin{equation}
                  (\mora \mthenof \Effects \morb)
                  _e = \mora_e \mthenof\SetL \morb_e
              \end{equation}
              as illustrated in \cref{fig:effect-composition}.
    \end{itemize}
\end{definition}

We can now make \Effects into a stacking semicategory by deciding how to evaluate a stack of functions.
We cannot evaluate them in parallel.
We need to decide on a sequence.
For example, top to bottom.
This is shown in~\cref{fig:effect-stacking}.

\begin{lemma}
    \label{lem:effects-is-stacking}
    \Effects is an associative stacking category using the evaluation rule as in~\cref{fig:effect-stacking}.
\end{lemma}

\begin{figure}[h!]
    \centering
    \subfloat[\label{fig:effects4}
        Stacking in \Effects]{
        \includesag{stacking_eff}
        %\includegraphics[width=4.5cm]{effects4}
    }
    \subfloat[\label{fig:effects5} Its representation in \SetL]{
        %\includegraphics[width=4.5cm]{effects5}
        \includesag{stacking_tup}
    }
    \caption{}
    \label{fig:effect-stacking}
\end{figure}

\todotextjira{415}{proof.
    Need to show semigroup.
}

\section{Functorial stacking semicategory}

\begin{ctdefinition}[Functorial stacking semicategory]
    \label{def:functorial-stacking-semi-cat}
    A functorial stacking semicategory is a stacking semicategory where the two stacking operations~$\mtimescatob$ and~$\mtimescatmor$ are the two components of a semifunctor
    \begin{equation}
        \mtimescat\colon \CatC \times \CatC \to \CatC.
    \end{equation}
    Concretely, and in infix notation, this means that
    \begin{equation}
        (\mora \mthen \morc ) \mtimescat (\morb \mthen \mord )
        =
        (\mora \mtimescat \morb )
        \mthen (\morc \mtimescat \mord )
    \end{equation}
    for all morphisms $\mora, \morb, \morc$, and $\mord$ where respectively $\mora$ and $\morc$, and $\morb$ and $\mord$ are composable.
\end{ctdefinition}

%More in detail, we have that for any~$n \geq 2$, there is a semifunctor
%%
%\begin{equation}
%    \mtimescat^{(n)}\colon \underbrace {\CatC \times \CatC \times \cdots \times \CatC}_{\text{$n$ times}} \to \CatC.
%\end{equation}
%
This describes a sort of commutivity property: we can either first compose horizontally and then vertically, or viceversa, and we obtain the same morphism~(\cref{fig:stacking-functorial}).

\begin{figure*}[h]
    \centering
    \subfloat[\label{fig:effects6}$(\mora \mtimescat \morb )
            \mthen (\morc \mtimescat \mord )$]{
        %\includegraphics[width=6.5cm]{effects6}
        \includesag{commuting_stacking_eff}
    }=
    \subfloat[\label{fig:effects8}$(\mora \mthen \morc ) \mtimescat (\morb \mthen \mord )$]{
        \includesag{commuting_stacking_eff_bis}
        %\includegraphics[width=6.5cm]{effects8}
    }
    \caption{Commutation of stacking and composition in a functorial stacking semicategory. }
    \label{fig:stacking-functorial}
\end{figure*}

\begin{lemma}
    \SetL is a functorial stacking semicategory.
\end{lemma}

\todotext{J: for the above lemma, one first needs to discuss/say explicitly what the stacking operation is.}

\Effects is an example of a stacking category that is not functorial.

\begin{lemma}
    \Effects is \emph{not} a functorial stacking semicategory.
\end{lemma}

\begin{proof}
    This is shown graphically in \cref{fig:effects-non-functorial} by showing that, in general,
    \begin{equation}
        (\mora \mtimescat \morb )
        \mthen (\morc \mtimescat \mord )
        \neq
        (\mora \mthen \morc ) \mtimescat (\morb \mthen \mord ).
    \end{equation}
\end{proof}

\begin{figure*}[b]
    \centering
    \subfloat[\label{fig:effects7}$(\mora \mtimescat \morb )
            \mthen (\morc \mtimescat \mord )$]{
        %\includegraphics[width=6.5cm]{effects7}
        \includesag{stacking_tup_counterproof}
    }
    \subfloat[\label{fig:effects9} $(\mora \mthen \morc ) \mtimescat (\morb \mthen \mord )$]{
        %\includegraphics[width=6.5cm]{effects9}
        \includesag{stacking_tup_counterproof_bis}
    }
    \caption{Proof that \Effects is not a functorial stacking category by showing that
        the two morphisms above have different representations in \SetL.}
    \label{fig:effects-non-functorial}
\end{figure*}

\section{Symmetric stacking}

Let $\CatC$ be an associative stacking category, and consider morphisms
\begin{equation*}
    \mora \mtimescatmor \morb \colon \Obja \mtimescatob \Objb \mto \Objc \mtimescatob \Objd
\end{equation*}
and~
\begin{equation*}
    \morc \mtimescatmor \mord \colon \Objd \mtimescatob \Objc \mto \Objf \mtimescatob \Obje.
\end{equation*}
If $\Objc \mtimescatob \Objd \neq \Objd \mtimescatob \Objc$, then the morphisms $\mora \mtimescatmor \morb$ and $\morc \mtimescatmor \mord$ are, in our model, technically not composable.
However, in some examples, we will in fact want to be able to compose such morphisms, because in those cases $\Objc \mtimescatob \Objd$ and $\Objd \mtimescatob \Objc$ are essentially equal, even if they aren't equal on the nose.

For example, $\mora, \morb, \morc, \mord$ might be systems, represented graphically by boxes with wires for input and output.
The stacked system $\mora \mtimescatmor \morb$ will have output wires for $\Objc$ and $\Objd$, and the stacked system $\morc \mtimescatmor \mord$ will have input wires for $\Objd$ and $\Objc$.
In some applications we are often indeed able to connect the one output wire labeled with $\Objc$ to the input wire also labeled with $\Objc$, and similarly for $\Objd$.

To model this for stacking semicategories, we introduce operations that correspond to switching (or permuting) input and output wires.
Recall that, for each $n \setin \natnumbers$, the symmetric group $S_n$ is the group of bijections of the set $\{1, 2, .
    .., n \}$ with itself.

%Now consider a a stacking semicategory $\CatC$. For each natural number $n \geq 2$ and each permutation $\sigma \setin S_n$, we define an operation $P_\sigma: \Ob_\CatC \to \Ob_\CatC$ by
%\begin{equation}
%P_\sigma: \Obja_1 \mtimescatob \dots \mtimescatob  \Obja_n \mapsto \Obja_{\sigma(1)} \mtimescatob \dots \mtimescatob  \Obja_{\sigma(n)}
%\end{equation}

\begin{ctdefinition}[Symmetric stacking semicategory]
    \label{def:symmetric-stacking-category}
    A symmetric associative stacking semicategory is an associative stacking semicategory~$\CatC$ with:

    \constit

    \begin{itemize}
        \item Functions
              \begin{equation}
                  L_\sigma \colon \HomSet{\CatC}{\mtimescatob_{i=1}^n \Obja_i}{\mtimescatob_{i=1}^n \Objb_i} \to \HomSet{\CatC}{\mtimescatob_{i=1}^n \Obja_{\sigma(i)}}{\mtimescatob_{i=1}^n \Objb_i}
              \end{equation}
              and
              \begin{equation}
                  R_\sigma \colon \HomSet{\CatC}{\mtimescatob_{i=1}^n \Obja_i}{\mtimescatob_{i=1}^n \Objb_i} \to \HomSet{\CatC}{\mtimescatob_{i=1}^n \Obja_i}{\mtimescatob_{i=1}^n \Objb_{\sigma(i)}}
              \end{equation}
              for every~$\sigma \setin S_n$,~$n \geq 2$.
    \end{itemize}

    \condit

    \begin{itemize}
        \item The equations
              \begin{equation}
                  L_\sigma \then L_\pi = L_{\pi \then \sigma}
                  \quad \text{ and } \quad
                  R_\sigma \then R_\pi = R_{\sigma \then \pi}
              \end{equation}
              hold for all $\sigma, \pi \setin S_n$, $n \geq 2$.
        \item
              Given $\mora_i : \Obja_i \mto \Objb_i$, $1 \leq i \leq n$, it holds that
              \begin{equation}
                  R_\sigma ( \mtimescatmor_{i=1}^n \mora_i ) = L_\sigma(  \mtimescatmor_{i=1}^n \mora_{\sigma(i)} ).
              \end{equation}

    \end{itemize}
\end{ctdefinition}

%\begin{figure*}[b]
%    %\includegraphics[width=8cm]{symmetric}
%    \centering
%    \subfloat[]{
%        \includesag{symmetric_stacking}
%    }
%    \subfloat[]{
%        \includesag{symmetric_stacking_bis}
%    }
%    \caption{
%        Illustration of \cref{eq:symmetric-condition}.
%    }
%    \label{fig:stacking-symmetric}
%\end{figure*}

\begin{example}
    \SetL is symmetric in a straighforward manner.
\end{example}

\begin{lemma}
    \Effects is not symmetric.
\end{lemma}

\todographicsjira{431}{@Andrea: Add figure for this lemma, in the same style as \cref{fig:effects-non-functorial} }
