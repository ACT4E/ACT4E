% !TEX root = chapter-standalone.tex

\section{Parallel stacking}
\label{sec:parallel-stacking}

So far we have seen how we can compose morphisms ``horizontally'':
%
\begin{equation}
    \prfperiod{
        \mora \colon \Obja \mto \Objb
    }{
        \morb\colon \Objb \mto \Objc
    }{
        \morab \colon \Obja \mto \Objc
    }
\end{equation}
%
There are other notions of composition that allow us to compose morphisms by ``stacking them vertically''.
Given two morphisms
%
\begin{align}
    \mora & \colon \Obja \mto \Objb, \\
    \morb & \colon \Objc \mto \Objd,
\end{align}
%
we will obtain by parallel stacking a morphism
%
\begin{align}
    (\mora\mtimescatmor \morb)
     & \colon (\Obja \mtimescatob \Objc) \mto (\Objb \mtimescatob \Objd),
\end{align}
%
where ``$\mtimescat$'' is a stacking operation to be defined.
Note that while in the case of sequential composition there was a compatibility condition to be defined, as the target of the first morphism must be the source of the second morphism, here instead we can stack arbitrary morphisms.

We also expect to be able to stack any number of morphisms.
Having a collection of morphisms
%
\begin{equation}
    \moran{i} \colon \Objan{i} \mto \Objbn{i}, \qquad 1 \leq i \leq n,
\end{equation}
%
we expect to be able to obtain the composed morphism
%
\begin{equation}
    (\mtimescat_{i=1}^n \moran{i} )
    \colon( \mtimescat_{i=1}^n \Objan{i} )\mto (\mtimescat_{i=1}^n \Objbn{i}).
\end{equation}

\subsection{Types of stacking operations}

There are various properties that we can consider for this stacking operation.
The ones that we will consider in this chapter are:
%
\begin{enumerate}
    \item \emph{Stacking semicategory} (\cref{def:simple-stacking-semi-cat}): a \SY{semicategory} in which it is possible to stack two morphisms.
    \item \emph{Associative stacking semicategory} (\cref{def:stacking-semi-cat}): a \SY{semicategory} in which the stacking operation is \SY{associative} and makes objects and morphisms into a \SY{semigroup}.
    \item \emph{Functorial stacking semicategory} (\cref{def:functorial-stacking-semi-cat}): a stacking \SY{semicategory} in which the stacking operation is also a \SY{functor}.
    \item \emph{Symmetric stacking semicategory}: a stacking \SY{semicategory} in which there is a series of symmetry operations that can permute the objects in a stack.
\end{enumerate}
%
In the next part we will talk about \emph{monoidal categories} (\cref{def:monoidal-cat}), which can be seen as a generalization of \SY{associative stacking} \SY{semicategories} where the stacking operation is not required to be \SY{associative} ``on the nose'', but rather only up to isomorphism.

\begin{remark}
    [Choices in definitions~$\star$]
    Of all these definitions, the only ``classical'' one is that of \emph{monoidal category}, and its specializations, such as \SY{strict monoidal category}, \SY{braided monoidal category}, and \SY{symmetric monoidal category}.
    We will look at all of those in~\cref{sec:parallelism-mon-cat}.

    We define the three non-classical notions mentioned above for the following reasons:
    \begin{itemize}
        \item Using the strictification construction of \SetL all the \SY{monoidal categories} that we need through the book are strict.
              Therefore, we can study parallel and feedback composition without knowing \SY{natural transformations}.

        \item There are important cases of \SY{semicategories} without identities with a stacking operation that do not fit the notion of \SY{monoidal category}.
              An example is discrete-time linear systems.
              For these categories we also want to consider appropriate traces.
        \item There are important examples in which there is a way to stack morphisms, but the stacking is not functorial.
              For example, we will describe a category of effectful computation with side effects.
    \end{itemize}
\end{remark}

\subsection{Stacking semicategories}

\begin{ctdefinition}[Stacking semicategory]
    \label{def:simple-stacking-semi-cat}
    A \maindef{stacking semicategory} is a \SY{semicategory}~\CatC with the following additional constituents and properties.

    \constit
    \begin{itemize}
        \item A stacking operation~$\mtimescatob \colon \ObC \cartprod \ObC \to \ObC$.
        \item A stacking operation~$\mtimescatmor \colon \Mor_\CatC \cartprod \Mor_\CatC \to \Mor_\CatC$.
    \end{itemize}

    \condit
    \begin{itemize}
        \item The two operations~$\mtimescatob$ and~$\mtimescatmor$ are compatible in the sense that
              %
              \begin{equation}
                  \prfperiod{
                      \moran{1} \colon \Objan{1} \mto \Objbn{1}
                      \qquad
                      \moran{2} \colon \Objan{2} \mto \Objbn{2}
                  }{
                      \moran{1} \mtimescatmor \moran{2} \colon  \Objan{1} \mtimescatob  \Objan{2} \mto \Objbn{1} \mtimescatob \Objbn{2}
                  }
              \end{equation}
    \end{itemize}
\end{ctdefinition}

In \cref{fig:stacked-morphisms} we have depicted a string diagram of two stacked morphisms.
Alternatively, in \cref{fig:stacked-morphisms-diagram} we depict the stacking of the string diagrams for $\moran{1}$ and $\moran{2}$, respectively, by stacking their diagrams vertically and drawing a box around them, merging their respective input and output terminals.
The outer box denotes $\moran{1} \mtimescatmor \moran{2}$; we think of \cref{fig:stacked-morphisms} as a ``black-boxed'' version of \cref{fig:stacked-morphisms-diagram}.

\begin{marginfigure}
    \centering
    \includegraphics[scale=0.12]{parallelism_stacked-morphisms}
    \caption{Stacked morphisms}
    \label{fig:stacked-morphisms}
\end{marginfigure}

\begin{marginfigure}
    \centering
    \includegraphics[scale=0.17]{parallelism_stacked-morphisms-diagram}
    \caption{Stacking string diagrams}
    \label{fig:stacked-morphisms-diagram}
\end{marginfigure}

\begin{marginfigure}[]
    \centering
    \includegraphics[scale=0.15]{parallelism_associative-stacking-1}
    \caption{One way of stacking three morphisms}
    \label{fig:associative-stacking-1}
\end{marginfigure}

\begin{marginfigure}
    \centering
    \includegraphics[scale=0.15]{parallelism_associative-stacking-2}
    \caption{Another way of stacking three morphisms}
    \label{fig:associative-stacking-2}
\end{marginfigure}

\begin{ctdefinition}[Associative stacking semicategory]
    \label{def:stacking-semi-cat}
    An \maindef{associative stacking semicategory} is a \SY{stacking semicategory} satisfying the following.

    \condit
    \begin{itemize}
        \item The stacking operation~$\mtimescatob$ makes the objects into a \SY{semigroup}.
        \item The stacking operation~$\mtimescatmor$ makes the morphisms into a \SY{semigroup}.
    \end{itemize}
\end{ctdefinition}

If a \SY{semicategory} is \SY{associative stacking}, then the two ways of stacking three morphisms -- as depicted in \cref{fig:associative-stacking-1} and \cref{fig:associative-stacking-2}, respectively -- give the same result.
For \SY{associative stacking} \SY{semicategories} we will use a simpler diagrammatic notation, where the diagrams in \cref{fig:associative-stacking-1} and \cref{fig:associative-stacking-2} instead look like the ones in \cref{fig:associative-stacking-1-new} and \cref{fig:associative-stacking-2-new}.
Since these two diagrams depict that same morphism, when it is convenient we will also simply depict them as in \cref{fig:triple-stacked} (and similarly for any number of stacked morphisms).
In particular, in an \SY{associative stacking} \SY{semicategory}, and stacking of two morphisms will be depicted as in \cref{fig:double-stacked-new}.

\begin{marginfigure}[]
    \centering
    \includegraphics[scale=0.15]{parallelism_associative-stacking-1-new}
    \caption{Associative stacking of three morphisms, in one order.}
    \label{fig:associative-stacking-1-new}
\end{marginfigure}

\begin{marginfigure}
    \centering
    \includegraphics[scale=0.15]{parallelism_associative-stacking-2-new}
    \caption{Associative stacking of three morphisms, in another order.}
    \label{fig:associative-stacking-2-new}
\end{marginfigure}

\begin{marginfigure}
    \centering
    \includegraphics[scale=0.15]{parallelism_triple-stacked}
    \caption{Our string diagram notation for a triple stack.}
    \label{fig:triple-stacked}
\end{marginfigure}

\begin{figure}[h!]
    \centering
    \includegraphics[scale=0.15]{parallelism_associative-stacking-two-new}
    \caption{Associative stacking of two morphisms.}
    \label{fig:double-stacked-new}
\end{figure}

\begin{remark}
    In an \SY{associative stacking} \SY{semicategory} it follows that we can stack any number of morphisms without needing to bracket using parentheses:
    \begin{equation}
        \prfperiod{
            \moran{i} \colon \Objan{i} \mto \Objbn{i}, \qquad 1 \leq i \leq n,
        }{
            \mtimescatmor_{i=1}^n \moran{i} \colon \mtimescatob_{i=1}^n \Objan{i} \mto \mtimescatob_{i=1}^n \Objbn{i}.
        }
    \end{equation}
\end{remark}
\clearpage
\begin{lemma}
    \label{lem:SetL-is-associative-stacking}
    \SetL is  \SY{associative stacking} using the structure that arises from tuple concatenation.
    % by setting $\mtimescatob_{\SetL} \definedas \cprod$
    % and $\mtimescatmor_{\SetL} \definedas \cprod$
\end{lemma}
\begin{proof}
    % In this example we show that~\SetL is an  \SY{associative stacking} semicategory.
    % We first show that it is a stacking category.
    % To do so, we start by showing that the stacking operations fulfill \cref{def:simple-stacking-semi-cat}.
    For the stacking operation on objects $\mtimescatob$ we use the operation $\cprod$ defined in \cref{sec:cartcatset} which was referred to as the ``multiplication in \SetL''.
    \\
    As for $\mtimescatmor$, we define it as follows:
    \begin{equation}
        \label{eq:mtimescatmor-SetL}
        \prfperiod{
            \mora\colon\setA\mtoin\SetL\setB
        }{
            \quad
        }{
            \morb\colon\setC\mtoin\SetL\setD
        }{
            \defmap{
                (\mora\mtimescatmor\morb )
            }{
                \setA \cprod \setC
            }{
                \mtoin\SetL
            }{
                \setB \cprod \setD
            }{
                \maketupconcat{\ela, \elc}
            }{
                \maketupconcat{\mora(\ela), \morb(\elc)}
            }
        }
    \end{equation}
    The two operations $\mtimescatob, \mtimescatmor$ so defined satisfy the compatibility conditions
    required by \cref{def:simple-stacking-semi-cat}.

    To show associativity, consider three morphisms
    \begin{equation}
        % \begin{aligned}
        \mora\colon\setA\mtoin\SetL\setB,\qquad
        \morb\colon\setC\mtoin\SetL\setD,\qquad
        \morc\colon\setE\mtoin\SetL\setF.
        % \end{aligned}
    \end{equation}
    We compute $\mora\mtimescatmor(\morb\mtimescatmor\morc)$ and $(\mora\mtimescatmor\morb)\mtimescatmor\morc$ following the recipe \cref{eq:mtimescatmor-SetL} to obtain
    \begin{equation}
        \defmapcomma{
            \parslight{\mora\mtimescatmor\morb}\mtimescatmor\morc
        }{
            \parslight{\setA \cprod \setC} \cprod \setE
        }{
            \mtoin\SetL
        }{
            \parslight{\setB \cprod \setD} \cprod \setF
        }{
            \maketupconcat{\parslight{\maketupconcat{\ela, \elc}}, \ele}
        }{
            \maketupconcat{\parslight{\maketupconcat{\mora(\ela), \morb(\elc)}}, \morc(\ele) }
        }
    \end{equation}
    \begin{equation}
        \defmapperiod{
            \mora\mtimescatmor\parslight{\morb\mtimescatmor\morc}
        }{
            \setA \cprod \parslight{\setC \cprod \setE}
        }{
            \mtoin\SetL
        }{
            \setB \cprod \parslight{\setD \cprod \setF}
        }{
            \maketupconcat{\ela, \parslight{\maketupconcat{\elc, \ele}}}
        }{
            \maketupconcat{\mora(\ela), \parslight{\maketupconcat{\morb(\elc), \morc(\ele)}}}
        }
    \end{equation}
    Notice that the operations $\cprod$ and $\tupconcat$ are associative; therefore, we can remove all the light parentheses that appear in the formulas.
    This implies that both functions are equal to
    \begin{equation}
        \defmapperiod{
            \mora\mtimescatmor\morb\mtimescatmor\morc
        }{
            \setA \cprod \setC \cprod \setE
        }{
            \mtoin\SetL
        }{
            \setB \cprod \setD \cprod \setF
        }{
            \maketupconcat{\ela, \elc, \ele}
        }{
            \maketupconcat{\mora(\ela), \morb(\elc), \morc(\ele)}
        }
    \end{equation}
    % \begin{equation}
    %     \defmapperiod{
    %         \mtimescatob
    %     }{
    %         \Obof{\SetL} \cartprod \Obof{\SetL}
    %     }{
    %         \mto
    %     }{
    %         \Obof{\SetL}
    %     }{
    %         \tup{\cObj{\setAn{1},\ldots, \setAn{n}}, \cObj{\setBn{1},\ldots,\setBn{m}}}
    %     }{
    %         \cObj{\setAn{1},\ldots, \setAn{n}, \setBn{1},\ldots,\setBn{m}}
    %     }
    % \end{equation}
    % The stacking operation on morphisms is defined as
    % \begin{equation}
    %     \defmapcomma{
    %         \mtimescatmor
    %     }{
    %         \Mor_{\SetL} \cartprod \Mor_{\SetL}
    %     }{
    %         \mto
    %     }{
    %         \Mor_{\SetL}
    %     }{
    %         \tup{\mora,\morb}
    %     }{
    %         \mora \cprod \morb
    %     },
    % \end{equation}
    % where~$(\mora \cprod \morb)(\tup{\setAeln{1},\ldots, \setAeln{m}} \tupconcat \tup{\setBel_1,\ldots, \setBel_n})\definedas \mora(\tup{\setAeln{1},\ldots, \setAeln{m}})\tupconcat \morb(\tup{\setBel_1,\ldots, \setBel_n})$.
    % This is indeed a map between sets.
    % The two operations are compatible, because
    % \begin{widepar}
    %     \begin{equation}
    %         \prfperiod{
    %             \mora\colon \cObj{\setAn{1},\ldots,\setAn{n}}\mto \cObj{\setBn{1},\ldots,\setBn{m}}
    %         }{
    %             \morb\colon \cObj{\setCn{1},\ldots,\setCn{o}}\mto \cObj{\setDn{1},\ldots,\setDn{p}}
    %         }{
    %             \mora \mtimescatmor \morb \colon \cObj{\setAn{1}, \ldots, \setAn{n}, \setCn{1}, \ldots, \setCn{o}} \mto \cObj{\setBn{1}, \ldots, \setBn{m}, \setDn{1}, \ldots, \setDn{p}}
    %         }
    %     \end{equation}
    % \end{widepar}

    % We now show associativity.
    % We have already shown in \cref{sec:cartcatset} that~$\cprod$ satisfies the properties of a \SY{semigroup} operation.
    % For the operation on morphisms, consider
    % \begin{equation}
    %     \begin{aligned}
    %         \mora\colon \cObj{\setAn{1},\ldots,\setAn{m}} & \mto \cObj{\setBn{1}, \ldots, \setBn{n}}, \\
    %         \morb\colon \cObj{\setCn{1},\ldots,\setCn{o}} & \mto \cObj{\setDn{1},\ldots,\setDn{p}}, \\
    %         \morc\colon \cObj{\setEn{1},\ldots,\setEn{q}} & \mto \cObj{\setFn{1},\ldots,\setFn{r}},
    %     \end{aligned}
    % \end{equation}
    % For brevity, we write~$\setAeln{}=\tup{\setAeln{1},\ldots, \setAeln{m}}$,~$\setCeln{}=\tup{\setCeln{1},\ldots, \setCeln{o}}$, and~$\setEeln{}=\tup{\setEeln{1},\ldots,\setEeln{q}}$.
    % We have
    % \begin{align}
    %     ((\mora \cprod \morb)\cprod \morc)(\tup{\setAeln{}, \setCeln{},\setEeln{}})
    %      & =(\mora(\setAeln{})\tupconcat \morb(\setCeln{}))\tupconcat \morc(\setEeln{}) \\
    %      & =\mora(\setAeln{})\tupconcat \morb(\setCeln{})\tupconcat \morc(\setEeln{}) \\
    %      & =\mora(\setAeln{})\tupconcat (\morb(\setCeln{})\tupconcat \morc(\setEeln{})) \\
    %      & =(\mora \cprod (\morb\cprod \morc))(\tup{\setAeln{}, \setCeln{},\setEeln{}})
    % \end{align}
    % for all~$\tup{\setAeln{}, \setCeln{},\setEeln{}}\setin \cObj{\setAn{1},\ldots,\setAn{m},\setCn{1},\ldots,\setCn{o},\setEn{1},\ldots,\setEn{q}}$.

\end{proof}

% \begin{comment}
% \todotext{The example below is perhaps deprecated if we no longer use Set* as a main character in our story}

% \begin{example}
%     \SetL is an  \SY{associative stacking} semicategory.
%     We first show that it is a stacking category.
%     The stacking operation on objects is defined as list concatenation:
%     \begin{equation}
%         \defmapperiod{\mtimescatob}{\Ob_{\SetL} \cartprod \Ob_{\SetL}}{\mto}{\Ob_{\SetL}}{\tup{\Tupcatt{\setAn{1}}{\ldots}{ \setAn{n}}, \Tupcatt{\setBn{1}}{\ldots}{\setBn{m}}}}{\Tupcatt{\setAn{1}}{\ldots}{\setAn{n}} \listconcat \Tupcatt{\setBn{1}}{\ldots}{\setBn{m}}}
%     \end{equation}
%     The stacking operation on morphisms is defined as
%     \begin{equation}
%         \defmapperiod{\mtimescatmor}{\Mor_{\SetL} \cartprod \Mor_{\SetL}}{\mto}{\Mor_{\SetL}}{\tup{\mora,\morb}}{\more},
%     \end{equation}
%     which, given~$\mora\colon \Tupcatt{\setAn{1}}{\ldots}{\setAn{n}}\mto \Tupcatt{\setBn{1}}{\ldots}{\setBn{m}}$ (given by a map~$\mapc$) and~$\Tupcatt{\setCn{1}}{\ldots}{\setCn{o}}\mto \Tupcatt{\setDn{1}}{\ldots}{\setDn{p}}$ (given by a map~$\mapd$) is given by a function
%     \begin{equation}
%         \mape \definedas \cohm_{\setA,\setC}\then (\mapc\funcprod \mapd) \then \cohm_{\setB,\setD},
%     \end{equation}
%     which has signature
%     \begin{widepar}
%         \begin{equation}
%             \setAn{1}\cartprod (\setA_2\cartprod (\ldots \cartprod (\setAn{n} \cartprod (\setCn{1} \cartprod(\setC_2 \cartprod (\ldots \cartprod \setCn{o}))))))
%             \to
%             \setBn{1}\cartprod (\setB_2\cartprod (\ldots \cartprod (\setBn{m} \cartprod (\setDn{1} \cartprod (\setD_2 \cartprod(\ldots \cartprod \setDn{p})))))).
%         \end{equation}
%     \end{widepar}
%     The two operations are compatible, because
%     \begin{widepar}
%         \begin{equation}
%             \prfperiod{\mora\colon \Tupcatt{\setAn{1}}{\ldots}{\setAn{n}}\mto \Tupcatt{\setBn{1}}{\ldots}{\setBn{m}}}
%             {\morb\colon \Tupcatt{\setCn{1}}{\ldots}{\setCn{o}}\mto \Tupcatt{\setDn{1}}{\ldots}{\setDn{p}}}
%             {\more\colon \Tupca{\setAn{1}\setconcat \ldots \setconcat \setAn{n} \setconcat \setCn{1} \setconcat \ldots \setconcat \setCn{o}} \mto \Tupca{\setBn{1}\setconcat \ldots \setconcat \setBn{m} \setconcat \setDn{1} \setconcat \ldots \setconcat \setDn{p}}}
%         \end{equation}
%     \end{widepar}
%     Note that using the coherence morphisms is needed for the compatibility conditions to hold.

%     We now show associativity.
%     We have already shown in \cref{sec:semigroups} that the concatenation of lists satisfies the properties of a \SY{semigroup} operation.
%     Showing associativity of the operation on the morphisms is more cumbersome.
%     Consider morphisms
%     \begin{equation}
%         \begin{aligned}
%             \mora\colon \Tupcatt{\setAn{1}}{\ldots}{\setAn{m}} & \mto \Tupcatt{\setBn{1}}{\ldots}{\setBn{n}}, \\
%             \morb\colon \Tupcatt{\setCn{1}}{\ldots}{\setCn{o}} & \mto \Tupcatt{\setDn{1}}{\ldots}{\setDn{p}}, \\
%             \morc\colon \Tupcatt{\setEn{1}}{\ldots}{ \\setEn{q}} & \mto \Tupcatt{\\setFn{1}}{\ldots}{\\setFn{r}},
%         \end{aligned}
%     \end{equation}
%     to which maps~$\mapd,\mape,\mapf$ are associated.

%     We have:

%     \begin{center}
%         \begin{tikzpicture}
%             \node at (0,0){
%                 \begin{tikzcd}[every arrow/.append style={-Triangle, draw=morphisms}, column sep=large]
%                     (\mora \mtimescatmor \morb)
%                     \mtimescatmor \morc                                                                                                                                                                      & \mora \mtimescatmor (\morb \mtimescatmor \morc) \\
%                     \tupset{((\setLA \listconcat \setLC)\listconcat \setLE)}\arrow[d,"\cohm_{\setLA\listconcat \setLC, \setLE}^{-1}"]\arrow[r, equal]                                                        & \tupset{(\setLA \listconcat (\setLC\listconcat \setLE))}\arrow[d] \\
%                     \tupset{(\setLA\listconcat \setLC)}\cartprod \tupset{(\setLE)}\arrow[d, "\cohm_{\tupset{(\setLA)}, \tupset{(\setLC)}}^{-1} \funcprod \catid_{\tupset{(\setLC)}}"]                         & \tupset{(\setLA)}\cartprod \tupset{(\setLC \listconcat \setLE)}\arrow[d] \\
%                     (\tupset{(\setLA)}\cartprod \tupset{(\setLC)})\cartprod \tupset{(\setLE)}\arrow[r, "\alpha"]\arrow[d, "(\mapd \funcprod \mape)\funcprod \mapf"]                                          & \tupset{(\setLA)}\cartprod (\tupset{(\setLC)}\cartprod \tupset{(\setLE)})\arrow[d, "\mapd \funcprod (\mape\funcprod \mapf)"] \\
%                     (\tupset{(\setLB)}\cartprod \tupset{(\setLD)})\cartprod \tupset{(\setLF)}\arrow[r, "\alpha"]\arrow[d, "\cohm_{\tupset{(\setLB)}, \tupset{(\setLD)}}\funcprod \catid_{\tupset{(\setLF)}}"] & \tupset{(\setLB)}\cartprod (\tupset{(\setLD)}\cartprod \tupset{(\setLF)})\arrow[d] \\
%                     \tupset{(\setLB\listconcat \setLD)}\cartprod \tupset{(\setLF)}\arrow[d,"\cohm_{\setLB\listconcat \setLD, \setLF}"]                                                                       & \tupset{(\setLB)} \cartprod \tupset{(\setLD \listconcat\setLF)}\arrow[d] \\
%                     \tupset{((\setLB \listconcat \setLD)\listconcat \setLF)}\arrow[r, equal]                                                                                                                 & \tupset{(\setLB \listconcat (\setLD\listconcat \setLF))}
%                 \end{tikzcd}
%             };
%         \end{tikzpicture}
%     \end{center}
%     \todo{finish diagram above}
% \end{example}
% \end{comment}

%
%\begin{definition}
%    An  \SY{associative stacking} semicategory is called \emph{commutative} if its two stacking operations make the collections of objects and morphisms, respectively, into commutative semigroups.
%\end{definition}

\subsection{The \SY{semicategory} \Effects}

We now construct a non-trivial \SY{semicategory} that will serve as an example of a stacking \SY{semicategory} that is not functorial.

There are two types of computation: ``functional'', or ``pure'', or free of side effects, and \emph{effectful}.
In functional programming, functions are very much like mathematical functions: they need an input and produce and output.
They don't interfere with other functions.

Effectful procedures, instead, can ``change the world'': for example, printing a page, sending an email, or placing an order of pizza.
The order in which effectful procedures are evaluated might change the result.
For example, the result of the sequence of operations
%
\begin{enumerate}
    \item Order a pizza;
    \item Cancel the last order;
\end{enumerate}
%
is different from the result of the sequence of operations
%
\begin{enumerate}
    \item Cancel the last order;
    \item Order a pizza;
\end{enumerate}

A very elegant way to treat side effects mathematically is using \emph{linear types}~\cite{Wadler90lineartypes}.
We will mention those in a successive part on linear logic.
For now, we stick to a simple treatment.

\begin{marginfigure}
    \centering
    \subfloat[\label{fig:effects1}
        A morphism~$\mora\colon \Obja \mtoin{\Effects} \Objb$ in \Effects.
    ]{
        \rule{1cm}{0pt}\includesag{morphism_eff}\rule{1cm}{0pt}
    }\\
    \subfloat[\label{fig:effects2}
        Its representation in \SetL as a morphism
        $\repreff{\mora}\colon \cObj{\Obja,\EfW} \mtoin{\SetL} \cObj{\Objb, \EfW}$.
    ]{
        \rule{1cm}{0pt}\includesag{morphism_tup}\rule{1cm}{0pt}
    }
    \caption{}
    \label{fig:effects12}
\end{marginfigure}

We are going to define a category \Effects.
The idea is to add another variable that represents ``the world'' that can be affected.
An effectful function
%
\begin{equation}
    \mora\colon \Obja \mtoin{\Effects} \Objb,
\end{equation}
%
which could have some unknown side effects on the world, can be represented by a pure function
\begin{equation}
    \repreff{\mora}\colon \Obja \cartprod \EfW \mtoin{\Set} \Objb \cartprod \EfW,
\end{equation}
or, in other words, as a morphism
\begin{equation}
    \repreff{\mora}\colon \cObj{\Obja,\EfW} \mtoin{\SetL} \cObj{\Objb, \EfW},
\end{equation}
%
where~$\EfW$ is the set of all possible worlds~(\cref{fig:effects12}).

The second input to~$\repreff{\mora}$ is the state of the world before the execution of the function.
The second output of~$\repreff{\mora}$ is the state of the world after the execution of the function.

We can now interconnect different effectful functions, with some precautions.
We cannot ``split the world'', by creating a function of type~$\EfW \to \EfW \cartprod \EfW$.
We will re-state this formally when we get to linear logic.

\begin{marginfigure}
    \centering
    \subfloat[\label{fig:effects3}
        Composition in \Effects.
    ]{
        \includesag{morphism_eff_comp}
        %\includegraphics[width=4.5cm]{effects3}
    }\\
    \subfloat[\label{fig:effects3b}
        Its representation in \SetL.
    ]{
        \includesag{morphism_tup_comp}
        %\includegraphics[width=4.5cm]{effects3b}
    }
    \caption{}
    \label{fig:effect-composition}
\end{marginfigure}

We can extend usual function composition to composition of effectful functions as in~\cref{fig:effect-composition}.
The second effectful function operates on the world after it was possibly modified by the first effectful function.

We have all the ingredients to define the category \Effects of effectful computation.

\begin{definition}[Category of effectful procedures \Effects]
    \SYNDEF{category of sets and functions with side effects}
    \label{def:Effects}
    Fix a set~$\EfW$ of all possible worlds.
    The category~$\Effects$ is defined by the following:
    \begin{itemize}
        \item \emph{Objects}: same as the objects of \SetL;
        \item \emph{Morphisms}: a morphism~$\mora\colon \Obja \mtoin{\Effects} \Objb$ is a morphism
              \begin{equation}
                  \repreff{\mora}\colon \cObj{\Obja, \EfW} \mtoin{\SetL} \cObj{\Objb, \EfW}.
              \end{equation}
        \item \emph{Composition}: The composition of~$\mora\colon \Obja \mtoin{\Effects} \Objb$ and~$\morb\colon \Objb \mtoin{\Effects} \Objc$ is the morphism~$\morab\colon \Obja \mtoin{\Effects} \Objc$ with~$\repreff{\morab}$ given by
              \begin{equation}
                  \repreff{\mora \mthenof \Effects \morb}
                  = \repreff{\mora} \mthenof{\SetL} \repreff{\morb}
              \end{equation}
              as illustrated in \cref{fig:effect-composition}.
    \end{itemize}
\end{definition}

\begin{marginfigure}
    \centering
    \subfloat[\label{fig:effects4}
        Stacking in \Effects]{
        \includesag{stacking_eff}
        %\includegraphics[width=4.5cm]{effects4}
    }

    \subfloat[\label{fig:effects5} Its representation in \SetL]{
        %\includegraphics[width=4.5cm]{effects5}
        \includesag{stacking_tup}
    }
    \caption{}
    \label{fig:effect-stacking}
\end{marginfigure}

We can now make \Effects into a stacking \SY{semicategory} by deciding how to evaluate a stack of functions.
We cannot evaluate them in parallel.
We need to decide on a sequence.
For example, top to bottom.
This is shown in~\cref{fig:effect-stacking}.

\begin{lemma}
    \label{lem:effects-is-stacking}
    \Effects is an  \SY{associative stacking} category using the evaluation rule as in~\cref{fig:effect-stacking}.
\end{lemma}

\todotextjira{415}{\bernina: @Andrea: proof.
    Need to show \SY{semigroup}.
}

\clearpage

\subsection{\Moore is associative stacking}
When considering Moore machines, we can define stacking operations and show that \Moore forms a stacking \SY{semicategory} (\cref{def:simple-stacking-semi-cat}).
The objects of \Moore are objects of \SetL, and therefore the stacking operation for objects corresponds to the ``multiplication in \SetL'', denoted by $\cprod$.

The operation on morphisms ``stacks'' Moore machines onto each other.
Formally:

\begin{equation*}
    \prfcomma{\mora\colon \prin_\mora \mtoin{\Moore} \prout_\mora}{\mora\colon \prin_\morb \mtoin{\Moore} \prout_\morb}
    {\mora \mtimescatmor \morb=\tup{\prin_\mora \cprod \prin_\morb, \prst_\mora \cprod \prst_\morb,\prout_\mora \cprod \prout_\morb, \prdyn_{\mora \mtimescatmor \morb},\prreadout_{\mora \mtimescatmor \morb}, \prstart_\mora \tupconcat \prstart_\morb}}
\end{equation*}
with
\begin{equation*}
    \defmapcomma{\prdyn_{\mora \mtimescatmor \morb}}{\prin_\mora \cprod \prin_\morb \cprod \prst_\mora \cprod \prst_\morb}
    {\sto}{\prst_\mora \cprod \prst_\morb}{\prinel_\mora \tupconcat \prinel_\morb \tupconcat \prstel_\mora \tupconcat \prstel_\morb}
    {\prdyn_\mora(\prinel_\mora \tupconcat \prstel_\mora)\tupconcat \prdyn_\morb(\prinel_\morb \tupconcat \prstel_\morb)}
\end{equation*}
and
\begin{equation*}
    \defmapperiod{\prreadout_{\mora \mtimescatmor \morb}}
    {\prst_\mora \cprod \prst_\morb}{\sto}{\prout_\mora \cprod \prout_\morb}
    {\prstel_\mora \tupconcat \prstel_\morb}{\prreadout(\prstel_\mora)\tupconcat \prreadout(\prstel_\morb)}
\end{equation*}
While we have already proved that the operation $\cprod$ is associative, it is also easy to see that the stacking of Moore machines is associative.
Therefore, \Moore equipped with the described stacking operations forms an \SY{associative stacking} \SY{semicategory}.

\subsection{LTI is associative stacking}
When considering LTI systems, we can define stacking operations and show that \LTI forms a stacking \SY{semicategory} (\cref{def:simple-stacking-semi-cat}).
The stacking operation on objects is just addition on the natural numbers:
\begin{equation}
    \defmapperiod{
        \mtimescatob
    }{
        \Obof\LTI \cartprod \Obof\LTI
    }{
        \to
    }{
        \Obof\LTI
    }{
        \tup{\styleobj{l},\styleobj{m}}
    }{
        \styleobj{l}+\styleobj{m}
    }
\end{equation}
On the other hand, the operation on morphisms ``stacks'' the LTI systems onto each other\footnote{For the control engineers out there: the resulting LTI system will have a Relative Gain Array (RGA) matrix corresponding to the identity matrix.
}.
Formally:
\begin{equation}
    \prfperiod{
        \mora \colon \styleobj{l}\mtoin\LTI \styleobj{m}
    }{
        \morb \colon \styleobj{n}\mtoin\LTI \styleobj{o}
    }{
        \mora\mtimescatmor\morb = \genericlti{} \colon
        \styleobj{l+n}\mtoin\LTI \styleobj{m+o}
    }
\end{equation}
% \begin{equation}
%     \defmapcomma{
%         \mtimescatmor
%     }{
%         \Mor_\LTI \cartprod \Mor_\LTI
%     }{
%         \to
%     }{
%         \Mor_\LTI
%     }{
%         \tup{\genericlti{\mora},\genericlti{\morb}}
%     }{
%         \genericlti{}
%     }
% \end{equation}
with
\begin{equation}
    \prstart=\begin{bmatrix}
        \prstart_\mora \\
        \prstart_\morb
    \end{bmatrix},\
    \mat{A}=\begin{bmatrix}
        \mat{A}_\mora & \mat{0}       \\
        \mat{0}       & \mat{A}_\morb
    \end{bmatrix},\
    \mat{B}=\begin{bmatrix}
        \mat{B}_\mora & \mat{0}       \\
        \mat{0}       & \mat{B}_\morb
    \end{bmatrix},
    %  \
    % \mat{B}=\begin{bmatrix}
    %     \mat{B}_\mora & \mat{0}       \\
    %     \mat{0}       & \mat{B}_\morb
    % \end{bmatrix},\
    % \mat{C}=\begin{bmatrix}
    %     \mat{C}_\mora & \mat{0}       \\
    %     \mat{0}       & \mat{C}_\morb
    % \end{bmatrix},\
    % \mat{D}=\begin{bmatrix}
    %     \mat{D}_\mora & \mat{0}       \\
    %     \mat{0}       & \mat{D}_\morb
    % \end{bmatrix}
\end{equation}
\begin{equation}
    % \prstart=\begin{bmatrix}
    %     \prstart_\mora \\
    %     \prstart_\morb
    % \end{bmatrix},\
    % \mat{A}=\begin{bmatrix}
    %     \mat{A}_\mora & \mat{0}       \\
    %     \mat{0}       & \mat{A}_\morb
    % \end{bmatrix}, \
    % \mat{B}=\begin{bmatrix}
    %     \mat{B}_\mora & \mat{0}       \\
    %     \mat{0}       & \mat{B}_\morb
    % \end{bmatrix},\
    \mat{C}=\begin{bmatrix}
        \mat{C}_\mora & \mat{0}       \\
        \mat{0}       & \mat{C}_\morb
    \end{bmatrix},\
    \mat{D}=\begin{bmatrix}
        \mat{D}_\mora & \mat{0}       \\
        \mat{0}       & \mat{D}_\morb
    \end{bmatrix}
\end{equation}

% Clearly, the morphism given by~$\genericlti{}$ satisfies the compatibility condition for stacking semicategories:
% if~$\genericlti{\mora}$ is~$\styleobj{l}\mto \styleobj{m}$ and~$\genericlti{\morb}$ is~$\styleobj{n}\mto \styleobj{o}$,~$\genericlti{}$ is~$\styleobj{l}+\styleobj{n}\mto \styleobj{m}+\styleobj{o}$.
Given that the resulting LTI system is described by diagonal matrices, the defined operations are \SY{associative}, and therefore \LTI equipped with them forms an \SY{associative stacking} \SY{semicategory}.

\section{Functorial stacking semicategories}

\begin{marginfigure}
    \centering
    $(\mora \mtimescatmor \morb )
        \mthen (\morc \mtimescatmor \mord )$

    \vspace{3mm}
    \includesag{commuting_stacking_eff}

    $=$

    \vspace{3mm}
    \includesag{commuting_stacking_eff_bis}
    %\includegraphics[width=6.5cm]{effects8}
    \vspace{3mm}
    $(\mora \mthen \morc ) \mtimescatmor (\morb \mthen \mord )$

    \caption{Commutation of stacking and composition in a functorial stacking \SY{semicategory}. }
    \label{fig:stacking-functorial}
\end{marginfigure}

\begin{ctdefinition}[Functorial stacking semicategory]
    \label{def:functorial-stacking-semi-cat}
    A \maindef{functorial stacking semicategory} is a stacking \SY{semicategory} where the two stacking operations~$\mtimescatob$ and~$\mtimescatmor$ are the two components of a \SY{semifunctor} \begin{equation}
        \mtimescat\colon \CatC \Ctimes \CatC \to \CatC.
    \end{equation}
    Concretely, and in infix notation, this means that
    \begin{equation}
        (\mora \mthen \morc )
        \mtimescatmor (\morb \mthen \mord )
        =
        (\mora \mtimescatmor \morb )
        \mthen (\morc \mtimescatmor \mord )
    \end{equation}
    for all morphisms~$\mora, \morb, \morc$, and $\mord$ where respectively $\mora$ and $\morc$, and $\morb$ and $\mord$ are composable.
\end{ctdefinition}

%More in detail, we have that for any~$n \geq 2$, there is a semifunctor
%%
%\begin{equation}
%    \mtimescat^{(n)}\colon \underbrace {\CatC \times \CatC \times \cdots \times \CatC}_{\text{$n$ times}} \to \CatC.
%\end{equation}
%
This describes a sort of commutativity property: we can either first compose horizontally and then vertically, or vice versa, and we obtain the same morphism~(\cref{fig:stacking-functorial}).

This property is somewhat strong.
\Effects is an example of a stacking category that is not functorial.

\begin{lemma}
    \label{lem:effects-not-functorial}
    \Effects is \emph{not} a \SY{functorial stacking semicategory}.
\end{lemma}

\begin{proof}
    In general, we have
    \begin{equation}
        (\mora \mtimescatmor \morb )
        \mthen (\morc \mtimescatmor \mord )
        \neq
        (\mora \mthen \morc ) \mtimescatmor (\morb \mthen \mord ).
    \end{equation}
    This is shown graphically in \cref{fig:effects-non-functorial}.
\end{proof}

\begin{figure*}[h]
    \centering
    \hfill
    \subfloat[\label{fig:effects7}$(\mora \mtimescatmor \morb )
            \mthen (\morc \mtimescatmor \mord )$]{
        %\includegraphics[width=6.5cm]{effects7}
        \includesag{stacking_tup_counterproof}
    }
    \hfill
    \subfloat[\label{fig:effects9} $(\mora \mthen \morc ) \mtimescatmor (\morb \mthen \mord )$]{
        %\includegraphics[width=6.5cm]{effects9}
        \includesag{stacking_tup_counterproof_bis}
    }
    \hfill
    \caption{Proof that \Effects is not a \SY{functorial stacking} category by showing that
        the two morphisms above have different representations in~\SetL.}
    \label{fig:effects-non-functorial}
\end{figure*}

\begin{example}[\SetL is functorial stacking]
    \label{ex:setfunstack}
    We want to show that~\SetL is a \SY{functorial stacking semicategory}.

    Consider four morphisms
    \begin{equation}
        \begin{aligned}
            \mora\colon \setA \mto \setB, & \quad \morc\colon \setB \mto \setC, \\
            \morb\colon \setD \mto \setE, & \quad \mord\colon \setE \mto \setF.
            \\
        \end{aligned}
    \end{equation}
    We want to show that
    \begin{equation}
        (\mora \mtimescatmor \morb )
        \mthen (\morc \mtimescatmor \mord )
        =
        (\mora \mthen \morc ) \mtimescatmor (\morb \mthen \mord ),
    \end{equation}
    We show this by showing that, for any $\tup{\setAel,\setBel}\setin \setA\cartprod\setB$:
    \begin{equation}
        \begin{aligned}
             & ((\mora \mtimescatmor \morb )\mthen (\morc \mtimescatmor \mord ))(\tup{\setAeln{},\setDeln{}}) \\
             & = (\morc \mtimescatmor \mord)(\mora(\setAeln{})\tupconcat \morb(\setDeln{})) \\
             & =\morc(\mora(\setAeln{}))\tupconcat \mord(\morb(\setDeln{})) \\
             & =(\mora \mthen \morc)(\setAeln{})\tupconcat (\morb\mthen \mord)(\setDeln{}) \\
             & =((\mora \mthen \morc ) \mtimescatmor (\morb \mthen \mord ))(\tup{\setAeln{}, \setDeln{}}).
        \end{aligned}
    \end{equation}
\end{example}
% \begin{comment}
% \devel{
%
%     \begin{equation}
%         \begin{aligned}
%             \mora\colon \cObj{\setAn{1}, \ldots,\setAn{m}} & \mto \cObj{\setBn{1}, \ldots, \setBn{n}}, \\
%             \morb\colon \cObj{\setDn{1}, \ldots,\setDn{o}} & \mto \cObj{\setEn{1}, \ldots, \setEn{p}}, \\
%             \morc\colon \cObj{\setBn{1}, \ldots,\setBn{n}} & \mto \cObj{\setCn{1}, \ldots, \setCn{q}}, \\
%             \mord\colon \cObj{\setEn{1}, \ldots,\setEn{p}} & \mto \cObj{\setFn{1}, \ldots, \\setFn{r}},
%         \end{aligned}
%     \end{equation}
%     to which maps~$\mape,\mapf,\mapg,\maph$ are associated.
%
%     We want to show that
%     \begin{equation}
%         (\mora \mtimescat \morb )
%         \mthen (\morc \mtimescat \mord )
%         =
%         (\mora \mthen \morc ) \mtimescat (\morb \mthen \mord ),
%     \end{equation}
%     and we do it by showing that the map associated with the left-hand side of the equation corresponds to the one on the right-hand side.
%     We know the maps associated to~$(\mora \mtimescat \morb )$ and~$(\morc \mtimescat \mord )$, which are
%     \begin{equation}
%         \cohm_{\setA,\setD}\then (\mape \funcprod \mapg)\then \cohm_{\setB,\setE},
%     \end{equation}
%     and
%     \begin{equation}
%         \cohm_{\setB,\setE}\then (\mapf \funcprod \maph)\then \cohm_{\setC,\setF},
%     \end{equation}
%     respectively.
%     The map associated to~$(\mora \mtimescat \morb )
%         \mthen (\morc \mtimescat \mord )$ is therefore
%     \begin{equation}
%         \label{eq:setL_functorial_a}
%         \cohm_{\setA,\setD}\then (\mape \funcprod \mapg)\then \cohm_{\setB,\setE}\then \cohm_{\setB,\setE}\then (\mapf \funcprod \maph)\then \cohm_{\setC,\setF}.
%     \end{equation}
%     On the other hand, the map associated to~$(\mora \mthen \morc )$ is~$\mape\then \mapf$, and the map associated to~$(\morb \mthen \mord)$ is~$\mapg\then \maph$.
%     Therefore, the map associated to~$(\mora \mthen \morc ) \mtimescat (\morb \mthen \mord )$ is
%     \begin{equation}
%         \cohm_{\setA,\setD}\then ((\mape\then \mapf)\funcprod (\mapg\then \maph))\then \cohm_{\setC,\setD}
%     \end{equation}
%
%     \todotext{Now need to finish by showing equivalence of maps}
% }
% \end{comment}

\begin{example}
    We want to show that \Moore, equipped with the defined stacking operations, is a \SY{functorial stacking semicategory}.
    Consider four Moore machines:
    \begin{equation*}
        \mora\colon \prin_\mora \mto \prout_\mora,\quad \morb\colon \prin_\morb \mto \prout_\morb, \quad \morc\colon \prout_\mora \mto \prout_\morc,\quad \mord\colon \prout_\morb \mto \prout_\mord.
    \end{equation*}
    We need to show:
    \begin{equation*}
        (\mora \mthen \morc)
        \mtimescatmor (\morb\mthen \mord)=(\mora\mtimescatmor \morb)\mthen (\morc\mtimescatmor \mord).
    \end{equation*}
    Let's start from the left-hand side.
    First, we have:
    \begin{equation*}
        \begin{aligned}
            \mora \mthen \morc & =\tup{\prin_\mora, \prst_\mora \cprod \prst_\morc, \prout_\morc, \prdyn_{\mora\mthen \morc},\prreadout_{\mora\mthen \morc}, \prstart_\mora\tupconcat \prstart_\morc}, \\
            \morb \mthen \mord & =\tup{\prin_\morb, \prst_\morb \cprod \prst_\mord, \prout_\mord, \prdyn_{\morb\mthen \mord},\prreadout_{\morb\mthen \mord}, \prstart_\morb\tupconcat \prstart_\mord},
        \end{aligned}
    \end{equation*}
    with
    \begin{equation*}
        \defmapcomma{\prdyn_{\mora\mthen \morc}}
        {\prin_\mora\cprod \prst_\mora \cprod \prst_\morc}
        {\sto}
        {\prst_\mora \cprod \prst_\morc}
        {\prinel_\mora\tupconcat \prstel_\mora \tupconcat \prstel_\morc}
        {\prdyn_\mora(\prinel_\mora \tupconcat \prstel_\mora)\tupconcat \prdyn_\morc(\prreadout_\mora(\prstel_\mora)\tupconcat \prstel_\morc)}
    \end{equation*}
    %
    \begin{equation*}
        \defmapcomma{\prdyn_{\morb\mthen \mord}}
        {\prin_\morb\cprod \prst_\morb \cprod \prst_\mord}
        {\sto}
        {\prst_\morb \cprod \prst_\mord}
        {\prinel_\morb\tupconcat \prstel_\morb \tupconcat \prstel_\mord}
        {\prdyn_\morb(\prinel_\morb \tupconcat \prstel_\morb)\tupconcat \prdyn_\mord(\prreadout_\morb(\prstel_\morb)\tupconcat \prstel_\mord)}
    \end{equation*}
    %
    \begin{equation*}
        \defmapcomma{\prreadout_{\mora\mthen \morc}}
        {\prst_\mora \cprod \prst_\morc}
        {\sto}
        {\prout_\morc}
        {\prstel_\mora \tupconcat \prstel_\morc}
        {\prreadout_\morc(\prstel_\morc)}
    \end{equation*}
    and
    \begin{equation*}
        \defmapperiod{\prreadout_{\morb\mthen \mord}}
        {\prst_\morb \cprod \prst_\mord}
        {\sto}
        {\prout_\mord}
        {\prstel_\morb \tupconcat \prstel_\mord}
        {\prreadout_\mord(\prstel_\mord)}
    \end{equation*}

    Furthermore:
    \begin{widepar}
        \begin{equation*}
            (\mora \mthen \morc)\mtimescatmor (\morb \mthen \mord)=\tup{\prin_\mora\cprod \prin_\morb, \prst_\mora \cprod \prst_\morc\cprod \prst_\morb \cprod \prst_\mord, \prout_\morc\cprod \prout_\mord,
                \prdyn_{(\mora\mthen \morc)\mtimescatmor(\morb\mthen \mord)}, \prreadout_{(\mora\mthen \morc)\mtimescatmor(\morb\mthen \mord)}, \prstart_\mora\tupconcat \prstart_\morc\tupconcat \prstart_\morb\tupconcat \prstart_\mord},
        \end{equation*}
    \end{widepar}
    with
    \begin{widepar}
        \begin{equation*}
            \defmapcomma{\prdyn_{(\mora\mthen \morc)\mtimescatmor(\morb\mthen \mord)}}
            {\prin_\mora\cprod \prin_\morb\cprod \prst_\mora \cprod \prst_\morc\cprod \prst_\morb \cprod \prst_\mord}
            {\sto}
            {\prst_\morc\cprod \prst_\morb \cprod \prst_\mord}
            {\prinel_\mora\tupconcat \prinel_\morb \tupconcat \prstel_\mora \tupconcat \prstel_\morc \tupconcat \prstel_\morb \tupconcat \prstel_\mord}
            {\underbrace{\prdyn_{\mora\mthen \morc}(\prinel_\mora\tupconcat \prstel_\mora \tupconcat \prstel_\morc)\tupconcat \prdyn_{\morb\mthen \mord}(\prinel_\morb\tupconcat \prstel_\morb \tupconcat \prstel_\mord)}_{(1)}}
        \end{equation*}
    \end{widepar}
    where
    \begin{equation*}
        (1)=\prdyn_\mora(\prinel_\mora \tupconcat \prstel_\mora)\tupconcat \prdyn_\morc(\prreadout_\mora(\prstel_\mora)\tupconcat \prstel_\morc) \tupconcat
        \prdyn_\morb(\prinel_\morb \tupconcat \prstel_\morb)\tupconcat \prdyn_\mord(\prreadout_\morb(\prstel_\morb)\tupconcat \prstel_\mord),
    \end{equation*}
    and
    \begin{equation*}
        \defmapcomma{\prreadout_{(\mora\mthen \morc)\mtimescatmor(\morb\mthen \mord)}}
        {\prst_\mora \cprod \prst_\morc\cprod \prst_\morb \cprod \prst_\mord}
        {\sto}
        {\prout_\morc\cprod \prout_\mord}
        {\prstel_\mora \tupconcat \prstel_\morc \tupconcat \prstel_\morb \tupconcat \prstel_\mord}
        {\underbrace{\prreadout_{\mora\mthen \morc}(\prstel_\mora \tupconcat \prstel_\morc)\tupconcat \prreadout_{\morb\mthen \mord}(\prstel_\morb \tupconcat \prstel_\mord)}_{(2)}}
    \end{equation*}
    where
    \begin{equation*}
        (2)=\prreadout_\morc(\prstel_\morc)\tupconcat \prreadout_\mord(\prstel_\mord).
    \end{equation*}
    On the other hand, we have:
    \begin{equation*}
        \begin{aligned}
            \mora \mtimescatmor \morb & =\tup{\prin_\mora \cprod \prin_\morb, \prst_\mora \cprod \prst_\morb, \prout_\mora \cprod \prout_\morb, \prdyn_{\mora\mtimescatmor \morb},\prreadout_{\mora\mtimescatmor \morb}, \prstart_\mora\tupconcat \prstart_\morb}, \\
            \morc \mtimescatmor \mord & =\tup{\prin_\morc \cprod \prin_\mord, \prst_\morc \cprod \prst_\mord, \prout_\morc \cprod \prout_\mord, \prdyn_{\morc\mtimescatmor \mord},\prreadout_{\morc\mtimescatmor \mord}, \prstart_\morc\tupconcat \prstart_\mord}.
        \end{aligned}
    \end{equation*}

    Furthermore:
    \begin{widepar}
        \begin{equation*}
            (\mora \mtimescatmor \morb)\mthen (\morc \mtimescatmor \mord)=\tup{\prin_\mora\cprod \prin_\morb, \prst_\mora \cprod \prst_\morb\cprod \prst_\morc \cprod \prst_\mord, \prout_\morc\cprod \prout_\mord,
                \prdyn_{(\mora\mthen \morc)\mtimescatmor(\morb\mthen \mord)}, \prreadout_{(\mora\mtimescatmor \morb)\mthen(\morc\mtimescatmor \mord)}, \prstart_\mora\tupconcat \prstart_\morb\tupconcat \prstart_\morc\tupconcat \prstart_\mord}.
        \end{equation*}
    \end{widepar}

\end{example}

\begin{example}
    We want to show that \LTI, equipped with the defined stacking operations, is almost a \SY{functorial stacking semicategory}, but not quite.
    Given morphisms~$\mora\colon \styleobj{l}\mto \styleobj{m}$,~$\morc\colon \styleobj{m}\mto \styleobj{n}$,~$\morb\colon \styleobj{o}\mto \styleobj{p}$,~$\mord\colon \styleobj{p}\mto \styleobj{q}$, we would need to have
    \begin{equation*}
        (\mora \mthen \morc)
        \mtimescatmor (\morb\mthen \mord)=(\mora\mtimescatmor \morb)\mthen (\morc\mtimescatmor \mord).
    \end{equation*}
    This, however, is not true.
    Let's see this by looking at the first matrix component of the LTI system.
    On one hand we have:
    \begin{equation}
        \mat{A}_{(\mora \mthen \morc)\mtimescatmor (\morb\mthen \mord)}=
        \begin{bmatrix}
            \mat{A}_\mora              & \mat{0}       & \mat{0}                    & \mat{0}       \\
            \mat{B}_\morc\mat{C}_\mora & \mat{A}_\morc & \mat{0}                    & \mat{0}       \\
            \mat{0}                    & \mat{0}       & \mat{A}_\morb              & \mat{0}       \\
            \mat{0}                    & \mat{0}       & \mat{B}_\mord\mat{C}_\morb & \mat{A}_\mord
        \end{bmatrix}.
    \end{equation}
    On the other hand we have:
    \begin{equation}
        \mat{A}_{(\mora\mtimescatmor \morb)\mthen (\morc\mtimescatmor \mord)}=
        \begin{bmatrix}
            \mat{A}_\mora               & \mat{0}                     & \mat{0}       & \mat{0}       \\
            \mat{0}                     & \mat{A}_\morb               & \mat{0}       & \mat{0}       \\
            \mat{B}_\morc \mat{C}_\mora & \mat{0}                     & \mat{A}_\morc & \mat{0}       \\
            \mat{0}                     & \mat{B}_\mord \mat{C}_\morb & \mat{0}       & \mat{A}_\mord
        \end{bmatrix}.
    \end{equation}
    These two are different, and will therefore describe different systems.
    However, the two matrices just differ by two permutations, which can be expressed via an invertible linear transformation~$\mat{T}$ as follows:
    \begin{equation}
        \mat{A}_{(\mora\mtimescatmor \morb)\mthen (\morc\mtimescatmor \mord)}=
        \underbrace{\begin{bmatrix}
                1 & 0 & 0 & 0 \\
                0 & 0 & 1 & 0 \\
                0 & 1 & 0 & 0 \\
                0 & 0 & 0 & 1
            \end{bmatrix}}_{\mat{T}}\cdot
        \mat{A}_{(\mora \mthen \morc)\mtimescatmor (\morb\mthen \mord)}
        \cdot
        \begin{bmatrix}
            1 & 0 & 0 & 0 \\
            0 & 0 & 1 & 0 \\
            0 & 1 & 0 & 0 \\
            0 & 0 & 0 & 1
        \end{bmatrix}.
    \end{equation}
    The other system matrices also obey \cref{def:equivalence_lti}.
    Therefore, from \cref{lem:equivsystequivact}, we know that although \LTI is not a \SY{functorial stacking semicategory},~$(\mora \mthen \morc)\mtimescatmor (\morb\mthen \mord)$ and~$(\mora\mtimescatmor \morb)\mthen (\morc\mtimescatmor \mord)$ have the same action, and hence \LTI modulo action is ``morally'' functorial.
\end{example}

\section{Symmetric stacking}

Let~\CatC be an \SY{associative stacking} category, and consider morphisms
\begin{equation}
    \mora \mtimescatmor \morb \colon \Obja \mtimescatob \Objb \mto \Objc \mtimescatob \Objd
\end{equation}
and
\begin{equation}
    \morc \mtimescatmor \mord \colon \Objd \mtimescatob \Objc \mto \Objf \mtimescatob \Obje.
\end{equation}
If~$\Objc \mtimescatob \Objd \neq \Objd \mtimescatob \Objc$, then the morphisms~$\mora \mtimescatmor \morb$ and~$\morc \mtimescatmor \mord$ are, in our model, technically not composable.
However, in some examples, we will in fact want to be able to compose such morphisms, because in those cases~$\Objc \mtimescatob \Objd$ and~$\Objd \mtimescatob \Objc$ are essentially equal, even if they aren't equal on the nose.

For example,~$\mora, \morb, \morc, \mord$ might be systems, represented graphically by boxes with wires for input and output.
The stacked system~$\mora \mtimescatmor \morb$ will have output wires for~$\Objc$ and $\Objd$, and the stacked system~$\morc \mtimescatmor \mord$ will have input wires for~$\Objd$ and~$\Objc$.
In some applications we are often indeed able to connect the one output wire labeled with~$\Objc$ to the input wire also labeled with~$\Objc$, and similarly for~$\Objd$.

To model this for stacking \SY{semicategories}, we introduce operations that correspond to crossing (or permuting) wires, both on the input and output sides of morphism.
Recall that, for each~$n \setin \natnumbers$, the symmetric group $S_n$ is the group of \SY{bijections} of the set~$\makeset{1, 2, \ldots, n }$ with itself.

%Now consider a a stacking semicategory $\CatC$. For each natural number $n \geq 2$ and each permutation $\sigma \setin S_n$, we define an operation $P_\sigma: \Ob_\CatC \to \Ob_\CatC$ by
%\begin{equation}
%P_\sigma: \Objan{1} \mtimescatob \dots \mtimescatob  \Obja_n \mapsto \Obja_{\sigma(1)} \mtimescatob \dots \mtimescatob  \Obja_{\sigma(n)}
%\end{equation}

\begin{marginfigure}
    \centering
    \includegraphics[scale=0.1]{parallelism_symmetric-stacking-source-perm}
    \caption{A diagram for a source permutation map.}
    \label{fig:symmetric-stacking-left-perm}
\end{marginfigure}

\begin{marginfigure}
    \centering
    \includegraphics[scale=0.1]{parallelism_symmetric-stacking-target-perm}
    \caption{A diagram for a target permutation map.}
\end{marginfigure}

\begin{marginfigure}
    \centering
    \includegraphics[scale=0.1]{parallelism_symmetric-stacking-source-perm-evaluated}
    \caption{A source permutation applied to a morphism $\mora \colon \Obja \mto \Objb$ whose source has a factorization $\Obja = \Objan{1} \mtimescatob \Objan{2}  \mtimescatob \Objan{3}$ and whose target has a factorization $\Objb = \Objbn{1} \mtimescatob \Objbn{2}  \mtimescatob \Objbn{3}$.}
    \label{fig:symmetric-stacking-left-perm-evaluated}
\end{marginfigure}

\begin{marginfigure}
    \centering
    \includegraphics[scale=0.1]{parallelism_symmetric-stacking-target-perm-evaluated}
    \caption{The target permutation using the same permutation as in \cref{fig:symmetric-stacking-left-perm} and applied to the same morphism.}
    \label{fig:symmetric-stacking-target-perm}
\end{marginfigure}

\begin{ctdefinition}[Symmetric stacking semicategory]
    \label{def:symmetric-stacking-category}
    A \maindef{symmetric associative stacking semicategory} is an \SY{associative stacking} \SY{semicategory}~\CatC with:

    \constit

    \begin{itemize}
        \item Functions
              \begin{equation}
                  \sourceperm{\sigma} \colon \HomSet{\CatC}{\mtimescatob_{i=1}^n \Objan{i}}{\mtimescatob_{i=1}^n \Objbn{i}} \to \HomSet{\CatC}{\mtimescatob_{i=1}^n \Obja_{\sigma^{-1}(i)}}{\mtimescatob_{i=1}^n \Objbn{i}}
              \end{equation}
              and
              \begin{equation}
                  \targetperm{\sigma} \colon \HomSet{\CatC}{\mtimescatob_{i=1}^n \Objan{i}}{\mtimescatob_{i=1}^n \Objbn{i}} \to \HomSet{\CatC}{\mtimescatob_{i=1}^n \Objan{i}}{\mtimescatob_{i=1}^n \Objb_{\sigma(i)}}
              \end{equation}
              for every~$\sigma \setin \Perms(n)$,~$n \geq 1$.
              We call these functions \emph{source permutations} and \emph{target permutations}, respectively.
    \end{itemize}

    \condit

    \begin{itemize}

        \item \emph{Compatibility with composition:}

              For all $\mora \setin \HomSet{\CatC}{\Obja}{\mtimescatob_{i=1}^n \Objbn{i}}$ and $\morb \setin \HomSet{\CatC}{\mtimescatob_{i=1}^n \Objb_{\sigma(i)}}{\Objc}$
              \begin{equation}
                  \label{eq:perm-compatibility-with-composition}
                  \targetperm{\sigma} (\mora) \mthen \morb = \mora \mthen \sourceperm{\sigma}(\morb).
              \end{equation}

        \item \emph{Compatibility with stacking:}

              Given~$\moran{i} \colon \Objan{i} \mto \Objbn{i}$,~$1 \leq i \leq n$, it holds that
              \begin{equation}
                  \label{eq:perm-compatibility-with-stacking-1}
                  \targetperm{\sigma} ( \mtimescatmor_{i=1}^n \moran{i} ) = \sourceperm{\sigma}( \mtimescatmor_{i=1}^n \mora_{\sigma(i)} )
              \end{equation}
              and
              \begin{equation}
                  \label{eq:perm-compatibility-with-stacking-2}
                  \sourceperm{\sigma} ( \mtimescatmor_{i=1}^n \moran{i} ) = \targetperm{\sigma} ( \mtimescatmor_{i=1}^n \mora_{\sigma^{-1}(i)} ).
              \end{equation}

        \item \emph{Compatibility with permutation composition:}

              The equations
              \begin{equation}
                  \label{eq:perm-compatibility-with-perm-comp}
                  \sourceperm{\sigma} \mthen \sourceperm{\pi} = \sourceperm{(\pi\mthen\sigma)}
                  \quad \text{ and } \quad
                  \targetperm{\sigma} \mthen \targetperm{\pi} = \targetperm{(\sigma \mthen \pi)}
              \end{equation}
              hold for all~$\sigma, \pi \setin S_n$,~$n \geq 2$.

    \end{itemize}
\end{ctdefinition}

\todotext{@J: check if this definition is compatible with the definition of a symmetric \SY{strict monoidal category}, in particular coherence conditions}

In terms of diagrams, the condition of compatibility with composition \cref{eq:perm-compatibility-with-composition} is illustrated in terms of diagrams in \cref{fig:symmetric-stacking-comp-compat}.

\begin{figure}[h]
    \centering
    \subfloat[\label{fig:symmetric-stacking-comp-compat-1}$\targetperm{\sigma} (\mora) \mthen \morb$]{
        \includegraphics[scale=0.1]{parallelism_symmetric-stacking-comp-compat-1}
    } \qquad \qquad
    \subfloat[\label{fig:symmetric-stacking-comp-compat-2}$\mora \mthen \sourceperm{\sigma}(\morb)$]{
        \includegraphics[scale=0.1]{parallelism_symmetric-stacking-comp-compat-2}
    }
    \caption{Compatibility with composition. }
    \label{fig:symmetric-stacking-comp-compat}
\end{figure}

In \cref{fig:compatibility-with-stacking} the first equation \cref{eq:perm-compatibility-with-stacking-1} for compatibility with stacking is illustrated diagrammatically.

\begin{figure}[h]
    \centering
    \subfloat[\label{fig:compatibility-with-stacking-1}$\targetperm{\sigma} ( \mtimescatmor_{i=1}^n \moran{i} )$]{
        \includegraphics[scale=0.1]{parallelism_compatibility-with-stacking-1}
    } \qquad \qquad
    \subfloat[\label{fig:compatibility-with-stacking-2}$\sourceperm{\sigma}(  \mtimescatmor_{i=1}^n \mora_{\sigma(i)}) $]{
        \includegraphics[scale=0.1]{parallelism_compatibility-with-stacking-2}
    }
    \caption{Compatibility with composition. }
    \label{fig:compatibility-with-stacking}
\end{figure}

\cref{fig:compatibility-perm-comp} illustrates the first equation \cref{eq:perm-compatibility-with-perm-comp} for compatibility with permutation composition.

\begin{figure}[h]
    \centering
    \subfloat[\label{fig:compatibility-perm-comp-1}$\sourceperm{\sigma} \mthen \sourceperm{\pi}$]{
        \includegraphics[scale=0.1]{parallelism_compatibility-perm-comp-1}
    } \qquad \qquad
    \subfloat[\label{fig:compatibility-perm-comp-2}$\sourceperm{(\pi\mthen\sigma)} $]{
        \includegraphics[scale=0.1]{parallelism_compatibility-perm-comp-2}
    }
    \caption{Compatibility with composition. }
    \label{fig:compatibility-perm-comp}
\end{figure}

%\begin{figure*}[b]
%    %\includegraphics[width=8cm]{symmetric}
%    \centering
%    \subfloat[]{
%        \includesag{symmetric_stacking}
%    }
%    \subfloat[]{
%        \includesag{symmetric_stacking_bis}
%    }
%    \caption{
%        Illustration of \cref{eq:symmetric-condition}.
%    }
%    \label{fig:stacking-symmetric}
%\end{figure*}

\begin{example}
    \SetL is symmetric in a straightforward manner.
\end{example}

\begin{lemma}
    \label{lem:effects-not-symmetric}
    \Effects is not symmetric.
\end{lemma}

\todographicsjira{431}{\alphubel: @Andrea: Add figure for this lemma, in the same style as \cref{fig:effects-non-functorial} }

\todojira{699}{\alphubel: Example of \LTI with $d=0$ a symmetric semicat}

% \devel{

%     \section{Strict monoidal semicategories}

%     \begin{ctdefinition}\label{def:strict-monoidal-semicat}
%         A \emph{strict monoidal semicategory} is a functorial stacking semicategory $\tup{\CatC, \mtimescat}$ with

%         \constit

%         \begin{itemize}
%             \item an object $\idmoncat \setin \Obof{\CatC}$, called the \emph{monoidal unit}
%         \end{itemize}

%         \condit

%         \begin{itemize}
%             \item For any object $\Obja$ of \CatC,
%                   \begin{equation}
%                       \Obja \mtimescatob \idmoncat = \Obja \qquad \text{and} \qquad  \idmoncat \mtimescatob \Obja = \Obja.
%                   \end{equation}
%             \item The monoidal unit $\idmoncat$ has an identity morphism $\catid_\idmoncat$, and for any morphism $\mora \colon \Obja \mto \Objb$,
%                   \begin{equation}
%                       \mora \mtimescatmor \catid_\idmoncat = \mora \qquad \text{and} \qquad \catid_\idmoncat \mtimescat  \mora = \mora.
%                   \end{equation}
%         \end{itemize}

%     \end{ctdefinition}

%     \todotext{@JL: write def of symmetric strict monoidal semicategory}

% }
