% !TEX root = chapter-standalone.tex

\section{Parallel stacking}
\label{sec:parallel-stacking}

So far we have seen how we can compose morphisms ``horizontally'':
%
\begin{equation}
    \prfperiod{
        \mora \colon \Obja \mto \Objb
    }{
        \morb\colon \Objb \mto \Objc
    }{
        \mora \mthen \morb \colon \Obja \mto \Objc
    }
\end{equation}
%
There are other notions of composition that allow us to compose morphisms by ``stacking them vertically''.
Given two morphisms
%
\begin{align}
    \mora & \colon \Obja \mto \Objb, \\
    \morb & \colon \Objc \mto \Objd,
\end{align}
%
we will obtain by parallel stacking a morphism
%
\begin{align}
    (\mora\mtimescat \morb)
     & \colon (\Obja \mtimescat \Objc) \mto (\Objb \mtimescat \Objd),
\end{align}
%
where ``$\mtimescat$'' is a stacking operation to be defined.
Note that while in the case of sequential composition there was a compatibility condition to be defined, as the target of the first morphism must be the source of the second morphism, here instead we can stack arbitrary morphisms.

We also expect to be able to stack any number of morphisms.
Having a collection of morphisms
%
\begin{equation}
    \moran{i} \colon \Objan{i} \mto \Objbn{i}, \qquad 1 \leq i \leq n,
\end{equation}
%
we expect to be able to obtain the composed morphism
%
\begin{equation}
    (\mtimescat_{i=1}^n  \moran{i} )
    \colon( \mtimescat_{i=1}^n  \Objan{i} )\mto (\mtimescat_{i=1}^n  \Objbn{i}).
\end{equation}

\subsection{Types of stacking operations}

There are various properties that one can consider for this stacking operation.
The ones that we will consider in this chapter are:
%
\begin{enumerate}
    \item \emph{Stacking semicategory} (\cref{def:stacking-semi-cat}): a semicategory in which it is possible to stack two morphisms.
    \item \emph{Associative stacking semicategory} (\cref{def:stacking-semi-cat}): a semicategory in which the stacking operation is associative and makes objects and morphisms into a semigroup.
    \item \emph{Functorial stacking semicategory} (\cref{def:functorial-stacking-semi-cat}): a stacking semicategory in which the stacking operation is also a functor.
    \item \emph{Symmetric stacking semicategory}: a stacking semicategory in which there is a series of symmetry operations that can permute the objects in a stack.
\end{enumerate}
%
In the next part we will talk about \emph{monoidal categories} (\cref{def:monoidal-cat}), which can be seen as a generalization of associative stacking semicategories where the stacking operation is not required to be associative ``on the nose'', but rather only up to isomorphism.

\begin{remark}
    [Choices in definitions~$\star$]
    Of all these definitions, the only `classical' one is that of \emph{monoidal category}, and its specializations, such as strict monoidal category, braided monoidal category, and symmetric monoidal category.
    We will look at all of those in~\cref{sec:parallelism-mon-cat}.

    We define the three non-classical notions mentioned above for the following reasons:
    \begin{itemize}
        \item Using the strictification construction of \SetL most of the monoidal categories are strict; we can ask that the composition induces semigroups of morphisms.
              We will not need to define unitors and associators.
              In fact, we do not need to define natural transformations.
              \todojira{641}{J: I'm not understanding what this comment is trying to say.}
        \item There are important cases of semicategories without identities with a stacking operation that do not fit the notion of monoidal category.
              An example is discrete-time linear systems.
              For these categories we also want to consider appropriate traces.
        \item There are important examples in which there is a way to stack morphisms, but the stacking is not functorial.
              For example, we will describe a category of effectful computation with side effects.
    \end{itemize}
\end{remark}

\subsection{Stacking semicategories}

\begin{ctdefinition}[Stacking semicategory]
    \label{def:simple-stacking-semi-cat}
    A stacking semicategory is a semicategory~$\CatC$ with the following additional constituents and properties.

    \constit
    \begin{itemize}
        \item A stacking operation~$\mtimescatob \colon \Ob_\CatC \cartprod \Ob_\CatC \to \Ob_\CatC$.
        \item A stacking operation~$\mtimescatmor \colon \Mor_\CatC \cartprod \Mor_\CatC \to \Mor_\CatC$.
    \end{itemize}

    \condit
    \begin{itemize}
        \item The two operations~$\mtimescatob$ and~$\mtimescatmor$ are compatible in the sense that
              %
              \begin{equation}
                  \prfperiod{
                      \moran{1} \colon \Objan{1} \mto \Objbn{1}
                      \qquad
                      \moran{2} \colon \Objan{2} \mto \Objbn{2}
                  }{
                      \moran{1} \mtimescatmor \moran{2} \colon  \Objan{1} \mtimescatob  \Objan{2} \mto \Objbn{1} \mtimescatob \Objbn{2}
                  }
              \end{equation}
    \end{itemize}
\end{ctdefinition}

\begin{ctdefinition}[Associative stacking semicategory]
    \label{def:stacking-semi-cat}
    An associative stacking semicategory is a stacking semicategory satisfying the following.

    \condit
    \begin{itemize}
        \item The stacking operation~$\mtimescatob$ makes the objects into a semigroup.
        \item The stacking operation~$\mtimescatmor$ makes the morphisms into a semigroup.
    \end{itemize}
\end{ctdefinition}

\begin{remark}
    In an associative stacking semicategory it follows that we can stack any number of morphisms without needing to bracket using parentheses:
    \begin{equation}
        \prfperiod{
            \moran{i} \colon \Objan{i} \mto \Objbn{i}, \qquad 1 \leq i \leq n,
        }{
            \mtimescatmor_{i=1}^n \moran{i} \colon  \mtimescatob_{i=1}^n \Objan{i} \mto \mtimescatob_{i=1}^n \Objbn{i}.
        }
    \end{equation}
\end{remark}

\begin{example}[\SetL is associative stacking]
    In this example we show that~\SetL is an associative stacking semicategory.
    We first show that it is a stacking category.
    To do so, we start by showing that the stacking operations fulfill \cref{def:simple-stacking-semi-cat}.
    The stacking operation on objects was defined in \cref{sec:cartcatset} and was referred to as the ``multiplication in \SetL''.
    Since it returns a set, it is valid.
    We have
    \begin{equation}
        \defmapperiod{\mtimescatob}{\Ob_{\SetL} \cartprod \Ob_{\SetL}}{\mto}{\Ob_{\SetL}}{\tup{\cObj{\setAn{1},\ldots, \setAn{n}}, \cObj{\setBn{1},\ldots,\setBn{m}}}}{\cObj{\setAn{1},\ldots, \setAn{n}} \cprod \cObj{\setBn{1},\ldots,\setBn{m}}}
    \end{equation}
    The stacking operation on morphisms is defined as
    \begin{equation}
        \defmapcomma{\mtimescatmor}{\Mor_{\SetL} \cartprod \Mor_{\SetL}}{\mto}{\Mor_{\SetL}}{\tup{\mora,\morb}}{\mora \cprod \morb},
    \end{equation}
    where~$(\mora \cprod \morb)(\tup{\setAeln{1},\ldots, \setAeln{m}} \tupconcat \tup{\setBel_1,\ldots, \setBel_n})\definedas \mora(\tup{\setAeln{1},\ldots, \setAeln{m}})\tupconcat \morb(\tup{\setBel_1,\ldots, \setBel_n})$.
    This is indeed a map between sets.
    The two operations are compatible, because
    \begin{widepar}
        \begin{equation}
            \prfperiod{\mora\colon \cObj{\setAn{1},\ldots,\setAn{n}}\mto \cObj{\setBn{1},\ldots,\setBn{m}}}
            {\morb\colon \cObj{\setCn{1},\ldots,\setCn{o}}\mto \cObj{\setDn{1},\ldots,\setDn{p}}}
            {\mora \mtimescatmor \morb \colon \cObj{\setAn{1}, \ldots, \setAn{n}, \setCn{1}, \ldots, \setCn{o}} \mto \cObj{\setBn{1}, \ldots, \setBn{m}, \setDn{1}, \ldots, \setDn{p}}}
        \end{equation}
    \end{widepar}

    We now show associativity.
    We have already shown in \cref{sec:cartcatset} that~$\cprod$ satisfies the properties of a semigroup operation.
    For the operation on morphisms, consider
    \begin{equation}
        \begin{aligned}
            \mora\colon \cObj{\setAn{1},\ldots,\setAn{m}} & \mto \cObj{\setBn{1}, \ldots, \setBn{n}}, \\
            \morb\colon \cObj{\setCn{1},\ldots,\setCn{o}} & \mto \cObj{\setDn{1},\ldots,\setDn{p}}, \\
            \morc\colon \cObj{\setEn{1},\ldots,\setEn{q}} & \mto \cObj{\setFn{1},\ldots,\setFn{r}},
        \end{aligned}
    \end{equation}
    For brevity, we write~$\setAeln{}=\tup{\setAeln{1},\ldots, \setAeln{m}}$,~$\setCeln{}=\tup{\setCeln{1},\ldots, \setCeln{o}}$, and~$\setEeln{}=\tup{\setEeln{1},\ldots,\setEeln{q}}$.
    We have
    \begin{align}
        ((\mora \cprod \morb)\cprod \morc)(\tup{\setAeln{}, \setCeln{},\setEeln{}})
         & =(\mora(\setAeln{})\tupconcat \morb(\setCeln{}))\tupconcat \morc(\setEeln{}) \\
         & =\mora(\setAeln{})\tupconcat \morb(\setCeln{})\tupconcat \morc(\setEeln{}) \\
         & =\mora(\setAeln{})\tupconcat (\morb(\setCeln{})\tupconcat \morc(\setEeln{})) \\
         & =(\mora \cprod (\morb\cprod \morc))(\tup{\setAeln{}, \setCeln{},\setEeln{}})
    \end{align}
    for all~$\tup{\setAeln{}, \setCeln{},\setEeln{}}\setin \cObj{\setAn{1},\ldots,\setAn{m},\setCn{1},\ldots,\setCn{o},\setEn{1},\ldots,\setEn{q}}$.

\end{example}

% \begin{comment}
% \todotext{The example below is perhaps deprecated if we no longer use Set* as a main character in our story}

% \begin{example}
%     \SetL is an associative stacking semicategory.
%     We first show that it is a stacking category.
%     The stacking operation on objects is defined as list concatenation:
%     \begin{equation}
%         \defmapperiod{\mtimescatob}{\Ob_{\SetL} \cartprod \Ob_{\SetL}}{\mto}{\Ob_{\SetL}}{\tup{\Tupcatt{\setAn{1}}{\ldots}{ \setAn{n}}, \Tupcatt{\setBn{1}}{\ldots}{\setBn{m}}}}{\Tupcatt{\setAn{1}}{\ldots}{\setAn{n}} \listconcat \Tupcatt{\setBn{1}}{\ldots}{\setBn{m}}}
%     \end{equation}
%     The stacking operation on morphisms is defined as
%     \begin{equation}
%         \defmapperiod{\mtimescatmor}{\Mor_{\SetL} \cartprod \Mor_{\SetL}}{\mto}{\Mor_{\SetL}}{\tup{\mora,\morb}}{\more},
%     \end{equation}
%     which, given~$\mora\colon \Tupcatt{\setAn{1}}{\ldots}{\setAn{n}}\mto \Tupcatt{\setBn{1}}{\ldots}{\setBn{m}}$ (given by a map~$\mapc$) and~$\Tupcatt{\setCn{1}}{\ldots}{\setCn{o}}\mto \Tupcatt{\setDn{1}}{\ldots}{\setDn{p}}$ (given by a map~$\mapd$) is given by a function
%     \begin{equation}
%         \mape \definedas \cohm_{\setA,\setC}\then (\mapc\funcprod \mapd) \then \cohm_{\setB,\setD},
%     \end{equation}
%     which has signature
%     \begin{widepar}
%         \begin{equation}
%             \setAn{1}\cartprod (\setA_2\cartprod (\ldots \cartprod (\setAn{n} \cartprod (\setCn{1} \cartprod(\setC_2 \cartprod (\ldots \cartprod \setCn{o}))))))
%             \to
%             \setBn{1}\cartprod (\setB_2\cartprod (\ldots \cartprod (\setBn{m} \cartprod (\setDn{1} \cartprod (\setD_2 \cartprod(\ldots \cartprod \setDn{p})))))).
%         \end{equation}
%     \end{widepar}
%     The two operations are compatible, because
%     \begin{widepar}
%         \begin{equation}
%             \prfperiod{\mora\colon \Tupcatt{\setAn{1}}{\ldots}{\setAn{n}}\mto \Tupcatt{\setBn{1}}{\ldots}{\setBn{m}}}
%             {\morb\colon \Tupcatt{\setCn{1}}{\ldots}{\setCn{o}}\mto \Tupcatt{\setDn{1}}{\ldots}{\setDn{p}}}
%             {\more\colon \Tupca{\setAn{1}\setconcat \ldots \setconcat \setAn{n} \setconcat \setCn{1} \setconcat \ldots \setconcat \setCn{o}} \mto \Tupca{\setBn{1}\setconcat \ldots \setconcat \setBn{m} \setconcat \setDn{1} \setconcat \ldots \setconcat \setDn{p}}}
%         \end{equation}
%     \end{widepar}
%     Note that using the coherence morphisms is needed for the compatibility conditions to hold.

%     We now show associativity.
%     We have already shown in \cref{sec:semigroups} that the concatenation of lists satisfies the properties of a semigroup operation.
%     Showing associativity of the operation on the morphisms is more cumbersome.
%     Consider morphisms
%     \begin{equation}
%         \begin{aligned}
%             \mora\colon \Tupcatt{\setAn{1}}{\ldots}{\setAn{m}} & \mto \Tupcatt{\setBn{1}}{\ldots}{\setBn{n}}, \\
%             \morb\colon \Tupcatt{\setCn{1}}{\ldots}{\setCn{o}} & \mto \Tupcatt{\setDn{1}}{\ldots}{\setDn{p}}, \\
%             \morc\colon \Tupcatt{\setEn{1}}{\ldots}{ \\setEn{q}} & \mto \Tupcatt{\\setFn{1}}{\ldots}{\\setFn{r}},
%         \end{aligned}
%     \end{equation}
%     to which maps~$\mapd,\mape,\mapf$ are associated.

%     We have:

%     \begin{center}
%         \begin{tikzpicture}
%             \node at (0,0){
%                 \begin{tikzcd}[every arrow/.append style={-Triangle, draw=morphisms}, column sep=large]
%                     (\mora \mtimescatmor \morb)
%                     \mtimescatmor \morc                                                                                                                                                                      & \mora \mtimescatmor (\morb \mtimescatmor \morc) \\
%                     \tupset{((\setLA \listconcat \setLC)\listconcat \setLE)}\arrow[d,"\cohm_{\setLA\listconcat \setLC, \setLE}^{-1}"]\arrow[r, equal]                                                        & \tupset{(\setLA \listconcat (\setLC\listconcat \setLE))}\arrow[d] \\
%                     \tupset{(\setLA\listconcat \setLC)}\cartprod \tupset{(\setLE)}\arrow[d, "\cohm_{\tupset{(\setLA)},\tupset{(\setLC)}}^{-1} \funcprod \catid_{\tupset{(\setLC)}}"]                         & \tupset{(\setLA)}\cartprod \tupset{(\setLC \listconcat \setLE)}\arrow[d] \\
%                     (\tupset{(\setLA)}\cartprod \tupset{(\setLC)})\cartprod \tupset{(\setLE)}\arrow[r, "\alpha"]\arrow[d, "(\mapd \funcprod \mape)\funcprod \mapf"]                                          & \tupset{(\setLA)}\cartprod (\tupset{(\setLC)}\cartprod \tupset{(\setLE)})\arrow[d, "\mapd \funcprod (\mape\funcprod \mapf)"] \\
%                     (\tupset{(\setLB)}\cartprod \tupset{(\setLD)})\cartprod \tupset{(\setLF)}\arrow[r, "\alpha"]\arrow[d, "\cohm_{\tupset{(\setLB)},\tupset{(\setLD)}}\funcprod \catid_{\tupset{(\setLF)}}"] & \tupset{(\setLB)}\cartprod (\tupset{(\setLD)}\cartprod \tupset{(\setLF)})\arrow[d] \\
%                     \tupset{(\setLB\listconcat \setLD)}\cartprod \tupset{(\setLF)}\arrow[d,"\cohm_{\setLB\listconcat \setLD, \setLF}"]                                                                       & \tupset{(\setLB)} \cartprod \tupset{(\setLD \listconcat\setLF)}\arrow[d] \\
%                     \tupset{((\setLB \listconcat \setLD)\listconcat \setLF)}\arrow[r, equal]                                                                                                                 & \tupset{(\setLB \listconcat (\setLD\listconcat \setLF))}
%                 \end{tikzcd}
%             };
%         \end{tikzpicture}
%     \end{center}
%     \todo{finish diagram above}
% \end{example}
% \end{comment}

%
\begin{definition}
    An associative stacking semicategory is called \emph{commutative} if its two stacking operations make the collections of objects and morphisms, respectively, into commutative semigroups.
\end{definition}

\subsection{The semicategory \Effects}

We now construct a non-trivial semicategory that will serve as an example of a stacking semicategory that is not functorial.

There are two types of computation: ``functional'', or ``pure'', or free of side effects, and \emph{effectful}.
In functional programming, functions are very much like mathematical functions: they need an input and produce and output.
They don't interfere with other functions.

Effectful procedures,  instead, can ``change the world'': for example, printing a page, sending an email, or placing an order of pizza.
The order in which effectful procedures are evaluated might change the result.
For example, the result of the sequence of operations
%
\begin{enumerate}
    \item Order a pizza;
    \item Cancel the last order;
\end{enumerate}
%
is different from the result of the sequence of operations
%
\begin{enumerate}
    \item Cancel the last order;
    \item Order a pizza;
\end{enumerate}

A very elegant way to treat side effects mathematically is using \emph{linear types}~\cite{Wadler90lineartypes}.
We will mention those in a successive part on linear logic.
For now, we stick to a simple treatment.

\begin{marginfigure}
    \centering
    \subfloat[\label{fig:effects1}
        A morphism~$\mora\colon \Obja \mtoin{\Effects} \Objb$ in \Effects.
    ]{
        \rule{1cm}{0pt}\includesag{morphism_eff}\rule{1cm}{0pt}
    }\\
    \subfloat[\label{fig:effects2}
        Its representation in \SetL as a morphism
        $\repreff{\mora}\colon  \cObj{\Obja,\EfW} \mtoin{\SetL}   \cObj{\Objb, \EfW}$.
    ]{
        \rule{1cm}{0pt}\includesag{morphism_tup}\rule{1cm}{0pt}
    }
    \caption{}
    \label{fig:effects12}
\end{marginfigure}

We are going to define a category \Effects.
The idea is to add another variable that represents ``the world'' that can be affected.
An effectful function
%
\begin{equation}
    \mora\colon \Obja \mtoin{\Effects} \Objb,
\end{equation}
%
which could have some unknown side effects on the world, can be represented by a pure function
\begin{equation}
    \repreff{\mora}\colon  \Obja  \cartprod \EfW \mtoin{\Set}   \Objb \cartprod \EfW,
\end{equation}
or, in other words, as a morphism
\begin{equation}
    \repreff{\mora}\colon  \cObj{\Obja,\EfW} \mtoin{\SetL}   \cObj{\Objb, \EfW},
\end{equation}
%
where~$\EfW$ is the set of all possible worlds~(\cref{fig:effects12}).

The second input to~$\repreff{\mora}$ is the state of the world before the execution of the function.
The second output of~$\repreff{\mora}$ is the state of the world after the execution of the function.

We can now interconnect different effectful functions, with some precautions.
We cannot ``split the world'', by creating a function of type~$\EfW \to  \EfW \cartprod \EfW$.
We will re-state this formally when we get to linear logic.

\begin{marginfigure}
    \centering
    \subfloat[\label{fig:effects3}
        Composition in \Effects.
    ]{
        \includesag{morphism_eff_comp}
        %\includegraphics[width=4.5cm]{effects3}
    }\\
    \subfloat[\label{fig:effects3b}
        Its representation in \SetL.
    ]{
        \includesag{morphism_tup_comp}
        %\includegraphics[width=4.5cm]{effects3b}
    }
    \caption{}
    \label{fig:effect-composition}
\end{marginfigure}

We can extend usual function composition to composition of effectful functions as in~\cref{fig:effect-composition}.
The second effectful function operates on the world after it was possibly modified by the first effectful function.

We have all the ingredients to define the category \Effects of effectful computation.

\begin{definition}[Category of effectful procedures \Effects]
    Fix a set~$\EfW$ of all possible worlds.
    The category~$\Effects$ is defined by the following:
    \begin{itemize}
        \item \emph{Objects}: same as the objects of \SetL;
        \item \emph{Morphisms}: a morphism~$\mora\colon \Obja \mtoin{\Effects} \Objb$ is a morphism
              \begin{equation}
                  \repreff{\mora}\colon \cObj{\Obja, \EfW} \mtoin{\SetL} \cObj{\Objb, \EfW}.
              \end{equation}
        \item \emph{Composition}: The composition of~$\mora\colon \Obja \mtoin{\Effects} \Objb$ and~$\morb\colon \Objb \mtoin{\Effects} \Objc$ is the morphism~$\morab\colon \Obja \mtoin{\Effects} \Objc$ with~$\repreff{\morab}$ given by
              \begin{equation}
                  \repreff{\mora \mthenof \Effects \morb}
                  = \repreff{\mora} \mthenof{\SetL} \repreff{\morb}
              \end{equation}
              as illustrated in \cref{fig:effect-composition}.
    \end{itemize}
\end{definition}

We can now make \Effects into a stacking semicategory by deciding how to evaluate a stack of functions.
We cannot evaluate them in parallel.
We need to decide on a sequence.
For example, top to bottom.
This is shown in~\cref{fig:effect-stacking}.

\begin{lemma}
    \label{lem:effects-is-stacking}
    \Effects is an associative stacking category using the evaluation rule as in~\cref{fig:effect-stacking}.
\end{lemma}

\begin{figure}[h!]
    \centering
    \subfloat[\label{fig:effects4}
        Stacking in \Effects]{
        \includesag{stacking_eff}
        %\includegraphics[width=4.5cm]{effects4}
    }
    \subfloat[\label{fig:effects5} Its representation in \SetL]{
        %\includegraphics[width=4.5cm]{effects5}
        \includesag{stacking_tup}
    }
    \caption{}
    \label{fig:effect-stacking}
\end{figure}

\todotextjira{415}{proof.
    Need to show semigroup.
}

\subsection{LTI is stacking}
When considering LTI systems, we can define stacking operations and show that it forms a stacking semicategory (\cref{def:simple-stacking-semi-cat}).
The stacking operation on objects is defined as
\begin{equation}
    \defmapperiod{\mtimescatob}{\Ob_\LTI \cartprod \Ob_\LTI}{\to}{\Ob_\LTI}{\tup{\styleobj{l},\styleobj{m}}}{\styleobj{l}+\styleobj{m}}
\end{equation}
On the other hand, the operation on morphisms ``stacks'' the LTI systems onto each other.
\footnote{For the control engineers out there: the resulting LTI system will have a Relative Gain Array (RGA) matrix corresponding to the identity matrix.}
Formally:
\begin{equation}
    \defmapcomma{\mtimescatmor}{\Mor_\LTI \cartprod \Mor_\LTI}{\to}{\Mor_\LTI}{\tup{\genericlti{\mora},\genericlti{\morb}}}{\genericlti{}}
\end{equation}
with
\begin{widepar}
    \begin{equation}
        \prstart=\begin{bmatrix}
            \prstart_\mora \\
            \prstart_\morb
        \end{bmatrix},\
        \mat{A}=\begin{bmatrix}
            \mat{A}_\mora & \mat{0}       \\
            \mat{0}       & \mat{A}_\morb
        \end{bmatrix}, \
        \mat{B}=\begin{bmatrix}
            \mat{B}_\mora & \mat{0}       \\
            \mat{0}       & \mat{B}_\morb
        \end{bmatrix},\
        \mat{C}=\begin{bmatrix}
            \mat{C}_\mora & \mat{0}       \\
            \mat{0}       & \mat{C}_\morb
        \end{bmatrix},\
        \mat{D}=\begin{bmatrix}
            \mat{D}_\mora & \mat{0}       \\
            \mat{0}       & \mat{D}_\morb
        \end{bmatrix}
    \end{equation}
\end{widepar}

Clearly, the morphism given by~$\genericlti{}$ satisfies the compatibility condition for stacking semicategories:
if~$\genericlti{\mora}$ is~$\styleobj{l}\mto \styleobj{m}$ and~$\genericlti{\morb}$ is~$\styleobj{n}\mto \styleobj{o}$,~$\genericlti{}$ is~$\styleobj{l}+\styleobj{n}\mto \styleobj{m}+\styleobj{o}$.
Given that the resulting LTI system is described by diagonal matrices, the defined operations are associative, and therefore \LTI is an associative stacking semicategory.

\section{Functorial stacking semicategory}

\begin{ctdefinition}[Functorial stacking semicategory]
    \label{def:functorial-stacking-semi-cat}
    A functorial stacking semicategory is a stacking semicategory where the two stacking operations~$\mtimescatob$ and~$\mtimescatmor$ are the two components of a semifunctor
    \begin{equation}
        \mtimescat\colon \CatC \times \CatC \to \CatC.
    \end{equation}
    Concretely, and in infix notation, this means that
    \begin{equation}
        (\mora \mthen \morc )
        \mtimescat (\morb \mthen \mord )
        =
        (\mora \mtimescat \morb )
        \mthen (\morc \mtimescat \mord )
    \end{equation}
    for all morphisms~$\mora, \morb, \morc$, and $\mord$ where respectively $\mora$ and $\morc$, and $\morb$ and $\mord$ are composable.
\end{ctdefinition}

%More in detail, we have that for any~$n \geq 2$, there is a semifunctor
%%
%\begin{equation}
%    \mtimescat^{(n)}\colon \underbrace {\CatC \times \CatC \times \cdots \times \CatC}_{\text{$n$ times}} \to \CatC.
%\end{equation}
%
This describes a sort of commutativity property: we can either first compose horizontally and then vertically, or vice versa, and we obtain the same morphism~(\cref{fig:stacking-functorial}).

\begin{figure*}[h]
    \centering
    \subfloat[\label{fig:effects6}$(\mora \mtimescat \morb )
            \mthen (\morc \mtimescat \mord )$]{
        %\includegraphics[width=6.5cm]{effects6}
        \includesag{commuting_stacking_eff}
    }=
    \subfloat[\label{fig:effects8}$(\mora \mthen \morc ) \mtimescat (\morb \mthen \mord )$]{
        \includesag{commuting_stacking_eff_bis}
        %\includegraphics[width=6.5cm]{effects8}
    }
    \caption{Commutation of stacking and composition in a functorial stacking semicategory. }
    \label{fig:stacking-functorial}
\end{figure*}

\begin{example}[\SetL is functorial stacking.]
    \label{ex:setfunstack}
    We want to show that~\SetL is a functorial stacking semicategory.

    Consider
    \begin{equation}
        \begin{aligned}
            \mora\colon \cObj{\setAn{1},\ldots,\setAn{m}} & \mto \cObj{\setBn{1},\ldots,\setBn{n}}, \\
            \morb\colon \cObj{\setDn{1},\ldots,\setDn{o}} & \mto \cObj{\setEn{1},\ldots,\setEn{p}}, \\
            \morc\colon \cObj{\setBn{1},\ldots,\setBn{n}} & \mto \cObj{\setCn{1},\ldots,\setCn{q}}, \\
            \mord\colon \cObj{\setEn{1},\ldots,\setEn{p}} & \mto \cObj{\setFn{1},\ldots,\setFn{r}},
        \end{aligned}
    \end{equation}
    We want to show that
    \begin{equation}
        (\mora \mtimescat \morb )
        \mthen (\morc \mtimescat \mord )
        =
        (\mora \mthen \morc ) \mtimescat (\morb \mthen \mord ),
    \end{equation}
    For brevity we write~$\setAeln{}=\tup{\setAeln{1},\ldots, \setAeln{m}}$ and~$\setDeln{}=\tup{\setDeln{1},\ldots, \setDeln{0}}$.
    We have
    \begin{widepar}
        \begin{equation}
            \begin{aligned}
                ((\mora \mtimescat \morb )\mthen (\morc \mtimescat \mord ))(\tup{\setAeln{},\setDeln{}})
                 & =(\morc \mtimescat \mord)(\mora(\setAeln{})\tupconcat \morb(\setDeln{})) \\
                 & =\morc(\mora(\setAeln{}))\tupconcat \mord(\morb(\setDeln{})) \\
                 & =(\mora \mthen \morc)(\setAeln{})\tupconcat (\morb\mthen \mord)(\setDeln{}) \\
                 & =((\mora \mthen \morc ) \mtimescat (\morb \mthen \mord ))(\tup{\setAeln{}, \setDeln{}}),
            \end{aligned}
        \end{equation}
    \end{widepar}
    for all~$\tup{\setAeln{}, \setDeln{}}\setin \cObj{\setAn{1},\ldots,\setAn{m},\setDn{1},\ldots,\setDn{o}}$.

\end{example}
\begin{comment}
\devel{

    \begin{equation}
        \begin{aligned}
            \mora\colon \cObj{\setAn{1}, \ldots,\setAn{m}} & \mto \cObj{\setBn{1}, \ldots, \setBn{n}}, \\
            \morb\colon \cObj{\setDn{1}, \ldots,\setDn{o}} & \mto \cObj{\setEn{1}, \ldots, \setEn{p}}, \\
            \morc\colon \cObj{\setBn{1}, \ldots,\setBn{n}} & \mto \cObj{\setCn{1}, \ldots, \setCn{q}}, \\
            \mord\colon \cObj{\setEn{1}, \ldots,\setEn{p}} & \mto \cObj{\setFn{1}, \ldots, \\setFn{r}},
        \end{aligned}
    \end{equation}
    to which maps~$\mape,\mapf,\mapg,\maph$ are associated.

    We want to show that
    \begin{equation}
        (\mora \mtimescat \morb )
        \mthen (\morc \mtimescat \mord )
        =
        (\mora \mthen \morc ) \mtimescat (\morb \mthen \mord ),
    \end{equation}
    and we do it by showing that the map associated with the left-hand side of the equation corresponds to the one on the right-hand side.
    We know the maps associated to~$(\mora \mtimescat \morb )$ and~$(\morc \mtimescat \mord )$, which are
    \begin{equation}
        \cohm_{\setA,\setD}\then (\mape \funcprod \mapg)\then \cohm_{\setB,\setE},
    \end{equation}
    and
    \begin{equation}
        \cohm_{\setB,\setE}\then (\mapf \funcprod \maph)\then \cohm_{\setC,\setF},
    \end{equation}
    respectively.
    The map associated to~$(\mora \mtimescat \morb )
        \mthen (\morc \mtimescat \mord )$ is therefore
    \begin{equation}
        \label{eq:setL_functorial_a}
        \cohm_{\setA,\setD}\then (\mape \funcprod \mapg)\then \cohm_{\setB,\setE}\then \cohm_{\setB,\setE}\then (\mapf \funcprod \maph)\then \cohm_{\setC,\setF}.
    \end{equation}
    On the other hand, the map associated to~$(\mora \mthen \morc )$ is~$\mape\then \mapf$, and the map associated to~$(\morb \mthen \mord)$ is~$\mapg\then \maph$.
    Therefore, the map associated to~$(\mora \mthen \morc ) \mtimescat (\morb \mthen \mord )$ is
    \begin{equation}
        \cohm_{\setA,\setD}\then ((\mape\then \mapf)\funcprod (\mapg\then \maph))\then \cohm_{\setC,\setD}
    \end{equation}

    \todotext{Now need to finish by showing equivalence of maps}
}
\end{comment}

\Effects is an example of a stacking category that is not functorial.

\begin{lemma}
    \Effects is \emph{not} a functorial stacking semicategory.
\end{lemma}

\begin{proof}
    In general, we do not have
    \begin{equation}
        (\mora \mtimescat \morb )
        \mthen (\morc \mtimescat \mord )
        \neq
        (\mora \mthen \morc ) \mtimescat (\morb \mthen \mord ).
    \end{equation}
    This is shown graphically in \cref{fig:effects-non-functorial}.
\end{proof}

\begin{figure*}[b]
    \centering
    \subfloat[\label{fig:effects7}$(\mora \mtimescat \morb )
            \mthen (\morc \mtimescat \mord )$]{
        %\includegraphics[width=6.5cm]{effects7}
        \includesag{stacking_tup_counterproof}
    }
    \subfloat[\label{fig:effects9} $(\mora \mthen \morc ) \mtimescat (\morb \mthen \mord )$]{
        %\includegraphics[width=6.5cm]{effects9}
        \includesag{stacking_tup_counterproof_bis}
    }
    \caption{Proof that \Effects is not a functorial stacking category by showing that
        the two morphisms above have different representations in~\SetL.}
    \label{fig:effects-non-functorial}
\end{figure*}

\begin{example}
    We want to show that \LTI, as defined, is almost a functorial stacking semicategory, but not quite.
    Given morphisms~$\mora\colon \styleobj{l}\mto \styleobj{m}$,~$\morc\colon \styleobj{m}\mto \styleobj{n}$,~$\morb\colon \styleobj{o}\mto \styleobj{p}$,~$\mord\colon \styleobj{p}\mto \styleobj{q}$, we would need to have
    \begin{equation}
        (\mora \mthen \morc)
        \mtimescat (\morb\mthen \mord)=(\mora\mtimescat \morb)\mthen (\morc\mtimescat \mord).
    \end{equation}
    This, however, is not true.
    Let's see this by looking at the first matrix component of the LTI system.
    On one hand we have:
    \begin{equation}
        \mat{A}_{(\mora \mthen \morc)\mtimescat (\morb\mthen \mord)}=
        \begin{bmatrix}
            \mat{A}_\mora              & \mat{0}       & \mat{0}                    & \mat{0}       \\
            \mat{B}_\morc\mat{C}_\mora & \mat{A}_\morc & \mat{0}                    & \mat{0}       \\
            \mat{0}                    & \mat{0}       & \mat{A}_\morb              & \mat{0}       \\
            \mat{0}                    & \mat{0}       & \mat{B}_\mord\mat{C}_\morb & \mat{A}_\mord
        \end{bmatrix}.
    \end{equation}
    On the other hand we have:
    \begin{equation}
        \mat{A}_{(\mora\mtimescat \morb)\mthen (\morc\mtimescat \mord)}=
        \begin{bmatrix}
            \mat{A}_\mora               & \mat{0}                     & \mat{0}       & \mat{0}       \\
            \mat{0}                     & \mat{A}_\morb               & \mat{0}       & \mat{0}       \\
            \mat{B}_\morc \mat{C}_\mora & \mat{0}                     & \mat{A}_\morc & \mat{0}       \\
            \mat{0}                     & \mat{B}_\mord \mat{C}_\morb & \mat{0}       & \mat{A}_\mord
        \end{bmatrix}.
    \end{equation}
    These two are different, and will therefore describe different systems.
    However, the two matrices just differ by two permutations, which can be expressed via an invertible linear transformation~$\mat{T}$ as follows:
    \begin{equation}
        \mat{A}_{(\mora\mtimescat \morb)\mthen (\morc\mtimescat \mord)}=
        \underbrace{\begin{bmatrix}
                1 & 0 & 0 & 0 \\
                0 & 0 & 1 & 0 \\
                0 & 1 & 0 & 0 \\
                0 & 0 & 0 & 1
            \end{bmatrix}}_{\mat{T}}\cdot
        \mat{A}_{(\mora \mthen \morc)\mtimescat (\morb\mthen \mord)}
        \cdot
        \begin{bmatrix}
            1 & 0 & 0 & 0 \\
            0 & 0 & 1 & 0 \\
            0 & 1 & 0 & 0 \\
            0 & 0 & 0 & 1
        \end{bmatrix}.
    \end{equation}
    The other system matrices also obey \cref{def:equivalence_lti}.
    Therefore, from \cref{lem:equivsystequivact}, we know that although \LTI is not a functorial stacking semicategory,~$(\mora \mthen \morc)\mtimescat (\morb\mthen \mord)$ and~$(\mora\mtimescat \morb)\mthen (\morc\mtimescat \mord)$ have the same action, and hence \LTI modulo action is morally functorial.
\end{example}

\section{Symmetric stacking}

Let~$\CatC$ be an associative stacking category, and consider morphisms
\begin{equation}
    \mora \mtimescatmor \morb \colon \Obja \mtimescatob \Objb \mto \Objc \mtimescatob \Objd
\end{equation}
and
\begin{equation}
    \morc \mtimescatmor \mord \colon \Objd \mtimescatob \Objc \mto \Objf \mtimescatob \Obje.
\end{equation}
If~$\Objc \mtimescatob \Objd \neq \Objd \mtimescatob \Objc$, then the morphisms~$\mora \mtimescatmor \morb$ and~$\morc \mtimescatmor \mord$ are, in our model, technically not composable.
However, in some examples, we will in fact want to be able to compose such morphisms, because in those cases~$\Objc \mtimescatob \Objd$ and~$\Objd \mtimescatob \Objc$ are essentially equal, even if they aren't equal on the nose.

For example,~$\mora, \morb, \morc, \mord$ might be systems, represented graphically by boxes with wires for input and output.
The stacked system~$\mora \mtimescatmor \morb$ will have output wires for~$\Objc$ and $\Objd$, and the stacked system~$\morc \mtimescatmor \mord$ will have input wires for~$\Objd$ and~$\Objc$.
In some applications we are often indeed able to connect the one output wire labeled with~$\Objc$ to the input wire also labeled with~$\Objc$, and similarly for~$\Objd$.

To model this for stacking semicategories, we introduce operations that correspond to switching (or permuting) input and output wires.
Recall that, for each~$n \setin \natnumbers$, the symmetric group $S_n$ is the group of bijections of the set~$\makeset{1, 2, \ldots, n }$ with itself.

%Now consider a a stacking semicategory $\CatC$. For each natural number $n \geq 2$ and each permutation $\sigma \setin S_n$, we define an operation $P_\sigma: \Ob_\CatC \to \Ob_\CatC$ by
%\begin{equation}
%P_\sigma: \Objan{1} \mtimescatob \dots \mtimescatob  \Obja_n \mapsto \Obja_{\sigma(1)} \mtimescatob \dots \mtimescatob  \Obja_{\sigma(n)}
%\end{equation}

\begin{ctdefinition}[Symmetric stacking semicategory]
    \label{def:symmetric-stacking-category}
    A symmetric associative stacking semicategory is an associative stacking semicategory~$\CatC$ with:

    \constit

    \begin{itemize}
        \item Functions
              \begin{equation}
                  L_\sigma \colon \HomSet{\CatC}{\mtimescatob_{i=1}^n \Objan{i}}{\mtimescatob_{i=1}^n \Objbn{i}} \to \HomSet{\CatC}{\mtimescatob_{i=1}^n \Obja_{\sigma(i)}}{\mtimescatob_{i=1}^n \Objbn{i}}
              \end{equation}
              and
              \begin{equation}
                  R_\sigma \colon \HomSet{\CatC}{\mtimescatob_{i=1}^n \Objan{i}}{\mtimescatob_{i=1}^n \Objbn{i}} \to \HomSet{\CatC}{\mtimescatob_{i=1}^n \Objan{i}}{\mtimescatob_{i=1}^n \Objb_{\sigma(i)}}
              \end{equation}
              for every~$\sigma \setin S_n$,~$n \geq 2$.
    \end{itemize}

    \condit

    \begin{itemize}

        \item \emph{Compatibility with composition:}

              For all $\mora \setin \HomSet{\CatC}{\Obja}{\mtimescatob_{i=1}^n \Objbn{i}}$ and $\morb \setin \HomSet{\CatC}{\mtimescatob_{i=1}^n \Objb_{\sigma(i)}}{\Objc}$
              \begin{equation}
                  R_\sigma (\mora) \mthen \morb = \mora \mthen L_{\sigma^{-1}}(\morb).
              \end{equation}

        \item \emph{Compatibility with stacking:}

              Given~$\moran{i} \colon \Objan{i} \mto \Objbn{i}$,~$1 \leq i \leq n$, it holds that
              \begin{equation}
                  R_\sigma ( \mtimescatmor_{i=1}^n \moran{i} ) = L_\sigma(  \mtimescatmor_{i=1}^n \mora_{\sigma^{-1}(i)} ).
              \end{equation}

        \item \emph{Compatibility with permutation composition:}

              The equations
              \begin{equation}
                  L_\sigma \then L_\pi = L_{\pi \then \sigma}
                  \quad \text{ and } \quad
                  R_\sigma \then R_\pi = R_{\sigma \then \pi}
              \end{equation}
              hold for all~$\sigma, \pi \setin S_n$,~$n \geq 2$.

    \end{itemize}
\end{ctdefinition}

%\begin{figure*}[b]
%    %\includegraphics[width=8cm]{symmetric}
%    \centering
%    \subfloat[]{
%        \includesag{symmetric_stacking}
%    }
%    \subfloat[]{
%        \includesag{symmetric_stacking_bis}
%    }
%    \caption{
%        Illustration of \cref{eq:symmetric-condition}.
%    }
%    \label{fig:stacking-symmetric}
%\end{figure*}

\begin{example}
    \SetL is symmetric in a straightforward manner.
\end{example}

\begin{lemma}
    \Effects is not symmetric.
\end{lemma}

\todographicsjira{431}{@Andrea: Add figure for this lemma, in the same style as \cref{fig:effects-non-functorial} }

\todojira{699}{Example of \LTI with $d=0$ a symmetric semicat}

\devel{

    \section{Strict monoidal semicategories}

    \begin{ctdefinition}
        A \emph{strict monoidal semicategory} is a functorial stacking semicategory $\tup{\CatC, \mtimescat}$ with

        \constit

        \begin{itemize}
            \item an object $\idmoncat \setin \Ob_{\CatC}$, called the \emph{monoidal unit}
        \end{itemize}

        \condit

        \begin{itemize}
            \item For any object $\Obja$ of $\CatC$,
                  \begin{equation}
                      \Obja \mtimescat \idmoncat = \Obja \qquad \text{and} \qquad  \idmoncat \mtimescat  \Obja = \Obja.
                  \end{equation}
            \item The monoidal unit $\idmoncat$ has an identity morphism $\catid_\idmoncat$, and for any morphism $\mora: \Obja \mto \Objb$,
                  \begin{equation}
                      \mora \mtimescat \catid_\idmoncat = \mora \qquad \text{and} \qquad \catid_\idmoncat \mtimescat  \mora = \mora.
                  \end{equation}
        \end{itemize}

    \end{ctdefinition}

    \todotext{@JL: write def of symmetric strict monoidal semicategory}

}
