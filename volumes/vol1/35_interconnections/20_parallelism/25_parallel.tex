% !TEX root = chapter-standalone.tex

\section{Parallel stacking}
\label{sec:parallel-stacking}

So far we have seen how we can compose morphisms ``horizontally'':
%
\begin{equation}
    \prfperiod{
        \mora \colon \Obja \mto \Objb
    }{
        \morb\colon \Objb \mto \Objc
    }{
        \morab \colon \Obja \mto \Objc
    }
\end{equation}
%
There are other notions of composition that allow us to compose morphisms by ``stacking them vertically''.
Given two morphisms
%
\begin{align}
    \mora & \colon \Obja \mto \Objb, \\
    \morb & \colon \Objc \mto \Objd,
\end{align}
%
we will obtain by parallel stacking a morphism
%
\begin{align}
    (\mora\mtimescatmor \morb)
     & \colon (\Obja \mtimescatob \Objc) \mto (\Objb \mtimescatob \Objd),
\end{align}
%
where ``$\mtimescat$'' is a stacking operation to be defined.
Note that while in the case of sequential composition there was a compatibility condition to be defined, as the target of the first morphism must be the source of the second morphism, here instead we can stack arbitrary morphisms.

We also expect to be able to stack any number of morphisms.
Having a collection of morphisms
%
\begin{equation}
    \moran{i} \colon \Objan{i} \mto \Objbn{i}, \qquad 1 \leq i \leq n,
\end{equation}
%
we expect to be able to obtain the composed morphism
%
\begin{equation}
    (\mtimescat_{i=1}^n \moran{i} )
    \colon( \mtimescat_{i=1}^n \Objan{i} )\mto (\mtimescat_{i=1}^n \Objbn{i}).
\end{equation}

\subsection{Types of stacking operations}

There are various properties that we can consider for this stacking operation.
The ones that we will consider in this chapter are:
%
\begin{enumerate}
    \item \emph{Stacking semicategory} (\cref{def:simple-stacking-semi-cat}): a \SY{semicategory} in which it is possible to stack two morphisms.
    \item \emph{Associative stacking semicategory} (\cref{def:stacking-semi-cat}): a \SY{semicategory} in which the stacking operation is \SY{associative} and makes objects and morphisms into a \SY{semigroup}.
    \item \emph{Functorial stacking semicategory} (\cref{def:functorial-stacking-semi-cat}): a stacking \SY{semicategory} in which the stacking operation is also a \SY{functor}.
    \item \emph{Symmetric stacking semicategory}: a stacking \SY{semicategory} in which there is a series of symmetry operations that can permute the objects in a stack.
\end{enumerate}
%
In the next part we will talk about \emph{monoidal categories} (\cref{def:monoidal-cat}), which can be seen as a generalization of \SY{associative stacking} \SY{semicategories} where the stacking operation is not required to be \SY{associative} ``on the nose'', but rather only up to isomorphism.

\todotext{This list / overview needs to be updated}

\begin{remark}
    [Choices in definitions~$\star$]
    Of all these definitions, the only ``classical'' one is that of \emph{monoidal category}, and its specializations, such as \SY{strict monoidal category}, \SY{braided monoidal category}, and \SY{symmetric monoidal category}.
    We will look at all of those in~\cref{sec:parallelism-mon-cat}.

    We define the three non-classical notions mentioned above for the following reasons:
    \begin{itemize}
        \item Using the strictification construction of \SetL all the \SY{monoidal categories} that we need through the book are strict.
              Therefore, we can study parallel and feedback composition without knowing \SY{natural transformations}.

        \item There are important cases of \SY{semicategories} without identities with a stacking operation that do not fit the notion of \SY{monoidal category}.
              An example is discrete-time linear systems.
              For these categories we also want to consider appropriate traces.
        \item There are important examples in which there is a way to stack morphisms, but the stacking is not functorial.
              For example, we will describe a category of effectful computation with side effects.
    \end{itemize}
\end{remark}

\subsection{Stacking semicategories}

\begin{marginfigure}
    \centering
    \includesag{parallelism-stacked-morphisms}
    %\includegraphics[scale=0.12]{parallelism_stacked-morphisms}
    \caption{Stacked morphisms}
    \label{fig:stacked-morphisms}
\end{marginfigure}

\begin{marginfigure}
    \centering
    \includesag{parallelism_stacked-morphisms-diagram}
    %\includegraphics[scale=0.17]{parallelism_stacked-morphisms-diagram}
    \caption{Stacking string diagrams}
    \label{fig:stacked-morphisms-diagram}
\end{marginfigure}

\begin{ctdefinition}[Stacking semicategory]
    \label{def:simple-stacking-semi-cat}
    A \maindef{stacking semicategory} is a \SY{semicategory}~\CatC with the following additional constituents and properties.

    \constit
    \begin{itemize}
        \item A stacking operation~$\mtimescatob \colon \ObC \cartprod \ObC \to \ObC$.
        \item A stacking operation~$\mtimescatmor \colon \Mor_\CatC \cartprod \Mor_\CatC \to \Mor_\CatC$.
    \end{itemize}

    \condit
    \begin{itemize}
        \item The two operations~$\mtimescatob$ and~$\mtimescatmor$ are compatible in the sense that
              %
              \begin{equation}
                  \prfperiod{
                      \moran{1} \colon \Objan{1} \mto \Objbn{1}
                      \qquad
                      \moran{2} \colon \Objan{2} \mto \Objbn{2}
                  }{
                      \moran{1} \mtimescatmor \moran{2} \colon  \Objan{1} \mtimescatob  \Objan{2} \mto \Objbn{1} \mtimescatob \Objbn{2}
                  }
              \end{equation}
    \end{itemize}
\end{ctdefinition}

In \cref{fig:stacked-morphisms} we have depicted a string diagram of two stacked morphisms.
Alternatively, in \cref{fig:stacked-morphisms-diagram} we depict the stacking of the string diagrams for $\moran{1}$ and $\moran{2}$, respectively, by stacking their diagrams vertically and drawing a box around them, merging their respective input and output terminals.
The outer box denotes $\moran{1} \mtimescatmor \moran{2}$; we think of \cref{fig:stacked-morphisms} as a ``black-boxed'' version of \cref{fig:stacked-morphisms-diagram}.

\begin{figure*}[tbh]
    \centering
    \begin{subfigure}{0.49\linewidth}
        \includesag{parallelism_associative-stacking-1}
        %\includegraphics[scale=0.15]{parallelism_associative-stacking-1}
        \caption{One way of stacking three morphisms}
        \label{fig:associative-stacking-1}
    \end{subfigure}
    %
    \begin{subfigure}{0.49\linewidth}
        \includesag{parallelism_associative-stacking-2}
        %\includegraphics[scale=0.15]{parallelism_associative-stacking-2}
        \caption{Another way of stacking three morphisms}
        \label{fig:associative-stacking-2}
    \end{subfigure}
    \caption{Stacking three morphisms.}
\end{figure*}

\begin{ctdefinition}[Associative stacking semicategory]
    \label{def:stacking-semi-cat}
    An \maindef{associative stacking semicategory} is a \SY{stacking semicategory} satisfying the following.

    \condit
    \begin{itemize}
        \item The stacking operation~$\mtimescatob$ makes the objects into a \SY{semigroup}.
        \item The stacking operation~$\mtimescatmor$ makes the morphisms into a \SY{semigroup}.
    \end{itemize}
\end{ctdefinition}

If a \SY{semicategory} is \SY{associative stacking}, then the two ways of stacking three morphisms -- as depicted in \cref{fig:associative-stacking-1} and \cref{fig:associative-stacking-2}, respectively -- give the same result.
For \SY{associative stacking} \SY{semicategories} we will use a simpler diagrammatic notation, where the diagrams in \cref{fig:associative-stacking-1} and \cref{fig:associative-stacking-2} instead look like the ones in \cref{fig:associative-stacking-1-new} and \cref{fig:associative-stacking-2-new}.
Since these two diagrams depict that same morphism, when it is convenient we will also simply depict them as in \cref{fig:triple-stacked} (and similarly for any number of stacked morphisms).
In particular, in an \SY{associative stacking} \SY{semicategory}, and stacking of two morphisms will be depicted as in \cref{fig:double-stacked-new}.

\begin{marginfigure}[]
    \centering
    \includesag{parallelism_associative-stacking-1-new}
    %\includegraphics[scale=0.15]{parallelism_associative-stacking-1-new}
    \caption{Associative stacking of three morphisms, in one order.}
    \label{fig:associative-stacking-1-new}
\end{marginfigure}

\begin{marginfigure}
    \centering
    \includesag{parallelism_associative-stacking-2-new}
    %\includegraphics[scale=0.15]{parallelism_associative-stacking-2-new}
    \caption{Associative stacking of three morphisms, in another order.}
    \label{fig:associative-stacking-2-new}
\end{marginfigure}

\begin{marginfigure}
    \centering
    \includesag{parallelism-triple-stacked}
    %\includegraphics[scale=0.15]{parallelism_triple-stacked}
    \caption{Our string diagram notation for a triple stack.}
    \label{fig:triple-stacked}
\end{marginfigure}

\begin{figure}[h!]
    \centering
    \includesag{parallelism-associative-stacking-two-new}
    %\includegraphics[scale=0.15]{parallelism_associative-stacking-two-new}
    \caption{Associative stacking of two morphisms.}
    \label{fig:double-stacked-new}
\end{figure}

\begin{remark}
    In an \SY{associative stacking} \SY{semicategory} it follows that we can stack any number of morphisms without needing to bracket using parentheses:
    \begin{equation}
        \prfperiod{
            \moran{i} \colon \Objan{i} \mto \Objbn{i}, \qquad 1 \leq i \leq n,
        }{
            \mtimescatmor_{i=1}^n \moran{i} \colon \mtimescatob_{i=1}^n \Objan{i} \mto \mtimescatob_{i=1}^n \Objbn{i}.
        }
    \end{equation}
\end{remark}
\clearpage
\begin{lemma}
    \label{lem:SetL-is-associative-stacking}
    \SetL is  \SY{associative stacking} using the structure that arises from tuple concatenation.
    % by setting $\mtimescatob_{\SetL} \definedas \cprod$
    % and $\mtimescatmor_{\SetL} \definedas \cprod$
\end{lemma}
\begin{proof}
    % In this example we show that~\SetL is an  \SY{associative stacking} semicategory.
    % We first show that it is a stacking category.
    % To do so, we start by showing that the stacking operations fulfill \cref{def:simple-stacking-semi-cat}.
    For the stacking operation on objects $\mtimescatob$ we use the operation $\cprod$ defined in \cref{sec:cartcatset} which was referred to as the ``multiplication in \SetL''.
    \\
    As for $\mtimescatmor$, we define it as follows:
    \begin{equation}
        \label{eq:mtimescatmor-SetL}
        \prfperiod{
            \mora\colon\setA\mtoin\SetL\setB
        }{
            \quad
        }{
            \morb\colon\setC\mtoin\SetL\setD
        }{
            \defmap{
                (\mora\mtimescatmor\morb )
            }{
                \setA \cprod \setC
            }{
                \mtoin\SetL
            }{
                \setB \cprod \setD
            }{
                \maketupconcat{\ela, \elc}
            }{
                \maketupconcat{\mora(\ela), \morb(\elc)}
            }
        }
    \end{equation}
    The two operations $\mtimescatob, \mtimescatmor$ so defined satisfy the compatibility conditions
    required by \cref{def:simple-stacking-semi-cat}.

    To show associativity, consider three morphisms
    \begin{equation}
        % \begin{aligned}
        \mora\colon\setA\mtoin\SetL\setB,\qquad
        \morb\colon\setC\mtoin\SetL\setD,\qquad
        \morc\colon\setE\mtoin\SetL\setF.
        % \end{aligned}
    \end{equation}
    We compute $\mora\mtimescatmor(\morb\mtimescatmor\morc)$ and $(\mora\mtimescatmor\morb)\mtimescatmor\morc$ following the recipe \cref{eq:mtimescatmor-SetL} to obtain
    \begin{equation}
        \defmapcomma{
            \parslight{\mora\mtimescatmor\morb}\mtimescatmor\morc
        }{
            \parslight{\setA \cprod \setC} \cprod \setE
        }{
            \mtoin\SetL
        }{
            \parslight{\setB \cprod \setD} \cprod \setF
        }{
            \maketupconcat{\parslight{\maketupconcat{\ela, \elc}}, \ele}
        }{
            \maketupconcat{\parslight{\maketupconcat{\mora(\ela), \morb(\elc)}}, \morc(\ele) }
        }
    \end{equation}
    \begin{equation}
        \defmapperiod{
            \mora\mtimescatmor\parslight{\morb\mtimescatmor\morc}
        }{
            \setA \cprod \parslight{\setC \cprod \setE}
        }{
            \mtoin\SetL
        }{
            \setB \cprod \parslight{\setD \cprod \setF}
        }{
            \maketupconcat{\ela, \parslight{\maketupconcat{\elc, \ele}}}
        }{
            \maketupconcat{\mora(\ela), \parslight{\maketupconcat{\morb(\elc), \morc(\ele)}}}
        }
    \end{equation}
    Notice that the operations $\cprod$ and $\tupconcat$ are associative; therefore, we can remove all the light parentheses that appear in the formulas.
    This implies that both functions are equal to
    \begin{equation}
        \defmapperiod{
            \mora\mtimescatmor\morb\mtimescatmor\morc
        }{
            \setA \cprod \setC \cprod \setE
        }{
            \mtoin\SetL
        }{
            \setB \cprod \setD \cprod \setF
        }{
            \maketupconcat{\ela, \elc, \ele}
        }{
            \maketupconcat{\mora(\ela), \morb(\elc), \morc(\ele)}
        }
    \end{equation}
    % \begin{equation}
    %     \defmapperiod{
    %         \mtimescatob
    %     }{
    %         \Obof{\SetL} \cartprod \Obof{\SetL}
    %     }{
    %         \mto
    %     }{
    %         \Obof{\SetL}
    %     }{
    %         \tup{\cObj{\setAn{1},\ldots, \setAn{n}}, \cObj{\setBn{1},\ldots,\setBn{m}}}
    %     }{
    %         \cObj{\setAn{1},\ldots, \setAn{n}, \setBn{1},\ldots,\setBn{m}}
    %     }
    % \end{equation}
    % The stacking operation on morphisms is defined as
    % \begin{equation}
    %     \defmapcomma{
    %         \mtimescatmor
    %     }{
    %         \Mor_{\SetL} \cartprod \Mor_{\SetL}
    %     }{
    %         \mto
    %     }{
    %         \Mor_{\SetL}
    %     }{
    %         \tup{\mora,\morb}
    %     }{
    %         \mora \cprod \morb
    %     },
    % \end{equation}
    % where~$(\mora \cprod \morb)(\tup{\setAeln{1},\ldots, \setAeln{m}} \tupconcat \tup{\setBel_1,\ldots, \setBel_n})\definedas \mora(\tup{\setAeln{1},\ldots, \setAeln{m}})\tupconcat \morb(\tup{\setBel_1,\ldots, \setBel_n})$.
    % This is indeed a map between sets.
    % The two operations are compatible, because
    % \begin{widepar}
    %     \begin{equation}
    %         \prfperiod{
    %             \mora\colon \cObj{\setAn{1},\ldots,\setAn{n}}\mto \cObj{\setBn{1},\ldots,\setBn{m}}
    %         }{
    %             \morb\colon \cObj{\setCn{1},\ldots,\setCn{o}}\mto \cObj{\setDn{1},\ldots,\setDn{p}}
    %         }{
    %             \mora \mtimescatmor \morb \colon \cObj{\setAn{1}, \ldots, \setAn{n}, \setCn{1}, \ldots, \setCn{o}} \mto \cObj{\setBn{1}, \ldots, \setBn{m}, \setDn{1}, \ldots, \setDn{p}}
    %         }
    %     \end{equation}
    % \end{widepar}

    % We now show associativity.
    % We have already shown in \cref{sec:cartcatset} that~$\cprod$ satisfies the properties of a \SY{semigroup} operation.
    % For the operation on morphisms, consider
    % \begin{equation}
    %     \begin{aligned}
    %         \mora\colon \cObj{\setAn{1},\ldots,\setAn{m}} & \mto \cObj{\setBn{1}, \ldots, \setBn{n}}, \\
    %         \morb\colon \cObj{\setCn{1},\ldots,\setCn{o}} & \mto \cObj{\setDn{1},\ldots,\setDn{p}}, \\
    %         \morc\colon \cObj{\setEn{1},\ldots,\setEn{q}} & \mto \cObj{\setFn{1},\ldots,\setFn{r}},
    %     \end{aligned}
    % \end{equation}
    % For brevity, we write~$\setAeln{}=\tup{\setAeln{1},\ldots, \setAeln{m}}$,~$\setCeln{}=\tup{\setCeln{1},\ldots, \setCeln{o}}$, and~$\setEeln{}=\tup{\setEeln{1},\ldots,\setEeln{q}}$.
    % We have
    % \begin{align}
    %     ((\mora \cprod \morb)\cprod \morc)(\tup{\setAeln{}, \setCeln{},\setEeln{}})
    %      & =(\mora(\setAeln{})\tupconcat \morb(\setCeln{}))\tupconcat \morc(\setEeln{}) \\
    %      & =\mora(\setAeln{})\tupconcat \morb(\setCeln{})\tupconcat \morc(\setEeln{}) \\
    %      & =\mora(\setAeln{})\tupconcat (\morb(\setCeln{})\tupconcat \morc(\setEeln{})) \\
    %      & =(\mora \cprod (\morb\cprod \morc))(\tup{\setAeln{}, \setCeln{},\setEeln{}})
    % \end{align}
    % for all~$\tup{\setAeln{}, \setCeln{},\setEeln{}}\setin \cObj{\setAn{1},\ldots,\setAn{m},\setCn{1},\ldots,\setCn{o},\setEn{1},\ldots,\setEn{q}}$.

\end{proof}

% \begin{comment}
% \todotext{The example below is perhaps deprecated if we no longer use Set* as a main character in our story}

% \begin{example}
%     \SetL is an  \SY{associative stacking} semicategory.
%     We first show that it is a stacking category.
%     The stacking operation on objects is defined as list concatenation:
%     \begin{equation}
%         \defmapperiod{\mtimescatob}{\Ob_{\SetL} \cartprod \Ob_{\SetL}}{\mto}{\Ob_{\SetL}}{\tup{\Tupcatt{\setAn{1}}{\ldots}{ \setAn{n}}, \Tupcatt{\setBn{1}}{\ldots}{\setBn{m}}}}{\Tupcatt{\setAn{1}}{\ldots}{\setAn{n}} \listconcat \Tupcatt{\setBn{1}}{\ldots}{\setBn{m}}}
%     \end{equation}
%     The stacking operation on morphisms is defined as
%     \begin{equation}
%         \defmapperiod{\mtimescatmor}{\Mor_{\SetL} \cartprod \Mor_{\SetL}}{\mto}{\Mor_{\SetL}}{\tup{\mora,\morb}}{\more},
%     \end{equation}
%     which, given~$\mora\colon \Tupcatt{\setAn{1}}{\ldots}{\setAn{n}}\mto \Tupcatt{\setBn{1}}{\ldots}{\setBn{m}}$ (given by a map~$\mapc$) and~$\Tupcatt{\setCn{1}}{\ldots}{\setCn{o}}\mto \Tupcatt{\setDn{1}}{\ldots}{\setDn{p}}$ (given by a map~$\mapd$) is given by a function
%     \begin{equation}
%         \mape \definedas \cohm_{\setA,\setC}\then (\mapc\funcprod \mapd) \then \cohm_{\setB,\setD},
%     \end{equation}
%     which has signature
%     \begin{widepar}
%         \begin{equation}
%             \setAn{1}\cartprod (\setA_2\cartprod (\ldots \cartprod (\setAn{n} \cartprod (\setCn{1} \cartprod(\setC_2 \cartprod (\ldots \cartprod \setCn{o}))))))
%             \to
%             \setBn{1}\cartprod (\setB_2\cartprod (\ldots \cartprod (\setBn{m} \cartprod (\setDn{1} \cartprod (\setD_2 \cartprod(\ldots \cartprod \setDn{p})))))).
%         \end{equation}
%     \end{widepar}
%     The two operations are compatible, because
%     \begin{widepar}
%         \begin{equation}
%             \prfperiod{\mora\colon \Tupcatt{\setAn{1}}{\ldots}{\setAn{n}}\mto \Tupcatt{\setBn{1}}{\ldots}{\setBn{m}}}
%             {\morb\colon \Tupcatt{\setCn{1}}{\ldots}{\setCn{o}}\mto \Tupcatt{\setDn{1}}{\ldots}{\setDn{p}}}
%             {\more\colon \Tupca{\setAn{1}\setconcat \ldots \setconcat \setAn{n} \setconcat \setCn{1} \setconcat \ldots \setconcat \setCn{o}} \mto \Tupca{\setBn{1}\setconcat \ldots \setconcat \setBn{m} \setconcat \setDn{1} \setconcat \ldots \setconcat \setDn{p}}}
%         \end{equation}
%     \end{widepar}
%     Note that using the coherence morphisms is needed for the compatibility conditions to hold.

%     We now show associativity.
%     We have already shown in \cref{sec:semigroups} that the concatenation of lists satisfies the properties of a \SY{semigroup} operation.
%     Showing associativity of the operation on the morphisms is more cumbersome.
%     Consider morphisms
%     \begin{equation}
%         \begin{aligned}
%             \mora\colon \Tupcatt{\setAn{1}}{\ldots}{\setAn{m}} & \mto \Tupcatt{\setBn{1}}{\ldots}{\setBn{n}}, \\
%             \morb\colon \Tupcatt{\setCn{1}}{\ldots}{\setCn{o}} & \mto \Tupcatt{\setDn{1}}{\ldots}{\setDn{p}}, \\
%             \morc\colon \Tupcatt{\setEn{1}}{\ldots}{ \\setEn{q}} & \mto \Tupcatt{\\setFn{1}}{\ldots}{\\setFn{r}},
%         \end{aligned}
%     \end{equation}
%     to which maps~$\mapd,\mape,\mapf$ are associated.

%     We have:

%     \begin{center}
%         \begin{tikzpicture}
%             \node at (0,0){
%                 \begin{tikzcd}[every arrow/.append style={-Triangle, draw=morphisms}, column sep=large]
%                     (\mora \mtimescatmor \morb)
%                     \mtimescatmor \morc                                                                                                                                                                      & \mora \mtimescatmor (\morb \mtimescatmor \morc) \\
%                     \tupset{((\setLA \listconcat \setLC)\listconcat \setLE)}\arrow[d,"\cohm_{\setLA\listconcat \setLC, \setLE}^{-1}"]\arrow[r, equal]                                                        & \tupset{(\setLA \listconcat (\setLC\listconcat \setLE))}\arrow[d] \\
%                     \tupset{(\setLA\listconcat \setLC)}\cartprod \tupset{(\setLE)}\arrow[d, "\cohm_{\tupset{(\setLA)}, \tupset{(\setLC)}}^{-1} \funcprod \catid_{\tupset{(\setLC)}}"]                         & \tupset{(\setLA)}\cartprod \tupset{(\setLC \listconcat \setLE)}\arrow[d] \\
%                     (\tupset{(\setLA)}\cartprod \tupset{(\setLC)})\cartprod \tupset{(\setLE)}\arrow[r, "\alpha"]\arrow[d, "(\mapd \funcprod \mape)\funcprod \mapf"]                                          & \tupset{(\setLA)}\cartprod (\tupset{(\setLC)}\cartprod \tupset{(\setLE)})\arrow[d, "\mapd \funcprod (\mape\funcprod \mapf)"] \\
%                     (\tupset{(\setLB)}\cartprod \tupset{(\setLD)})\cartprod \tupset{(\setLF)}\arrow[r, "\alpha"]\arrow[d, "\cohm_{\tupset{(\setLB)}, \tupset{(\setLD)}}\funcprod \catid_{\tupset{(\setLF)}}"] & \tupset{(\setLB)}\cartprod (\tupset{(\setLD)}\cartprod \tupset{(\setLF)})\arrow[d] \\
%                     \tupset{(\setLB\listconcat \setLD)}\cartprod \tupset{(\setLF)}\arrow[d,"\cohm_{\setLB\listconcat \setLD, \setLF}"]                                                                       & \tupset{(\setLB)} \cartprod \tupset{(\setLD \listconcat\setLF)}\arrow[d] \\
%                     \tupset{((\setLB \listconcat \setLD)\listconcat \setLF)}\arrow[r, equal]                                                                                                                 & \tupset{(\setLB \listconcat (\setLD\listconcat \setLF))}
%                 \end{tikzcd}
%             };
%         \end{tikzpicture}
%     \end{center}
%     \todo{finish diagram above}
% \end{example}
% \end{comment}

%
%\begin{definition}
%    An  \SY{associative stacking} semicategory is called \emph{commutative} if its two stacking operations make the collections of objects and morphisms, respectively, into commutative semigroups.
%\end{definition}

\subsection{The \SY{semicategory} \Effects}

We now construct a non-trivial \SY{semicategory} that will serve as an example of a stacking \SY{semicategory} that is not functorial.

There are two types of computation: ``functional'', or ``pure'', or free of side effects, and \emph{effectful}.
In functional programming, functions are very much like mathematical functions: they need an input and produce and output.
They don't interfere with other functions.

Effectful procedures, instead, can ``change the world'': for example, printing a page, sending an email, or placing an order of pizza.
The order in which effectful procedures are evaluated might change the result.
For example, the result of the sequence of operations
%
\begin{enumerate}
    \item Order a pizza;
    \item Cancel the last order;
\end{enumerate}
%
is different from the result of the sequence of operations
%
\begin{enumerate}
    \item Cancel the last order;
    \item Order a pizza;
\end{enumerate}

A very elegant way to treat side effects mathematically is using \emph{linear types}~\cite{Wadler90lineartypes}.
We will mention those in a successive part on linear logic.
For now, we stick to a simple treatment.

\begin{marginfigure}
    \centering
    \subfloat[\label{fig:effects1}
        A morphism~$\mora\colon \Obja \mtoin{\Effects} \Objb$ in \Effects.
    ]{
        \rule{1cm}{0pt}\includesag{morphism_eff}\rule{1cm}{0pt}
    }\\
    \subfloat[\label{fig:effects2}
        Its representation in \SetL as a morphism
        $\repreff{\mora}\colon \cObj{\Obja,\EfW} \mtoin{\SetL} \cObj{\Objb, \EfW}$.
    ]{
        \rule{1cm}{0pt}\includesag{morphism_tup}\rule{1cm}{0pt}
    }
    \caption{}
    \label{fig:effects12}
\end{marginfigure}

We are going to define a category \Effects.
The idea is to add another variable that represents ``the world'' that can be affected.
An effectful function
%
\begin{equation}
    \mora\colon \Obja \mtoin{\Effects} \Objb,
\end{equation}
%
which could have some unknown side effects on the world, can be represented by a pure function
\begin{equation}
    \repreff{\mora}\colon \Obja \cartprod \EfW \mtoin{\Set} \Objb \cartprod \EfW,
\end{equation}
or, in other words, as a morphism
\begin{equation}
    \repreff{\mora}\colon \cObj{\Obja,\EfW} \mtoin{\SetL} \cObj{\Objb, \EfW},
\end{equation}
%
where~$\EfW$ is the set of all possible worlds~(\cref{fig:effects12}).

The second input to~$\repreff{\mora}$ is the state of the world before the execution of the function.
The second output of~$\repreff{\mora}$ is the state of the world after the execution of the function.

We can now interconnect different effectful functions, with some precautions.
We cannot ``split the world'', by creating a function of type~$\EfW \to \EfW \cartprod \EfW$.
We will re-state this formally when we get to linear logic.

\begin{marginfigure}
    \centering
    \subfloat[\label{fig:effects3}
        Composition in \Effects.
    ]{
        \includesag{morphism_eff_comp}
        %\includegraphics[width=4.5cm]{effects3}
    }\\
    \subfloat[\label{fig:effects3b}
        Its representation in \SetL.
    ]{
        \includesag{morphism_tup_comp}
        %\includegraphics[width=4.5cm]{effects3b}
    }
    \caption{}
    \label{fig:effect-composition}
\end{marginfigure}

We can extend usual function composition to composition of effectful functions as in~\cref{fig:effect-composition}.
The second effectful function operates on the world after it was possibly modified by the first effectful function.

We have all the ingredients to define the category \Effects of effectful computation.

\begin{definition}[Category of effectful procedures \Effects]
    \SYNDEF{category of sets and functions with side effects}
    \label{def:Effects}
    Fix a set~$\EfW$ of all possible worlds.
    The category~$\Effects$ is defined by the following:
    \begin{itemize}
        \item \emph{Objects}: same as the objects of \SetL;
        \item \emph{Morphisms}: a morphism~$\mora\colon \Obja \mtoin{\Effects} \Objb$ is a morphism
              \begin{equation}
                  \repreff{\mora}\colon \cObj{\Obja, \EfW} \mtoin{\SetL} \cObj{\Objb, \EfW}.
              \end{equation}
        \item \emph{Composition}: The composition of~$\mora\colon \Obja \mtoin{\Effects} \Objb$ and~$\morb\colon \Objb \mtoin{\Effects} \Objc$ is the morphism~$\morab\colon \Obja \mtoin{\Effects} \Objc$ with~$\repreff{\morab}$ given by
              \begin{equation}
                  \repreff{\mora \mthenof \Effects \morb}
                  = \repreff{\mora} \mthenof{\SetL} \repreff{\morb}
              \end{equation}
              as illustrated in \cref{fig:effect-composition}.
    \end{itemize}
\end{definition}

\begin{marginfigure}
    \centering
    \subfloat[\label{fig:effects4}
        Stacking in \Effects]{
        \includesag{stacking_eff}
        %\includegraphics[width=4.5cm]{effects4}
    }

    \subfloat[\label{fig:effects5} Its representation in \SetL]{
        %\includegraphics[width=4.5cm]{effects5}
        \includesag{stacking_tup}
    }
    \caption{}
    \label{fig:effect-stacking}
\end{marginfigure}

We can now make \Effects into a stacking \SY{semicategory} by deciding how to evaluate a stack of functions.
We cannot evaluate them in parallel.
We need to decide on a sequence.
For example, top to bottom.
This is shown in~\cref{fig:effect-stacking}.

\begin{lemma}
    \label{lem:effects-is-stacking}
    \Effects is an  \SY{associative stacking} category using the evaluation rule as in~\cref{fig:effect-stacking}.
\end{lemma}

\todotextjira{415}{\bernina: @Andrea: proof.
    Need to show \SY{semigroup}.
}

\subsection{\Moore is associative stacking}
When considering Moore machines, we can define stacking operations and show that \Moore forms a stacking \SY{semicategory} (\cref{def:simple-stacking-semi-cat}).
The objects of \Moore are objects of \SetL, and therefore the stacking operation for objects corresponds to the ``multiplication in \SetL'', denoted by $\cprod$.

The operation on morphisms ``stacks'' Moore machines onto each other.
Formally:

\begin{equation*}
    \prfcomma{\mora\colon \prin_\mora \mtoin{\Moore} \prout_\mora}{\mora\colon \prin_\morb \mtoin{\Moore} \prout_\morb}
    {\mora \mtimescatmor \morb=\tup{\prin_\mora \cprod \prin_\morb, \prst_\mora \cprod \prst_\morb,\prout_\mora \cprod \prout_\morb, \prdyn_{\mora \mtimescatmor \morb},\prreadout_{\mora \mtimescatmor \morb}, \prstart_\mora \tupconcat \prstart_\morb}}
\end{equation*}
with
\begin{equation*}
    \defmapcomma{\prdyn_{\mora \mtimescatmor \morb}}{\prin_\mora \cprod \prin_\morb \cprod \prst_\mora \cprod \prst_\morb}
    {\sto}{\prst_\mora \cprod \prst_\morb}{\prinel_\mora \tupconcat \prinel_\morb \tupconcat \prstel_\mora \tupconcat \prstel_\morb}
    {\prdyn_\mora(\prinel_\mora \tupconcat \prstel_\mora)\tupconcat \prdyn_\morb(\prinel_\morb \tupconcat \prstel_\morb)}
\end{equation*}
and
\begin{equation*}
    \defmapperiod{\prreadout_{\mora \mtimescatmor \morb}}
    {\prst_\mora \cprod \prst_\morb}{\sto}{\prout_\mora \cprod \prout_\morb}
    {\prstel_\mora \tupconcat \prstel_\morb}{\prreadout(\prstel_\mora)\tupconcat \prreadout(\prstel_\morb)}
\end{equation*}
While we have already proved that the operation $\cprod$ is associative, it is also easy to see that the stacking of Moore machines is associative.
Therefore, \Moore equipped with the described stacking operations forms an \SY{associative stacking} \SY{semicategory}.

\subsection{LTI is associative stacking}
When considering LTI systems, we can define stacking operations and show that \LTI forms a stacking \SY{semicategory} (\cref{def:simple-stacking-semi-cat}).
The stacking operation on objects is just addition on the natural numbers:
\begin{equation}
    \defmapperiod{
        \mtimescatob
    }{
        \Obof\LTI \cartprod \Obof\LTI
    }{
        \to
    }{
        \Obof\LTI
    }{
        \tup{\styleobj{l},\styleobj{m}}
    }{
        \styleobj{l}+\styleobj{m}
    }
\end{equation}
On the other hand, the operation on morphisms ``stacks'' the LTI systems onto each other\footnote{For the control engineers out there: the resulting LTI system will have a Relative Gain Array (RGA) matrix corresponding to the identity matrix.
}.
Formally:
\begin{equation}
    \prfperiod{
        \mora \colon \styleobj{l}\mtoin\LTI \styleobj{m}
    }{
        \morb \colon \styleobj{n}\mtoin\LTI \styleobj{o}
    }{
        \mora\mtimescatmor\morb = \genericlti{} \colon
        \styleobj{l+n}\mtoin\LTI \styleobj{m+o}
    }
\end{equation}
% \begin{equation}
%     \defmapcomma{
%         \mtimescatmor
%     }{
%         \Mor_\LTI \cartprod \Mor_\LTI
%     }{
%         \to
%     }{
%         \Mor_\LTI
%     }{
%         \tup{\genericlti{\mora},\genericlti{\morb}}
%     }{
%         \genericlti{}
%     }
% \end{equation}
with
\begin{equation}
    \prstart=\begin{bmatrix}
        \prstart_\mora \\
        \prstart_\morb
    \end{bmatrix},\
    \mat{A}=\begin{bmatrix}
        \mat{A}_\mora & \mat{0}       \\
        \mat{0}       & \mat{A}_\morb
    \end{bmatrix},\
    \mat{B}=\begin{bmatrix}
        \mat{B}_\mora & \mat{0}       \\
        \mat{0}       & \mat{B}_\morb
    \end{bmatrix},
    %  \
    % \mat{B}=\begin{bmatrix}
    %     \mat{B}_\mora & \mat{0}       \\
    %     \mat{0}       & \mat{B}_\morb
    % \end{bmatrix},\
    % \mat{C}=\begin{bmatrix}
    %     \mat{C}_\mora & \mat{0}       \\
    %     \mat{0}       & \mat{C}_\morb
    % \end{bmatrix},\
    % \mat{D}=\begin{bmatrix}
    %     \mat{D}_\mora & \mat{0}       \\
    %     \mat{0}       & \mat{D}_\morb
    % \end{bmatrix}
\end{equation}
\begin{equation}
    % \prstart=\begin{bmatrix}
    %     \prstart_\mora \\
    %     \prstart_\morb
    % \end{bmatrix},\
    % \mat{A}=\begin{bmatrix}
    %     \mat{A}_\mora & \mat{0}       \\
    %     \mat{0}       & \mat{A}_\morb
    % \end{bmatrix}, \
    % \mat{B}=\begin{bmatrix}
    %     \mat{B}_\mora & \mat{0}       \\
    %     \mat{0}       & \mat{B}_\morb
    % \end{bmatrix},\
    \mat{C}=\begin{bmatrix}
        \mat{C}_\mora & \mat{0}       \\
        \mat{0}       & \mat{C}_\morb
    \end{bmatrix},\
    \mat{D}=\begin{bmatrix}
        \mat{D}_\mora & \mat{0}       \\
        \mat{0}       & \mat{D}_\morb
    \end{bmatrix}
\end{equation}

% Clearly, the morphism given by~$\genericlti{}$ satisfies the compatibility condition for stacking semicategories:
% if~$\genericlti{\mora}$ is~$\styleobj{l}\mto \styleobj{m}$ and~$\genericlti{\morb}$ is~$\styleobj{n}\mto \styleobj{o}$,~$\genericlti{}$ is~$\styleobj{l}+\styleobj{n}\mto \styleobj{m}+\styleobj{o}$.
Given that the resulting LTI system is described by diagonal block matrices, it is evident that the defined operations are \SY{associative}, and therefore \LTI is an \SY{associative stacking} \SY{semicategory}.

\subsection{Monoidal stacking}

\begin{ctdefinition}[Strict monoidal stacking semicategory]
    \label{def:strict-monoidal-stacking-semicat}
    A \maindef{strict monoidal stacking semicategory} is a \SY{stacking semicategory} $\tup{\CatC, \mtimescatob, \mtimescatmor}$ with

    \constit

    \begin{enumerate}
        \item an object $\idmoncat \setin \Obof{\CatC}$, called the \emph{monoidal unit}
    \end{enumerate}

    \condit

    \begin{enumerate}
        \item For any object $\Obja$ of \CatC,
              \begin{equation}
                  \Obja \mtimescatob \idmoncat = \Obja \qquad \text{and} \qquad \idmoncat \mtimescatob \Obja = \Obja.
              \end{equation}
        \item The monoidal unit $\idmoncat$ has an \SY{identity morphism} $\catid_\idmoncat$, and for any morphism $\mora \colon \Obja \mto \Objb$,
              \begin{equation}
                  \mora \mtimescatmor \catid_\idmoncat = \mora \qquad \text{and} \qquad \catid_\idmoncat \mtimescatmor  \mora = \mora.
              \end{equation}
    \end{enumerate}
\end{ctdefinition}

\todotext{make a remark about why we use the word ``strict'' here}

\begin{example}
    We can look at \Moore and ask whether it is a strict monoidal semicategory.
    The monoidal unit is given by $\cObj{}$.
    Its identity morphism is the Moore machine
    \begin{equation*}
        \catid_\idmoncat=\tup{\cObj{},\cObj{},\cObj{},\prdyn_\idmoncat, \prreadout_\idmoncat, \tup{}},
    \end{equation*}
    where
    \begin{equation*}
        \defmapcomma{\prdyn_{\idmoncat}}
        {\cObj{} \cprod \cObj{}}
        {\sto}
        {\cObj{}}
        {\tup{}\tupconcat \tup{}}
        {\tup{}}
    \end{equation*}
    and
    \begin{equation*}
        \defmapperiod{\prreadout_{\idmoncat}}
        {\cObj{}}
        {\sto}
        {\cObj{}}
        {\tup{}}
        {\tup{}}
    \end{equation*}
    Clearly, $\prObja \cprod \cObj{}=\cObj{}\cprod \prObja=\prObja$ for every $\prObja\setin \Ob_\Moore$.
    Furthermore, consider a Moore machine $\mora\colon \prin \mto \prout$ with
    \begin{equation*}
        \mora=\tup{\prin,\prst, \prout, \prdyn,\prreadout,\prstart}.
    \end{equation*}
    One has:
    \begin{equation*}
        \begin{aligned}
            \mora \mtimescatmor \catid_\idmoncat & =\tup{\prin \cprod \cObj{},\prst \cprod \cObj{},\prout \cprod \cObj{},\prdyn_{\mora \mtimescatmor\catid_\idmoncat}, \prreadout_{\mora \mtimescatmor\catid_\idmoncat}, \prstart\tupconcat \tup{}} \\
                                                 & =\tup{\prin,\prst ,\prout,\prdyn, \prreadout, \prstart}=\mora,
        \end{aligned}
    \end{equation*}
    where we used
    \begin{equation*}
        \begin{aligned}
            \prdyn_{\mora \mtimescatmor\catid_\idmoncat}\colon \prin \cprod \cObj{}\cprod \prst \cprod \cObj{} & \sto \prst \cprod \cObj{} \\
            \prinel \tupconcat \tup{}\tupconcat \prstel \tupconcat \tup{}                                      & \mapsto \prdyn(\prinel,\prstel)\tupconcat \prdyn_\idmoncat(\tup{},\tup{})=\prdyn(\prinel,\prstel)
        \end{aligned}
    \end{equation*}
    and
    \begin{equation*}
        \begin{aligned}
            \prreadout_{\mora \mtimescatmor\catid_\idmoncat}\colon \prst \cprod \cObj{} & \sto \prout \cprod \cObj{} \\
            \prstel \tupconcat \tup{}                                                   & \mapsto \prreadout(\prstel)\tupconcat \prreadout_\idmoncat(\tup{})=\prreadout(\prstel)
        \end{aligned}
    \end{equation*}
    to show the equivalences $\prdyn=\prdyn_{\mora \mtimescatmor \catid_\idmoncat}$ and $\prreadout=\prreadout_{\mora \mtimescatmor \catid_\idmoncat}$.
    The argument for $\catid_\idmoncat \mtimescatmor \mora$ follows analogously.
\end{example}

\begin{ctdefinition}[Strict monoidal stacking category]
    \label{def:strict-monoidal-stacking-cat}
    A \maindef{strict monoidal stacking category} is a \SY{strict monoidal stacking semicategory} for which all identity morphisms exist.
\end{ctdefinition}

\begin{example}
    \LTI, equipped with previously described stacking operations and an appropriate unit, is a strict monoidal stacking category.
    The unit is given by the object 0, and its identity morphism is given by the LTI system
    \begin{equation*}
        \catid_\idmoncat=\tup{\mat{0}^{0\times 1}, \mat{0}^{0\times 0}, \mat{0}^{0\times 0}, \mat{0}^{0\times 0},\mat{0}^{0\times 0}}.
    \end{equation*}
    On the side of objects, clearly $l+0=0+l=l$ for any object $l\setin \Ob_\LTI$.
    Consider $\mora\colon l\mto m$.
    On the side of morphisms we have:
    \begin{equation*}
        \begin{aligned}
            \mora \mtimescatmor \catid_\idmoncat & =
            \langle\begin{bmatrix}\prstart \\ \mat{0}^{0\times 1}\end{bmatrix},
            \begin{bmatrix}\mat{A}&\mat{0}\\ \mat{0}&\mat{0}^{0\times 0}\end{bmatrix},
            \begin{bmatrix}\mat{B}&\mat{0}\\ \mat{0}&\mat{0}^{0\times 0}\end{bmatrix},
            \begin{bmatrix}\mat{C}&\mat{0}\\ \mat{0}&\mat{0}^{0\times 0}\end{bmatrix},
            \begin{bmatrix}\mat{D}&\mat{0}\\ \mat{0}&\mat{0}^{0\times 0}\end{bmatrix}\rangle \\
                                                 & =\genericlti{}
        \end{aligned}
    \end{equation*}
    Similarly:
    \begin{equation*}
        \begin{aligned}
            \catid_\idmoncat \mtimescatmor \mora & =
            \langle\begin{bmatrix}\mat{0}^{0\times 1}\\ \prstart\end{bmatrix},
            \begin{bmatrix}\mat{0}^{0\times 0}&\mat{0}\\\mat{0}&\mat{A}\end{bmatrix},
            \begin{bmatrix}\mat{0}^{0\times 0}&\mat{0}\\\mat{0}&\mat{B}\end{bmatrix},
            \begin{bmatrix}\mat{0}^{0\times 0}&\mat{0}\\\mat{0}&\mat{C}\end{bmatrix},
            \begin{bmatrix}\mat{0}^{0\times 0}&\mat{0}\\\mat{0}&\mat{D}\end{bmatrix}\rangle \\
                                                 & =\genericlti{}
        \end{aligned}
    \end{equation*}
\end{example}

\todo{solve $\tup{}$ over multiple lines.
    .}

\section{Functorial stacking semicategories}

\begin{marginfigure}
    \centering
    $(\mora \mtimescatmor \morb )
        \mthen (\morc \mtimescatmor \mord )$

    \vspace{3mm}
    \includesag{commuting_stacking_eff}

    $=$

    \vspace{3mm}
    \includesag{commuting_stacking_eff_bis}
    %\includegraphics[width=6.5cm]{effects8}
    \vspace{3mm}
    $(\mora \mthen \morc ) \mtimescatmor (\morb \mthen \mord )$

    \caption{Commutation of stacking and composition in a functorial stacking \SY{semicategory}. }
    \label{fig:stacking-functorial}
\end{marginfigure}

\begin{ctdefinition}[Functorial stacking semicategory]
    \label{def:functorial-stacking-semi-cat}
    A \maindef{functorial stacking semicategory} is a stacking \SY{semicategory} where the two stacking operations~$\mtimescatob$ and~$\mtimescatmor$ are the two components of a \SY{semifunctor} \begin{equation}
        \mtimescat\colon \CatC \Ctimes \CatC \to \CatC.
    \end{equation}
    Concretely, and in infix notation, this means that
    \begin{equation}
        (\mora \mthen \morc )
        \mtimescatmor (\morb \mthen \mord )
        =
        (\mora \mtimescatmor \morb )
        \mthen (\morc \mtimescatmor \mord )
    \end{equation}
    for all morphisms~$\mora, \morb, \morc$, and $\mord$ where respectively $\mora$ and $\morc$, and $\morb$ and $\mord$ are composable.
\end{ctdefinition}

%More in detail, we have that for any~$n \geq 2$, there is a semifunctor
%%
%\begin{equation}
%    \mtimescat^{(n)}\colon \underbrace {\CatC \times \CatC \times \cdots \times \CatC}_{\text{$n$ times}} \to \CatC.
%\end{equation}
%
This describes a sort of commutativity property: we can either first compose horizontally and then vertically, or vice versa, and we obtain the same morphism~(\cref{fig:stacking-functorial}).

This property is somewhat strong.
\Effects is an example of a stacking category that is not functorial.

\begin{lemma}
    \label{lem:effects-not-functorial}
    \Effects is \emph{not} a \SY{functorial stacking semicategory}.
\end{lemma}

\begin{proof}
    In general, we have
    \begin{equation}
        (\mora \mtimescatmor \morb )
        \mthen (\morc \mtimescatmor \mord )
        \neq
        (\mora \mthen \morc ) \mtimescatmor (\morb \mthen \mord ).
    \end{equation}
    This is shown graphically in \cref{fig:effects-non-functorial}.
\end{proof}

\begin{figure*}[h]
    \centering
    \hfill
    \subfloat[\label{fig:effects7}$(\mora \mtimescatmor \morb )
            \mthen (\morc \mtimescatmor \mord )$]{
        %\includegraphics[width=6.5cm]{effects7}
        \includesag{stacking_tup_counterproof}
    }
    \hfill
    \subfloat[\label{fig:effects9} $(\mora \mthen \morc ) \mtimescatmor (\morb \mthen \mord )$]{
        %\includegraphics[width=6.5cm]{effects9}
        \includesag{stacking_tup_counterproof_bis}
    }
    \hfill
    \caption{Proof that \Effects is not a \SY{functorial stacking} category by showing that
        the two morphisms above have different representations in~\SetL.}
    \label{fig:effects-non-functorial}
\end{figure*}

\todotextjira{751}{\alphubel  @GZ: There is a typo in the above diagrams -- U and Z are switched from where they should be placed.
    Also, the right hand diagram should have *two* boxes with dotted lines, not just one.
}

\begin{example}[\SetL is functorial stacking]
    \label{ex:setfunstack}
    We want to show that~\SetL is a \SY{functorial stacking semicategory}.

    Consider four morphisms
    \begin{equation}
        \begin{aligned}
            \mora\colon \setA \mto \setB, & \quad \morc\colon \setB \mto \setC, \\
            \morb\colon \setD \mto \setE, & \quad \mord\colon \setE \mto \setF.
            \\
        \end{aligned}
    \end{equation}
    We want to show that
    \begin{equation}
        (\mora \mtimescatmor \morb )
        \mthen (\morc \mtimescatmor \mord )
        =
        (\mora \mthen \morc ) \mtimescatmor (\morb \mthen \mord ),
    \end{equation}
    We show this by showing that, for any $\setAel\tupconcat \setBel\setin \setA\cprod\setB$:
    \begin{equation}
        \begin{aligned}
            ((\mora \mtimescatmor \morb )\mthen (\morc \mtimescatmor \mord ))(\setAeln{}\tupconcat \setDeln{})
             & = (\morc \mtimescatmor \mord)(\mora(\setAeln{})\tupconcat \morb(\setDeln{})) \\
             & =\morc(\mora(\setAeln{}))\tupconcat \mord(\morb(\setDeln{})) \\
             & =(\mora \mthen \morc)(\setAeln{})\tupconcat (\morb\mthen \mord)(\setDeln{}) \\
             & =((\mora \mthen \morc ) \mtimescatmor (\morb \mthen \mord ))(\setAeln{}\tupconcat  \setDeln{}).
        \end{aligned}
    \end{equation}
\end{example}
% \begin{comment}
% \devel{
%
%     \begin{equation}
%         \begin{aligned}
%             \mora\colon \cObj{\setAn{1}, \ldots,\setAn{m}} & \mto \cObj{\setBn{1}, \ldots, \setBn{n}}, \\
%             \morb\colon \cObj{\setDn{1}, \ldots,\setDn{o}} & \mto \cObj{\setEn{1}, \ldots, \setEn{p}}, \\
%             \morc\colon \cObj{\setBn{1}, \ldots,\setBn{n}} & \mto \cObj{\setCn{1}, \ldots, \setCn{q}}, \\
%             \mord\colon \cObj{\setEn{1}, \ldots,\setEn{p}} & \mto \cObj{\setFn{1}, \ldots, \\setFn{r}},
%         \end{aligned}
%     \end{equation}
%     to which maps~$\mape,\mapf,\mapg,\maph$ are associated.
%
%     We want to show that
%     \begin{equation}
%         (\mora \mtimescat \morb )
%         \mthen (\morc \mtimescat \mord )
%         =
%         (\mora \mthen \morc ) \mtimescat (\morb \mthen \mord ),
%     \end{equation}
%     and we do it by showing that the map associated with the left-hand side of the equation corresponds to the one on the right-hand side.
%     We know the maps associated to~$(\mora \mtimescat \morb )$ and~$(\morc \mtimescat \mord )$, which are
%     \begin{equation}
%         \cohm_{\setA,\setD}\then (\mape \funcprod \mapg)\then \cohm_{\setB,\setE},
%     \end{equation}
%     and
%     \begin{equation}
%         \cohm_{\setB,\setE}\then (\mapf \funcprod \maph)\then \cohm_{\setC,\setF},
%     \end{equation}
%     respectively.
%     The map associated to~$(\mora \mtimescat \morb )
%         \mthen (\morc \mtimescat \mord )$ is therefore
%     \begin{equation}
%         \label{eq:setL_functorial_a}
%         \cohm_{\setA,\setD}\then (\mape \funcprod \mapg)\then \cohm_{\setB,\setE}\then \cohm_{\setB,\setE}\then (\mapf \funcprod \maph)\then \cohm_{\setC,\setF}.
%     \end{equation}
%     On the other hand, the map associated to~$(\mora \mthen \morc )$ is~$\mape\then \mapf$, and the map associated to~$(\morb \mthen \mord)$ is~$\mapg\then \maph$.
%     Therefore, the map associated to~$(\mora \mthen \morc ) \mtimescat (\morb \mthen \mord )$ is
%     \begin{equation}
%         \cohm_{\setA,\setD}\then ((\mape\then \mapf)\funcprod (\mapg\then \maph))\then \cohm_{\setC,\setD}
%     \end{equation}
%
%     \todotext{Now need to finish by showing equivalence of maps}
% }
% \end{comment}

\begin{example}
    We want to show that \Moore, equipped with the defined stacking operations, is almost a \SY{functorial stacking semicategory},
    but not quite.
    Consider four Moore machines:
    \begin{equation*}
        \mora\colon \prin_\mora \mto \prout_\mora,\quad \morb\colon \prin_\morb \mto \prout_\morb, \quad \morc\colon \prout_\mora \mto \prout_\morc,\quad \mord\colon \prout_\morb \mto \prout_\mord.
    \end{equation*}
    We need to show:
    \begin{equation*}
        (\mora \mthen \morc)
        \mtimescatmor (\morb\mthen \mord)=(\mora\mtimescatmor \morb)\mthen (\morc\mtimescatmor \mord).
    \end{equation*}
    Let's start from the left-hand side.
    First, we have:
    \begin{equation*}
        \begin{aligned}
            \mora \mthen \morc & =\tup{\prin_\mora, \prst_\mora \cprod \prst_\morc, \prout_\morc, \prdyn_{\mora\mthen \morc},\prreadout_{\mora\mthen \morc}, \prstart_\mora\tupconcat \prstart_\morc}, \\
            \morb \mthen \mord & =\tup{\prin_\morb, \prst_\morb \cprod \prst_\mord, \prout_\mord, \prdyn_{\morb\mthen \mord},\prreadout_{\morb\mthen \mord}, \prstart_\morb\tupconcat \prstart_\mord},
        \end{aligned}
    \end{equation*}
    with
    \begin{equation*}
        \defmapcomma{\prdyn_{\mora\mthen \morc}}
        {\prin_\mora\cprod \prst_\mora \cprod \prst_\morc}
        {\sto}
        {\prst_\mora \cprod \prst_\morc}
        {\prinel_\mora\tupconcat \prstel_\mora \tupconcat \prstel_\morc}
        {\prdyn_\mora(\prinel_\mora \tupconcat \prstel_\mora)\tupconcat \prdyn_\morc(\prreadout_\mora(\prstel_\mora)\tupconcat \prstel_\morc)}
    \end{equation*}
    %
    \begin{equation*}
        \defmapcomma{\prdyn_{\morb\mthen \mord}}
        {\prin_\morb\cprod \prst_\morb \cprod \prst_\mord}
        {\sto}
        {\prst_\morb \cprod \prst_\mord}
        {\prinel_\morb\tupconcat \prstel_\morb \tupconcat \prstel_\mord}
        {\prdyn_\morb(\prinel_\morb \tupconcat \prstel_\morb)\tupconcat \prdyn_\mord(\prreadout_\morb(\prstel_\morb)\tupconcat \prstel_\mord)}
    \end{equation*}
    %
    \begin{equation*}
        \defmapcomma{\prreadout_{\mora\mthen \morc}}
        {\prst_\mora \cprod \prst_\morc}
        {\sto}
        {\prout_\morc}
        {\prstel_\mora \tupconcat \prstel_\morc}
        {\prreadout_\morc(\prstel_\morc)}
    \end{equation*}
    and
    \begin{equation*}
        \defmapperiod{\prreadout_{\morb\mthen \mord}}
        {\prst_\morb \cprod \prst_\mord}
        {\sto}
        {\prout_\mord}
        {\prstel_\morb \tupconcat \prstel_\mord}
        {\prreadout_\mord(\prstel_\mord)}
    \end{equation*}

    Furthermore:
    \begin{widepar}
        \begin{equation*}
            (\mora \mthen \morc)\mtimescatmor (\morb \mthen \mord)=\tup{\prin_\mora\cprod \prin_\morb, \prst_\mora \cprod \prst_\morc\cprod \prst_\morb \cprod \prst_\mord, \prout_\morc\cprod \prout_\mord,
                \prdyn_{(\mora\mthen \morc)\mtimescatmor(\morb\mthen \mord)}, \prreadout_{(\mora\mthen \morc)\mtimescatmor(\morb\mthen \mord)}, \prstart_\mora\tupconcat \prstart_\morc\tupconcat \prstart_\morb\tupconcat \prstart_\mord},
        \end{equation*}
    \end{widepar}
    with
    \begin{widepar}
        \begin{equation*}
            \defmapcomma{\prdyn_{(\mora\mthen \morc)\mtimescatmor(\morb\mthen \mord)}}
            {\prin_\mora\cprod \prin_\morb\cprod \prst_\mora \cprod \prst_\morc\cprod \prst_\morb \cprod \prst_\mord}
            {\sto}
            {\prst_\morc\cprod \prst_\morb \cprod \prst_\mord}
            {\prinel_\mora\tupconcat \prinel_\morb \tupconcat \prstel_\mora \tupconcat \prstel_\morc \tupconcat \prstel_\morb \tupconcat \prstel_\mord}
            {\underbrace{\prdyn_{\mora\mthen \morc}(\prinel_\mora\tupconcat \prstel_\mora \tupconcat \prstel_\morc)\tupconcat \prdyn_{\morb\mthen \mord}(\prinel_\morb\tupconcat \prstel_\morb \tupconcat \prstel_\mord)}_{(1)}}
        \end{equation*}
    \end{widepar}
    where
    \begin{equation*}
        (1)=\prdyn_\mora(\prinel_\mora \tupconcat \prstel_\mora)\tupconcat \prdyn_\morc(\prreadout_\mora(\prstel_\mora)\tupconcat \prstel_\morc) \tupconcat
        \prdyn_\morb(\prinel_\morb \tupconcat \prstel_\morb)\tupconcat \prdyn_\mord(\prreadout_\morb(\prstel_\morb)\tupconcat \prstel_\mord),
    \end{equation*}
    and
    \begin{equation*}
        \defmapcomma{\prreadout_{(\mora\mthen \morc)\mtimescatmor(\morb\mthen \mord)}}
        {\prst_\mora \cprod \prst_\morc\cprod \prst_\morb \cprod \prst_\mord}
        {\sto}
        {\prout_\morc\cprod \prout_\mord}
        {\prstel_\mora \tupconcat \prstel_\morc \tupconcat \prstel_\morb \tupconcat \prstel_\mord}
        {\underbrace{\prreadout_{\mora\mthen \morc}(\prstel_\mora \tupconcat \prstel_\morc)\tupconcat \prreadout_{\morb\mthen \mord}(\prstel_\morb \tupconcat \prstel_\mord)}_{(2)}}
    \end{equation*}
    where
    \begin{equation*}
        (2)=\prreadout_\morc(\prstel_\morc)\tupconcat \prreadout_\mord(\prstel_\mord).
    \end{equation*}
    On the other hand, we have:
    \begin{equation*}
        \begin{aligned}
            \mora \mtimescatmor \morb & =\tup{\prin_\mora \cprod \prin_\morb, \prst_\mora \cprod \prst_\morb, \prout_\mora \cprod \prout_\morb, \prdyn_{\mora\mtimescatmor \morb},\prreadout_{\mora\mtimescatmor \morb}, \prstart_\mora\tupconcat \prstart_\morb}, \\
            \morc \mtimescatmor \mord & =\tup{\prin_\morc \cprod \prin_\mord, \prst_\morc \cprod \prst_\mord, \prout_\morc \cprod \prout_\mord, \prdyn_{\morc\mtimescatmor \mord},\prreadout_{\morc\mtimescatmor \mord}, \prstart_\morc\tupconcat \prstart_\mord},
        \end{aligned}
    \end{equation*}
    with
    \begin{equation*}
        \defmapcomma{\prdyn_{\mora \mtimescatmor \morb}}{\prin_\mora \cprod \prin_\morb \cprod \prst_\mora \cprod \prst_\morb}
        {\sto}{\prst_\mora \cprod \prst_\morb}
        {\prinel_\mora \tupconcat \prinel_\morb \tupconcat \prstel_\mora \tupconcat \prstel_\morb}
        {\prdyn_\mora(\prinel_\mora \tupconcat \prstel_\mora)\tupconcat \prdyn_\morb(\prinel_\morb \tupconcat \prstel_\morb)}
    \end{equation*}
    %
    \begin{equation*}
        \defmapcomma{\prdyn_{\morc \mtimescatmor \mord}}{\prin_\morc \cprod \prin_\mord \cprod \prst_\morc \cprod \prst_\mord}
        {\sto}{\prst_\morc \cprod \prst_\mord}
        {\prinel_\morc \tupconcat \prinel_\mord \tupconcat \prstel_\morc \tupconcat \prstel_\mord}
        {\prdyn_\morc(\prinel_\morc \tupconcat \prstel_\morc)\tupconcat \prdyn_\mord(\prinel_\mord \tupconcat \prstel_\mord)}
    \end{equation*}
    %
    \begin{equation*}
        \defmapcomma{\prreadout_{\mora \mtimescatmor \morb}}
        {\prst_\mora \cprod \prst_\morb}{\sto}{\prout_\mora \cprod \prout_\morb}
        {\prstel_\mora \tupconcat \prstel_\morb}{\prreadout_\mora(\prstel_\mora)\tupconcat \prreadout_\morb(\prstel_\morb)}
    \end{equation*}
    and
    \begin{equation*}
        \defmapperiod{\prreadout_{\morc \mtimescatmor \mord}}
        {\prst_\morc \cprod \prst_\mord}{\sto}{\prout_\morc \cprod \prout_\mord}
        {\prstel_\morc \tupconcat \prstel_\mord}{\prreadout_\morc(\prstel_\morc)\tupconcat \prreadout_\mord(\prstel_\mord)}
    \end{equation*}

    Furthermore:
    \begin{widepar}
        \begin{equation*}
            (\mora \mtimescatmor \morb)\mthen (\morc \mtimescatmor \mord)=\tup{\prin_\mora\cprod \prin_\morb, \prst_\mora \cprod \prst_\morb\cprod \prst_\morc \cprod \prst_\mord, \prout_\morc\cprod \prout_\mord,
                \prdyn_{(\mora\mtimescatmor \morb)\mtimescatmor(\morc\mtimescatmor \mord)}, \prreadout_{(\mora\mtimescatmor \morb)\mthen(\morc\mtimescatmor \mord)}, \prstart_\mora\tupconcat \prstart_\morb\tupconcat \prstart_\morc\tupconcat \prstart_\mord},
        \end{equation*}
    \end{widepar}
    with
    \begin{widepar}
        \begin{equation*}
            \defmapcomma{\prdyn_{(\mora\mtimescatmor \morb)\mthen(\morc\mtimescatmor \mord)}}
            {\prin_\mora\cprod \prin_\morb\cprod \prst_\mora \cprod \prst_\morb\cprod \prst_\morc \cprod \prst_\mord}
            {\sto}
            {\prst_\mora \cprod \prst_\morb\cprod \prst_\morc \cprod \prst_\mord}
            {\prinel_\mora \tupconcat \prinel_\morb\tupconcat \prstel_\mora \tupconcat \prstel_\morb \tupconcat \prstel_\morc \tupconcat \prstel_\mord}
            {\underbrace{\prdyn_{\mora \mtimescatmor \morb}(\prinel_\mora \tupconcat \prinel_\morb \tupconcat \prstel_\mora \tupconcat \prstel_\morb)
                    \tupconcat \prdyn_{\morc\mtimescatmor \mord}(\prreadout_{\mora \mtimescatmor\morb}(\prstel_\mora \tupconcat \prstel_\morb)\tupconcat \prstel_\morc \tupconcat \prstel_\mord)}_{(3)}}
        \end{equation*}
    \end{widepar}
    with
    \begin{widepar}
        \begin{equation*}
            \begin{aligned}
                (3) & =\prdyn_\mora(\prinel_\mora \tupconcat \prstel_\mora)\tupconcat \prdyn_\morb(\prinel_\morb \tupconcat \prstel_\morb)
                \tupconcat \prdyn_{\morc\mtimescatmor \mord}(\prreadout_\mora(\prstel_\mora)\tupconcat \prreadout_\morb(\prstel_\morb)\tupconcat \prstel_\morc \tupconcat \prstel_\mord) \\
                    & =\prdyn_\mora(\prinel_\mora \tupconcat \prstel_\mora)\tupconcat \underbrace{\prdyn_\morb(\prinel_\morb \tupconcat \prstel_\morb)}_{(*)}
                \tupconcat \underbrace{\prdyn_{\morc}(\prreadout_\mora(\prstel_\mora)\tupconcat \prstel_\morc)}_{(**)}\tupconcat \prdyn_\mord(\prreadout_\morb(\prstel_\morb)\tupconcat \prstel_\mord)
            \end{aligned}
        \end{equation*}
    \end{widepar}
    and
    \begin{equation*}
        \defmapcomma{\prreadout_{(\mora\mtimescatmor \morb)\mthen(\morc\mtimescatmor \mord)}}
        {\prst_\mora \cprod \prst_\morb\cprod \prst_\morc \cprod \prst_\mord}
        {\sto}
        {\prout_\morc\cprod \prout_\mord}
        {\prstel_\mora \tupconcat \prstel_\morb \tupconcat \prstel_\morc \tupconcat \prstel_\mord}
        {\prreadout_{\morc\mtimescatmor \mord}(\prstel_\morc \tupconcat \prstel_\mord)=\prreadout_\morc(\prstel_\morc)\tupconcat \prreadout_\mord(\prstel_\mord)}
    \end{equation*}
    As one can see from the expression for (3), the two terms ($*$) and ($**$) are switched compared to (1).
    Apart from this switch (and the corresponding switch in the signatures of the dynamics maps), we can see that there is a moral correspondence between the Moore machines in the functorial stacking axiom.

\end{example}

\begin{example}
    We want to show that \LTI, equipped with the defined stacking operations, is almost a \SY{functorial stacking semicategory}, but not quite.
    Given morphisms~$\mora\colon \styleobj{l}\mto \styleobj{m}$,~$\morc\colon \styleobj{m}\mto \styleobj{n}$,~$\morb\colon \styleobj{o}\mto \styleobj{p}$,~$\mord\colon \styleobj{p}\mto \styleobj{q}$, we would need to have
    \begin{equation*}
        (\mora \mthen \morc)
        \mtimescatmor (\morb\mthen \mord)=(\mora\mtimescatmor \morb)\mthen (\morc\mtimescatmor \mord).
    \end{equation*}
    This, however, is not true.
    Let's see this by looking at the first matrix component of the LTI system.
    On one hand we have:
    \begin{equation}
        \mat{A}_{(\mora \mthen \morc)\mtimescatmor (\morb\mthen \mord)}=
        \begin{bmatrix}
            \mat{A}_\mora              & \mat{0}       & \mat{0}                    & \mat{0}       \\
            \mat{B}_\morc\mat{C}_\mora & \mat{A}_\morc & \mat{0}                    & \mat{0}       \\
            \mat{0}                    & \mat{0}       & \mat{A}_\morb              & \mat{0}       \\
            \mat{0}                    & \mat{0}       & \mat{B}_\mord\mat{C}_\morb & \mat{A}_\mord
        \end{bmatrix}.
    \end{equation}
    On the other hand we have:
    \begin{equation}
        \mat{A}_{(\mora\mtimescatmor \morb)\mthen (\morc\mtimescatmor \mord)}=
        \begin{bmatrix}
            \mat{A}_\mora               & \mat{0}                     & \mat{0}       & \mat{0}       \\
            \mat{0}                     & \mat{A}_\morb               & \mat{0}       & \mat{0}       \\
            \mat{B}_\morc \mat{C}_\mora & \mat{0}                     & \mat{A}_\morc & \mat{0}       \\
            \mat{0}                     & \mat{B}_\mord \mat{C}_\morb & \mat{0}       & \mat{A}_\mord
        \end{bmatrix}.
    \end{equation}
    These two are different, and will therefore describe different systems.
    However, the two matrices just differ by two permutations, which can be expressed via an invertible linear transformation~$\mat{T}$ as follows:
    \begin{equation}
        \mat{A}_{(\mora\mtimescatmor \morb)\mthen (\morc\mtimescatmor \mord)}=
        \underbrace{\begin{bmatrix}
                1 & 0 & 0 & 0 \\
                0 & 0 & 1 & 0 \\
                0 & 1 & 0 & 0 \\
                0 & 0 & 0 & 1
            \end{bmatrix}}_{\mat{T}}\cdot
        \mat{A}_{(\mora \mthen \morc)\mtimescatmor (\morb\mthen \mord)}
        \cdot
        \begin{bmatrix}
            1 & 0 & 0 & 0 \\
            0 & 0 & 1 & 0 \\
            0 & 1 & 0 & 0 \\
            0 & 0 & 0 & 1
        \end{bmatrix}.
    \end{equation}
    It turns out that $(\mora \mthen \morc)\mtimescatmor (\morb\mthen \mord)$ and~$(\mora\mtimescatmor \morb)\mthen (\morc\mtimescatmor \mord)$ are equivalent systems (\cref{def:equivalence_lti}), even though they are not equal.
    In particular, although \LTI is not a \SY{functorial stacking semicategory}, by \cref{lem:equivsystequivact}~$(\mora \mthen \morc)\mtimescatmor (\morb\mthen \mord)$ and~$(\mora\mtimescatmor \morb)\mthen (\morc\mtimescatmor \mord)$ have the same action, and hence \LTI is, in one sense, ``morally'' functorial.
\end{example}

\subsection{Functorial stacking categories}

\begin{ctdefinition}[Functorial stacking category]
    \label{def:functorial-stacking-cat}
    A \maindef{functorial stacking category} is a stacking \SY{category} where the two stacking operations~$\mtimescatob$ and~$\mtimescatmor$ are the two components of a \SY{functor} \begin{equation}
        \mtimescat\colon \CatC \Ctimes \CatC \to \CatC.
    \end{equation}
    In infix notation, this means that, in addition to the equation
    \begin{equation}
        (\mora \mthen \morc )
        \mtimescatmor (\morb \mthen \mord )
        =
        (\mora \mtimescatmor \morb )
        \mthen (\morc \mtimescatmor \mord )
    \end{equation}
    it is now also the case that $\mtimescat$ is compatible with identity morphisms:
    \begin{equation}
        \catidat{\Obja} \mtimescatmor \catidat{\Objb} = \catidat{\Obja \mtimescatob \Objb}
    \end{equation}
    for all objects $\Obja$, $\Objb$ of $\CatC$.
\end{ctdefinition}

\begin{remark}
    Note that a functorial stacking category is \emph{not} the same thing as a functorial stacking semicategory where the semicategory in question happens to be a category.
\end{remark}
