% !TEX root = chapter-standalone.tex

\section{Introduction to systems}
    \todojira{624}{fill the whole part}

    \todotext{Maybe include several examples throughout this intro to liven up the text and make it more concrete and engineering flavored}

    The term ``system'' is not a precise mathematical term for us, but rather an intuitive concept that relates directly to modeling in engineering. We will think of a system as having input and output ports with which it can interact with other systems (or its broader environment), and that a system in some way establishes a relationship between input and output signals. This relationship might be a deterministic, causal relationship -- inputs determining outputs -- or it might be another form of lawfulness.

A typical way to depict a system diagrammatically is to draw it as a box, with externally extended wires indicating the input and output ports. We will usually orient such diagrams horizontally, and assume that the left-hand wires indicate input ports, and right-hand wires indicate output ports.

\todotext{insert diagam of a single system here}


 \subsection{Composing systems}
 
Our concept of system is compositional: systems can be connected together to build larger, composite systems. In the next chapter we will discuss how to compose systems not only in series but also in parallel, and later we will also describe how to model feedback. 


An illustrative example of systems are Moore machines, which we discussed in some length in \cref{chap:processes}. Given a Moore machine
 \begin{equation}
                  \tup{\prinL,\prstL,\proutL,\prdyn,\prreadout,\prstart}
\end{equation}
 it has an input set $\prinL$ and an output $\proutL$. When the output set of one machine matches the input set of another, we have already seen how to compose Moore machines in series to build composite systems which are again Moore machines. We will soon also formalize parallel composition and feedback for Moore machines.  

\todotext{insert illustrative figure of composing/composed Moore machines here}

 \subsection{System specification vs. system behavior}

 \todotext{The material below has been copied/moved to the section introducing Moore machines, so needs to be edited so as not to be redundant}

    Consider a Moore machine $\tup{\prin, \prout, \prst, \prdyn, \prreadout}$.
    In \cref{sec:action-of-a-category} we saw how, given an initial state $x_0 \setin \prst$, a Moore machine may act on sequences of inputs, mapping these to sequences of outputs.

    For example, given a sequence of inputs $u_0, u_1, u_2, .
        .. $, we may map this to a sequence of outputs $y_0, y_1, y_2, ... $ using the following recursion relations
    \begin{align}
        \label{eq:Moore-standard-recursion}
        x_{k+1} & = \prdyn(x_k, u_k) \\
        y_{k}   & = \prreadout(x_{k}),
    \end{align}
    with $k \setin \natnumbers$.

    In other words, given $x_0 \setin \prst$, we may map the Moore machine \label{eq:moore-again} to a function
    \begin{equation}
        \prin^\natnumbers \to \prout^\natnumbers,  \quad (u_k)_{k \setin \natnumbers} \mapsto (y_k)_{k \setin \natnumbers}.
    \end{equation}
    We will think of this function as an `external behavior' of the Moore machine, because it encodes what is externally observable to us in terms of how the Moore machine is used to relate inputs to outputs.

    Note that in concrete application we might not actually know a precise model of a Moore machine in the form {eq:moore-specification-again}.
    But we can still observe what it does when we feed it inputs.
    And in some cases this external behavior is in fact all we really care about.

    \subsection{Many behaviors from one machine}

    Other kinds of behavior may be generated with the same Moore machine $\tup{\prin, \prout, \prst, \prdyn, \prreadout}$ as above (and using the same initial state).
    For example, instead of \cref{eq:Moore-standard-recursion} we may use the set of equations
    \begin{align}
        \tilde x_{k} & = \prdyn(x_k, u_k) \\
        x_{k+1}      & = \prdyn(\tilde x_{k}, u_k) \\
        y_{k}        & = \prreadout(x_{k}),
    \end{align}
    where $\tilde x$ is a new `latent' variable that we've introduced.
    This illustrates that the recursion equations are part of what generates a behavior of the Moore machine; they are not part of the specification $\tup{\prin, \prout, \prst, \prdyn, \prreadout}$ of the Moore machine itself.

   
    \todotext{Talk here in the intro about the distinction between formal specifications or parametrizations of systems versus behaviors of systems; use Moore (and More) machines as an example}


