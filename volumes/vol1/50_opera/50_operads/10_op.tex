\section{Definition}
\label{sec:operads-definition}
\todostructurejira{301}{\bernina: @Gioele: Reorganize the videos in bigger chunks}

\linkvideo{spring2021-operads-a:intro-idea-operad} % The basic idea of operad
\linkvideo{spring2021-operads-a:terminology-operad} % Terminology
\linkvideo{spring2021-operads-a:composition-operad} % Composition
\linkvideo{spring2021-operads-a:notation-operad} % Notation
\linkvideo{spring2021-operads-a:operad-sets} % Operad of sets (via product)
\linkvideo{spring2021-operads-a:operad-disks} % Operad of little disks
\linkvideo{spring2021-operads-a:operad-def} % Definition of operad

\begin{ctdefinition}[Operad]
    \label{def:operad}
    An \maindef{operad} is defined by:

    
    \constit
    \begin{enumerate}
        \item \emph{Objects:} A collection~$\Obof\operada$;
        \item \emph{Morphisms:} Let~$n\setin \natnumbers$.
              For each finite string~$[\Obja_1,\ldots, \Obja_n]$ of objects and each object~$    \Objb$, one specifies a set~$\HomSet{\operada}{[\Obja_1,\ldots,\Obja_n]}{\Objb}$,
              elements of which are morphisms~$[\Obja_1,\ldots,\Obja_n]\mto \Objb$;
        \item \emph{Identity morphisms:} For each object~$\Obja$, a morphism
              \begin{equation}
                  \catidat\Obja \setin \HomSet{\operada}{[\Obja_1,\ldots,        \Obja_n]}{\Objb};
              \end{equation}
        \item \emph{Composition operations:}
              \begin{equation}
                  \begin{aligned}
                      \HomSet{\operada}{[\Obja_{1}^1, \ldots, \Obja_{n_1}^1]}{\Objb_1}\times \ldots \times  \HomSet{\operada}{[\Obja_{1}^m, \ldots, \Obja_{n_m}^m]}{\Objb_m}\times  \HomSet{\operada}{[\Objb_{1}, \ldots,\Objb_{m}]}{\Objc} &
                      \mto  \HomSet{\operada}{[\Obja_{1}^1, \ldots, \Obja_{n_m}^m]}{\Objc} \\
                      \tup{\mora_1,\ldots,\mora_m,\morb}                                                                                                                                                                                    & \mapsto [\mora_1,\ldots, \mora_m]\mthen \morb.
                  \end{aligned}
              \end{equation}
    \end{enumerate}
    \condit
    \begin{enumerate}
        \item \emph{Associativity:}
        \begin{equation}
              \begin{aligned}
                  &[[\mora_{1}^1,\ldots, \mora_{n_1}^1]\mthen \morb_1,[\mora_{1}^2,\ldots, \mora_{n_2}^2]\mthen \morb_2,\ldots, [\mora_{1}^m,\ldots, \mora_{n_m}^m]\mthen \morb_m ]\mthen \morc\\=&[\mora_{1}^1,\ldots, \mora_{n_m}^m]\mthen ([\morb_{1},\ldots, \morb_{m}]\mthen \morc).
              \end{aligned}
            \end{equation}
        \item \emph{Unitality}:
              \begin{equation}
                  [\catidat{\Obja_1},\ldots, \catidat{\Obja_n}]
                  \mthen \mora = \mora = \mora \mthen \catidat\Objb, \quad \forall \mora\colon [\Obja_1,\ldots,\Obja_n]\mto \Objb.
              \end{equation}
    \end{enumerate}
\end{ctdefinition}

\linkvideo{spring2021-operads-a:operad-multilin-maps} % Operad of multilinear maps
\devel{
    \begin{example}[Operead of multilinear maps]
        \todotextjira{302}{\bernina: Finish trascribing}
    \end{example}
}

\linkvideo{spring2021-operads-a:swiss-cheese-operad}
\devel{
    \begin{example}[Swiss cheese operad]
        \todotextjira{302}{\bernina: Finish trascribing}
    \end{example}
}

\linkvideo{spring2021-operads-b:network-operad} % Network operads
\devel{
    \begin{example}[Network operads]
        \todotextjira{302}{Finish trascribing}
    \end{example}
}

\devel{
    \begin{definition}
        \label{def:operad_from_monoidal}
        Let~$\tup{\CatC, {{\mtimescat}},\monunit}$ be a \SY{strict monoidal category}.
        Its associated \SY{operad}~$\operada_\CatC$ has:
        \begin{enumerate}
            \item \emph{Objects}: $\Obof{\operada_\CatC}=\ObC$;
            \item \emph{Morphisms}: $\HomSet{\operada_\CatC}{[\Obja_1,\ldots,\Obja_n]}{\Objb}=\HomSet{\CatC}{\Obja_1 \mtimescat \ldots \mtimescatob \Obja_n}{\Objb}$;
            \item \emph{Identity morphism}: $\catidat\Obja \setin \HomSet{\operada_\CatC}{[\Obja]}{\Obja}=\catidat\Obja \setin \HomSet{\CatC}{\Obja}{\Obja}$;
            \item \emph{Composition of morphisms:}
        \end{enumerate}
    \end{definition}}

\linkvideo{spring2021-operads-a:operad-monoidal-cat} % Operad from a monoidal category
\begin{remark}
    \label{operad-from-monoidal}
    For non-strict \SY{monoidal categories} it is also possible to define an associated \SY{operad} similarly.
    There are in fact various ways of going about this.
    One way is to choose a convention about bracketing: for instance one might set
    \begin{equation}
        \HomSet{\operada_\CatC}{[\Obja_1,\ldots,\Obja_n]}{\Objb}=\HomSet{\CatC}{ ( \dots (\Obja_1 \mtimescatob \Obja_2) \ldots \mtimescatob \Obja_n)}{\Objb}
    \end{equation}
    by putting all brackets in the left-most manner.
    Another approach is to invoke a well-known theorem (called the ``strictification theorem'' for \SY{monoidal categories}) that says that every \SY{monoidal category} is monoidally equivalent to a \SY{strict monoidal category}.
    Then, we can assume that one is working with the ``strict version'' of a given \SY{monoidal category}.
    We leave out discussing these technical details any further here.
    When using \SY{operads} associated with \SY{monoidal categories} we will sometimes simply act ``as if'' our \SY{monoidal categories} are strict, even when they are not.
\end{remark}

\begin{example}
    Let $\CatC = \Set$ be the category of sets and functions, and view it as equipped with the monoidal structure induced by the \SY{cartesian product}.
    This category is \emph{not} strict monoidal as is, however, in light of \cref{operad-from-monoidal}, we can still define an associated \SY{operad}.
    As mentioned there, we will sweep the details under the rug for the time-being and act as if the category~\Set were indeed strict monoidal.
    The associated \SY{operad} that we obtain from the \SY{monoidal category} \Set will also be called~\Set.
\end{example}

\linkvideo{spring2021-operads-b:functors-operads} % Functors between operads
\begin{ctdefinition}
    \label{def:functors-operads}
    Let~$\operada,\operadb$ be \SY{operads}.
    A \maindef{functor between operads}~$\funa\colon \operada \fto \operadb$  is composed of:
    \begin{enumerate}
        \item A function~$\funaob\colon \Obof\operada\sto \Obof\operadb$;
        \item A function
              \begin{equation}
                  \funamor\colon \HomSet{\operada}{[\Obja_1,\ldots,\Obja_n]}{\Objb}\sto \HomSet{\operadb}{[\funaob(\Obja_1),\ldots, \funaob(\Obja_n)]}{\funaob(\Objb)}.
              \end{equation}
    \end{enumerate}
    These constituents must satisfy conditions which encode compatibility with the composition operations and with \SY{identity morphisms}; these conditions are analogous to the ones in the definition of a \SY{functor} between categories.
\end{ctdefinition}

\linkvideo{spring2021-operads-b:operad-algebras} % Algebras for an operad

\begin{definition}[Algebra of an operad]
    \label{def:algebra-operad}
    \SYNDEF{algebra of an operad}
    Let~$\operada$ be an \SY{operad}.
    An \emph{algebra} for~$\operada$ is a \SY{functor} of \SY{operads}~$\operada \fto \Set$.
\end{definition}

\linkvideo{spring2021-operads-b:sets-algebras} % Sets as algebras
\devel{
    \begin{example}[Sets as algebras]
        \todotextjira{302}{\bernina: Finish trascribing}
    \end{example}
}
\linkvideo{spring2021-operads-b:semigroups-algebras} % Semigroups as algebras
\devel{
    \begin{example}[Semigroups as algebras]
        \todotextjira{302}{\bernina: Finish trascribing}

    \end{example}
}

\linkvideo{spring2021-operads-b:single-typed-branches} % Single Typed Branches
\linkvideo{spring2021-operads-b:operad-blueprint} % Operads as blueprints
\linkvideo{spring2021-monads-b:blueprint-monoids} % Blueprinting monoids

\begin{gradedexercise}[\exname{MonoidsAsAlgebras}]
    \label{ex:MonoidsAsAlgebras}
    Let $\operada$ be the following \SY{operad}.
    It has just a single object, which we call $\star$.
    For each natural number $n \setin \natnumbers$ (including $0$), we let $[n]$ denote the list consisting of $n$ copies of the object $\star$ (so $[0]$ in this case is a synonym for the empty list).
    With this notation, we define $\Hom_\operada([n];1)$ to be the 1-element set $\makeset{ * }$ for each $n \setin \natnumbers$.
    The intuition is that, for each $n$, $\Hom_\operada([n];1)$ represents a single $n$-ary operation.

    In this exercise, the task is to describe what an algebra for this \SY{operad} is.
    Try to prove as many of the statements that you make as you can.
\end{gradedexercise}

\solutionof{MonoidsAsAlgebras}

\linkvideo{spring2021-operads-b:actions-recap} % Recap Actions
\linkvideo{spring2021-operads-b:monoid-act-algebras} % Monoid actions as algebras

\begin{gradedexercise}[\exname{MonoidActionsAsAlgebras}]
    \label{ex:MonoidsActionsAsAlgebras}
    For the duration of this exercise, we fix a \SY{monoid} $\monA$.
    We define an $\operada$ as follows.
    It has a single object, which we call $\star$.
    For each natural number $n \setin \natnumbers$ (including $0$), let $[n]$ denote the list consisting of $n$ copies of the object $\star$.
    We define $\Hom_\operada([n];1)$ to be the set underlying $\monA$ if $n =1$, and we set $\Hom_\operada([n];1) = \Emptyset$ if $n \neq 1$.

    Can you describe what an algebra for this \SY{operad} is?
    Please prove your statements as best you can.
\end{gradedexercise}

\solutionof{MonoidActionsAsAlgebras}

\devel{
    \begin{definition}
        \label{def:cospan}
        Let~\CatC be a category.
        A \maindef{cospan} in~\CatC is a pair of morphisms to a common object:
        \equationsag{cospan}{eq:cospan}
    \end{definition}

    \linkvideo{spring2021-operads-b:co-span-operad} % Cospan Operad
    \linkvideo{spring2021-operads-b:wiring-diags-operads} % Wiring diagram operads

}

\showslides{
    \begin{forslides}
        \begin{equation}
            \label{eq:composition_operad}
            [\mora,\morb]\mthen \morc
        \end{equation}
    \end{forslides}

}

