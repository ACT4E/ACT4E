\section{Definitions}

\begin{definition}[Closed category]
    \label{def:closed-category}
    A category $\CatC$ is \emph{closed} if for any pair of objects $\Obja,\Objb$,
    the collection of morphisms $\HomSet\CatC\Obja\Objb$ can be seen as an object of
    \CatC.

    If the category $\CatC$ is closed, it is usual to indicate the homset as $\inthom\Obja\Objb$.
\end{definition}
\begin{definition}[Internal hom functors]
    \label{def:internal-hom-functors}
    For each object $\Obja$ of a closed category $\CatC$, we define the functor
    \begin{equation}
        \inthomleft{\Obja}: \CatC \fto \CatC\op
    \end{equation}
    defined as
    \begin{equation}
        \inthomleft{\Obja}(\Objb) = \inthom\Obja\Objb
    \end{equation}
    and
    \begin{equation}
        \inthomright{\Obja} \colon \CatC \fto \CatC
    \end{equation}
    defined as
    \begin{equation}
        \inthomright{\Obja}(\Objb) = \inthom\Obja\Objb.
    \end{equation}
\end{definition}

\begin{definition}[Closed monoidal category]
    \label{def:closed-monoidal-category}
    A \emph{closed monoidal category} is a monoidal category that is also closed
    in a ``compatible'' way.
    For any object $\Obja$, consider the functor
    \begin{equation}
        \funa_{\Obja} \colon \CatC \fto \CatC
    \end{equation}
    defined as
    \begin{equation}
        \funa_{\Obja}(\Objb) = \Objb \otimes \Obja,
    \end{equation}
    % and consider the functor defined as
    % \begin{equation}
    %     \inthomright{\Obja} \colon \CatC \fto \CatC
    % \end{equation}
    % defined as
    % \begin{equation}
    %     \inthomright{\Obja}(\Objb) = \inthom\Obja\Objb.
    % \end{equation}
    For the category to be closed monoidal, we require that $\funa$ and $\inthomright{\Obja}$ are a pair of adjoint functors.
\end{definition}

\begin{example}
    The category $\Set$ is monoidal closed.
    The condition
    spells out
    %
    \begin{equation}
        \HomSet\Set{\Obja\cartprod\Objb}{\Objc} \simeq \HomSet\Set{\Obja}{\Objc\cartprod\Objb}.
    \end{equation}

\end{example}

See \cref{def:compact-closed-category} and \cref{def:dualizable-object}.

%
%
% \begin{definition}[Compact closed category]
%     \label{def:compact-closed-category}
%         A \emph{compact closed category}, is a symmetric monoidal category in which every object is dualizable.
% \end{definition}

\begin{definition}[Autonomous category]
    \label{def:autonomous-category}
    A closed monoidal category that is also symmetric.
\end{definition}

\begin{definition}[Global dualizing object]
    \label{def:global-dualizing-object}
    A global dualizing object $\starob$ in a closed category~\CatC is an object such that the internal hom functor
    \begin{equation}
        \inthomleft{\starob}: \CatC \fto \CatC\op
    \end{equation}
    defined as
    \begin{equation}
        \inthomleft{\starob}(\Obja) = \inthom\Obja\starob
    \end{equation}
    % \begin{equation}
    %     (\inthom{-}{\starob}) \colon \CatC \to \CatC\op
    % \end{equation}
    is an equivalence of categories, which implies that for all objects $\Obja$ there is a canonical isomorphism
    \begin{equation}
        d_{\Obja}\colon\Obja\mto \func_{\starob}(\func_{\starob}(\Obja)).
    \end{equation}
\end{definition}

\begin{definition}[\starautonomous category]
    \label{def:star-autonomous-category-1}
    A \starautonomous category is an autonomous (symmetric closed monoidal) category with a global dualizing object: an object $\starob$ such that for each object $\Obja$ the canonical morphism
    obtained by applying twice the dualization
    \begin{equation}
        d_{\Obja}: \Obja \to \inthom{(\inthom\Obja\starob)}{\starob}
    \end{equation}
    is an isomorphism.
\end{definition}

\begin{definition}[\starautonomous category]
    \label{def:star-autonomous-categor-2y}
    A \starautonomous category is a symmetric monoidal category
    with a full and faithful functor
    \begin{equation}
        \funa: \CatC\op \fto \CatC
    \end{equation}
    such that there is a natural isomorphism
    \begin{equation}
        f : \HomSet\CatC{\Obja \otimes \Objb}{\funa(\Objc)} \simeq \HomSet\CatC{\Obja}{\funa(\Objb \otimes \Objc)}
    \end{equation}
\end{definition}

\begin{ctdefinition}[Polycategory]
    \label{def:polycategory}
    A \maindef{polycategory} $\PolyA$ is defined by:

    \constit
    \begin{enumerate}
        \item \emph{Objects:} a collection~$\Obof\PolyA$;
        \item \emph{Morphisms:} for each pair $\polyoba, \polyobb$ of \emph{lists} of elements of $\Obof\PolyA$
              a set
              \begin{equation}
                  \HomSet{\PolyA}{\polyoba}{\polyobb}
              \end{equation}
              elements of which are morphisms~$\polyoba \mto \polyobb$,
              also called ``polymaps''.
        \item \emph{Identity morphisms:} for each object~$\Obja$, a morphism
              \begin{equation}
                  \catidat\Obja \setin \HomSet{\PolyA}{\makelist{\Obja}}{\makelist{\Obja}};
              \end{equation}
        \item \emph{Composition operations:} for any tuple of lists of objects
              $\polyoba, \polyobb_1, \polyobb_2, \polyobc_1, \polyobc_2, \polyobd$ and any object $\Obja$,
              a composition map of the type
              \begin{equation}
                  \begin{aligned}
                      \mthen \colon \HomSet{\PolyA}{\polyoba}{\polyobb_1,\Obja,\polyobb_2}
                      \cartprod
                      \HomSet{\PolyA}{\polyobc_1,\Obja,\polyobc_2}{\polyobd} \\
                      \sto
                      \HomSet{\PolyA}{\polyobc_1,\polyoba,\polyobc_2}{\polyobb_1,\polyobd,\polyobb_2}.
                  \end{aligned}
              \end{equation}
    \end{enumerate}
    \condit
    \begin{enumerate}
        \item \emph{Associativity:} for any triple of morphism $\mora,\morb,\morc$ where
              \begin{equation}
                  \mora \colon \polyoba_1 \mto \polyoba_2,\Obja,\polyoba_3,
                  \quad
                  \morb  \colon \polyobb_1 , \Obja,  \polyobb_2 \mto \polyobb_3, \Objb ,\polyobb_4,
                  \qquad
                  \morc \colon \polyobc_1 , \Objb ,  \polyobc_2 \mto \polyobc_3.
              \end{equation}
              $(\mora\mthen\morb)\mthen\morc$ and  $\mora\mthen(\morb\mthen\morc)$ coincide
              and so we indicate them as
              \begin{equation}
                  \mora\mthen\morb\mthen\morc \colon \polyobc_1 , \polyobb_1 ,  \polyoba_1 , \polyobb_2  ,\polyobc_2
                  \mto
                  \polyoba_2, \polyobb_3, \polyobc_3 ,\polyobb_4, \polyoba_3.
              \end{equation}
        \item \emph{Neutrality}: for each $\mora: \polyoba, \Obja, \polyobb \mto \polyobc$, it holds that
              \begin{equation}
                  \catidat\Obja  \mthen \mora  =\mora.
              \end{equation}
              For each $\morb: \polyoba \mto \polyobc, \Obja, \polyobd$, it holds that
              \begin{equation}
                  \morb \mthen \catidat\Obja =\morb.
              \end{equation}
        \item \emph{Partial commutativity}:
              For any triple of morphism $\mora,\morb,\morc$ where
              \begin{equation}
                  \mora: \polyoba_1 \mto  \polyoba_2, \Obja, \polyoba_3,
                  \quad \morb: \polyobb_1 \mto  \polyobb_2, \Obja , \polyobb_3,
                  \quad
                  \morc: \polyobc_1, \Obja, \polyobc_2, \Objb , \polyobc_3 \mto \polyobc_4,
              \end{equation}
              if at least one of $\polyoba_2$ and $\polyobb_2$ is empty,
              and at least one of $\polyoba_3$ and $\polyobb_3$ is empty, then $\mora\mthen(\morb\mthen\morc)=(\mora\mthen\morb)\mthen\morc$.

              Symmetrically, for any triple of morphism $\mora,\morb,\morc$ where
              \begin{equation}
                  \morc: \polyobc_1 \mto \polyobc_2, \Obja, \polyobc_3, \Objb , \polyobc_4,
                  \quad
                  \mora: \polyoba_1, \Obja, \polyoba_2 \mto \polyoba_3,
                  \quad
                  \morb: \polyobb_1, \Objb, \polyobb_2 \mto \polyobb_3,
              \end{equation}
              if at least one of $\polyoba_1$ and $\polyobb_1$ is empty,
              and at least one of $\polyoba_2$ and $\polyobb_2$ is empty, then $\mora\mthen(\morb\mthen\morc)=(\mora\mthen\morb)\mthen\morc$.
    \end{enumerate}
\end{ctdefinition}

\begin{ctdefinition}[Symmetric polycategories]
    \label{def:symmetric-polycategory}
    A \maindef{symmetric polycategory} is a polycategory for which
    for all lists of objects $\polyoba, \polyobb$ of $\PolyA$, and for each permutation $\sigma$ of $\polyoba$ and $\tau$ of $\polyobb$,
    there are isomorphisms
    \begin{equation}
        \HomSet{\PolyA}{\polyoba}{\polyobb} \simeq \HomSet{\PolyA}{\sigma \polyoba}{\tau \polyobb}.
    \end{equation}
\end{ctdefinition}

Blanco and Zeilberger

\begin{ctdefinition}[Tensor product in a polycategory]
    \label{def:tensor-polycategory}
    Let $\polyoba$ be a list of objects in a polycategory~$\PolyA$.
    A \emph{tensor product} of~$\polyoba$ is an object $\lltimes \polyoba$ equipped with a polymap
    $\mora_{\polyoba}: \polyoba \mto \lltimes \polyoba$ such that the operation of precomposing with it
    \begin{equation}
        \text{precompose}_{\mora_\polyoba}: \HomSet{\PolyA}{\polyobb_1, \lltimes\polyoba, \polyobb_2}{\polyobc}
        \fto \HomSet{\PolyA}{\polyobb_1, \polyoba, \polyobb_2}{\polyobc}
    \end{equation}
    is invertible.
\end{ctdefinition}

% \begin{ctdefinition}[Co-tensor product in a polycategory]
%     \label{def:cotensor-polycategory}
%     Let $\polyobc$ be a list of objects in a polycategory $\PolyA$.
%     A \emph{tensor product} of $\polyobc$ is an object $\llpar \polyobc$ equipped with a polymap
%     $\morb_{\polyobb}: \llpar\polyobc \mto \polyobc$ such that the operation of postcomposing with it
%     \begin{equation}
%             \text{postcompose}_{\morb_\polyobc}: \HomSet{\PolyA}{\polyoba}{\polyobd_1, \lltimes\polyobc, \polyobd_2}
%             \fto \HomSet{\PolyA}{\polyoba}{\polyobd_1, \polyobc, \polyobd_2}
%     \end{equation}
%     is invertible.
% \end{ctdefinition}

\begin{ctdefinition}[Co-tensor product in a polycategory]
    \label{def:cotensor-polycategory}
    Let $\polyobc$ be a list of objects in a polycategory $\PolyA$.
    A \emph{co-tensor or par product} of~$\polyobc$ is an object $\llpar \polyobc$ equipped with a polymap
    $\morb_{\polyobb}: \llpar\polyobc \mto \polyobc$ such that the operation of postcomposing with it
    \begin{equation}
        \text{postcompose}_{\morb_\polyobc}: \HomSet{\PolyA}{\polyoba}{\polyobd_1, \llpar\polyobc, \polyobd_2}
        \fto \HomSet{\PolyA}{\polyoba}{\polyobd_1, \polyobc, \polyobd_2}
    \end{equation}
    is invertible.
\end{ctdefinition}

\begin{ctdefinition}[Representable polycategory]
    \label{def:representable-polycategory}
    A representable polycategory is a polycategory that has tensor and co-tensor products for all lists of objects.
\end{ctdefinition}

A representable polycategory is one where a morphism of the type
\begin{equation}\label{eq:polymora}
    \mora: \polyoba \mto \polyobb
\end{equation}
can be represented by a morphism
\begin{equation}\label{eq:polymora-tensors}
    \mora: (\polyobae_1 \lltimes \polyobae_2 \lltimes \cdots \lltimes \polyobae_n) \mto
    (\polyobbe_1 \llpar \polyobbe_2 \llpar \cdots \llpar \polyobbe_m )
\end{equation}

\begin{ctdefinition}[Right duals of objects in a polycategory]
    \label{def:right-duals-polycategory}
    A \emph{right dual} of an object $\Obja$ of a polycategory $\PolyA$ is an object $\rdualof\Obja$
    together with two polymaps
    \begin{equation}
        \rcupof\Obja \colon \emptylist \mto \Obja, \rdualof\Obja,
        \qquad
        \rcapof\Obja \colon \rdualof\Obja , \Obja \mto \emptylist,
    \end{equation}
    such that
    \begin{equation}
        \rcupof\Obja \mthenof{\rdualof\Obja} \rcapof\Obja = \catidat\Obja
        \quad\text{and}\qquad
        \rcapof\Obja \mthenof{\Obja} \rcupof\Obja = \catidat{\rdualof\Obja}.
    \end{equation}
\end{ctdefinition}

\begin{ctdefinition}[Left duals of objects in a polycategory]
    \label{def:left-duals-polycategory}
    A \emph{left dual} of an object $\Obja$ of a polycategory $\PolyA$ is an object $\ldualof\Obja$
    together with two polymaps
    \begin{equation}
        \lcupof\Obja \colon \emptylist \mto \ldualof\Obja, \Obja,
        \qquad
        \lcapof\Obja \colon \Obja , \ldualof\Obja \mto \emptylist,
    \end{equation}
    such that
    \begin{equation}
        \lcupof\Obja \mthenof{\ldualof\Obja} \lcapof\Obja = \catidat\Obja
        \quad\text{and}\qquad
        \lcapof\Obja \mthenof{\Obja} \lcupof\Obja = \catidat{\ldualof\Obja}.
    \end{equation}
\end{ctdefinition}

\begin{ctdefinition}[Right dual object in a monoidal category]
    \label{def:dualizable-object2}
    Let~$\tup{\CatC,\mtimesC,\idmoncat_{\CatC}}$ be a \SY{monoidal category}, and let~$\Obja \setin \ObC$.
    A \maindef{right dual object} of~$\Obja$ is specified by:

    \constit
    \begin{enumerate}
        \item an object $\Objadual \setin \ObC$;
        \item a morphism $\ev_\Obja\colon \Objadual \mtimescatob \Obja \mto \idmoncat$, called \emph{evaluation}; \label{def:ev}
        \item a morphism $\coev_\Obja\colon \idmoncat \mto \Obja \mtimescatob \Objadual$, called \emph{coevaluation};\label{def:coev}
    \end{enumerate}

    \condit
    \begin{enumerate}
        \item
              \begin{equation}\label{eq:snake-eq-1b}
                  \leftunitor_{\Obja}^{-1} \mthen (\coev_\Obja \mtimescatmor \catidat\Obja) \mthen \associator_{\Obja, \Objadual, \Obja} \mthen(\catidat\Obja \mtimescatmor \ev_\Obja) \mthen \rightunitor_{\Obja} = \catidat\Obja;
              \end{equation}
        \item
              \begin{equation}\label{eq:snack-eq-2b}
                  \rightunitor_{\Objadual}^{-1} \mthen (\catidat{\Objadual} \mtimescatmor \coev_\Obja) \mthen \associator_{\Objadual, \Obja, \Objadual}^{-1} \mthen (\ev_\Obja \mtimescatmor \catidat{\Objadual}) \mthen \leftunitor_{\Objadual} = \catidat{\Objadual}.
              \end{equation}
    \end{enumerate}
\end{ctdefinition}

\begin{ctdefinition}[Cartesian polycategory]
    \label{def:cartesian-polycategory}
    A Cartesian polycategory $\PolyA$ is a polycategory
    in which for each object $\Obja$ there exist
    two polymaps
    \begin{equation} \label{eq:polycopy}
        \polycopyof\Obja \colon \Obja \mto \Obja, \Obja
    \end{equation}
    \begin{equation} \label{eq:polydiscard}
        \polydiscardof\Obja \colon \Obja \mto \emptylist
    \end{equation}
    such that
    \begin{equation}
        \polycopyof\Obja \mthen \polydiscardof\Obja = \catidat\Obja.
    \end{equation}
\end{ctdefinition}
