\section{Parallel stacking}


So far we have seen how we can compose morphisms ``horizontally``:
%
\begin{equation}
    \prftree[r]{.}{
        \mora \colon \Obja \mto \Objb
    }{
        \morb\colon \Objb \mto \Objc
    }{
        \mora \mthen \morb \colon \Obja \mto \Objc
    }
\end{equation}
%
There are other notions of composition that allow us to compose morphisms by ``stacking them vertically``.
Given two morphisms
%
\begin{align}
    \mora &\colon \Obja \mto \Objb, \\
    \morb &\colon \Objc \mto \Objd,
\end{align}
%
we obtain by parallel stacking a morphism
%
\begin{align}
    (\mora\mtimescat \morb)  &\colon (\Obja \mtimescat \Objc) \mto (\Objb \mtimescat \Objd),
\end{align}
%
where ``$\mtimescat$`` is a stacking operation to be defined.
Note that while in the case of sequential composition there was a compatibility condition to be defined, as the target of the first morphism must be the source of the secon morphism, here instead we ask that we can stack arbistrary morphisms.

We also expect to be able to stack any number of morphisms. Having a collection of morphisms
%
\begin{equation}
    \mora_i \colon \Obja_i \mto \Objb_i, \qquad 1 \leq i \leq n,
\end{equation}
%
we expect to be able to obtain the composed morphism
%
\begin{equation}
    (\mtimescat_{i=1}^n  \mora_i )\colon( \mtimescat_{i=1}^n  \Obja_i )\mto (\mtimescat_{i=1}^n  \Objb_i).
\end{equation}

\subsection{Types of stacking operations}

There are various properties that one can consider for this stacking operation.
The ones that that we will consider in this chapter are:
%
\begin{enumerate}
    \item \emph{Stacking semi-category}: a semi-category in which the stacking operation is associative and makes objects and morphisms into a semigroup.
    \item \emph{Functorial stacking semi-category}: a stacking semi-category in which the stacking operation is also a functor.
    \item \emph{Symmetric stacking semi-category}: a stacking semi-category in which there is a series of symmetry isomorphisms that can permute the objects in a stack.
\end{enumerate}
%
In the next part we will talk about \emph{monoidal categories} (\cref{def:monoidal-category}), which can be seen as a generalization of stacking semi-categories where the stacking operation is not required to be associative ``on the nose'', but rather only up to isomorphism.

\begin{remark}
    [Choices in definitions $\star$]
    Of all these definitions, the only classical one is that of \emph{monoidal category}, and its specializations, such as strict monoidal category, braided monoidal category, and symetric monoidal category. We will look at all of those in~\cref{sec:parallelism-mon-cat}.

    We define the three non-classical notions mentioned above for the following reasons:
    \begin{itemize}
        \item Using the strictifaction construction of \SetStar most of the monoidal categories are strict; we can ask that the composition induces semigroups of morphisms.
        We will not need to define unitors and associators.
        In fact, we do not need to define natural transformations.
        \item There are important cases of semi-categories without identities with a stacking operation that do not fit the notion of monoidal category.
        An example is discrete-time linear systems.
        For these categories we also want to consider appropriate traces.
        \item There are important examples in which there is a way to stack morphisms but the stacking is not functorial. For example, we will describe a category of effectful computation with side effects.
    \end{itemize}
\end{remark}

\subsection{Stacking semi-categories}

\begin{ctdefinition}[Stacking semi-category]
    \label{def:stacking-semi-cat}
    A stacking semi-category is a semi-category with the following additional constituents and properties.

    \constit
    \begin{itemize}
        \item A stacking operation $\mtimescatob$ that makes the objects into a semigroup.
        \item A stacking operation $\mtimescatmor$ that makes the morphisms into a semigroup.
    \end{itemize}

    \condit
    \begin{itemize}
        \item The two operations $\mtimescatob$ and $\mtimescatmor$ are compatible in the sense that
        %
        \begin{equation}
            \prftree[r]{.}{
                \mora_i \colon \Obja_i \mto \Objb_i, \qquad 1 \leq i \leq n,
            }{
               ( \mtimescatmor_{i=1}^n \mora_i )\colon( \mtimescatob_{i=1}^n \Obja_i) \mto (\mtimescatob_{i=1}^n \Objb_i).
            }
        \end{equation}
    \end{itemize}
\end{ctdefinition}

\begin{example}[\SetStar is a stacking semi-category]
    \SetStar (\cref{def:SetL}) is a stacking semi-category,
    with list concatenation being the semigroup operation.
\end{example}

\subsection{The \Effects category}

Let's now construct a non-trivial category that will serve as an example of a stacking semi-category that is not functorial.

There are two types of computation: ``functional'', or ``pure'', or free of side-effects, and \emph{effectful}.
In functional programming, functions are very much like mathematical functions: they need an input and produce and output. They don't interfer with other functions.

Effectful procedurees instead, can ``change the world'': for example, printing a page, sending an email, or placing an order of pizza. The order in which effectful procedures are evaluated might change the result. For example, the result of the operations 
% 
\begin{enumerate}
\item Order a pizza;
\item Cancel the last order.
\end{enumerate}
% 
is different than the result of 
% 
\begin{enumerate}
    \item Cancel the last order.
    \item Order a pizza;
\end{enumerate}

Also side-effects can be treated mathematically. 
A very elegant way is using \emph{linear types} \XXX. 
We will mention those in a successive part on linear logic. 
For now, let's have a simple treatment.

The idea is to add another variable that represents ``the world'' that can be affected. 
An effectful function 
\begin{equation}
    \mora: \Obja \mto \Objb,
\end{equation}
which could have some unknown side-effects on the world, can be represented by a pure function 
% 
\begin{equation}
    \mora_e:  \Obja \stimes \EfW \mto   \Objb \stimes \EfW,
\end{equation}
% 
where $\EfW$ is the set of all possible worlds. 
The second input to $\mora_e$ is the state of the world before the execution of the function. 
The second output of $\mora_e$ is the state of the world after the execution of the function. 

We can now interconnect different effectful functions, with some precautions.

\begin{definition}[\Effects]
    \begin{itemize}
        \item \emph{Objects}: same as the objects of \SetStar;
        \item \emph{Morphisms}: a morphism $\mora: \Obja \mto_{\Effects} \Objb$ is a function 
        \begin{equation}
            \mora_e: \Tupcat \Obja \EfW \mto_{\SetStar} \Tupcat \Objb \EfW,
        \end{equation}
        where $\EfW$ is the set of all possible worlds. 
        \item \emph{Composition}: The composition of  $\mora: \Obja \mto_{\Effects} \Objb$ and 
        $\morb: \Objb \mto_{\Effects} \Objc$ is a morphism $\morab: \Obja \mto_{\Effects} \Objb$ with function $(\morab)_e$ given by 
        \todographics{figure}
    \end{itemize}
\end{definition}

