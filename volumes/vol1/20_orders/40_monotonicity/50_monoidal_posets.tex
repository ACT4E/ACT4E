% !TEX root = chapter-standalone.tex

\section{Monoidal posets}
\label{sec:monoidal-posets}
\linkvideo{spring2021-par-feedback:mon-cat:mon-pos} % Monoidal posets

A monoidal poset is a poset that is also a monoid, and in which the monoidal product is a monotone map that is compatible with the order.

% In order to ``warm up", we first consider the definition of a monoidal structure for a poset.
% Posets are a simpler special case of categories, and the following definition is a special case of the general definition of a monoidal category.

\begin{ctdefinition}[\iindex{Monoidal poset}]
    \label{def:monoidal-poset}
    A \emph{monoidal structure} on a poset~$\Cat{P} = \tup{\posAset, \posAleq}$ is specified by:

    \constit
    \begin{enumerate}
        \item A monotone map~$\mtimescat \colon \Cat{P} \Ctimes \Cat{P} \fto \Cat{P}$, called the \emph{monoidal product}.

              \noindent
              Note that here we are implicitly assuming~$\Cat{P} \Ctimes \Cat{P}$ as having the product order.
              In detail, monotonicity means that, for all~$\posela_1, \posela_2, \poselb_1, \poselb_2 \in \posA$:
              \begin{equation}
                  \prfperiod{\posela_1 \posAleq \poselb_1}{\posela_2 \posAleq \poselb_2}{ (\posela_1 \mtimescat  \posela_2) \posAleq  (\poselb_1 \mtimescat  \poselb_2)}
              \end{equation}
        \item An element~$\idmoncat \in \posA$, called the \emph{monoidal unit}.
    \end{enumerate}

    \condit
    \begin{enumerate}
        \item Associativity: for all~$\posela, \poselb, \poselc \in \posA$:
              \begin{equation}
                  (\posela \mtimescat \poselb)
                  \mtimescat \poselc =  \posela  \mtimescat ( \poselb \mtimescat \poselc).
              \end{equation}
        \item Left and right unitality: for all~$\posela \in \posA$:
              \begin{equation}
                  \idmoncat \mtimescat \posela = \posela
                  \qqand
                  \posela \mtimescat \idmoncat = \posela.
              \end{equation}
    \end{enumerate}

    \noindent A poset equipped with a monoidal structure is called a \emph{monoidal poset}.
\end{ctdefinition}

\begin{ctdefinition}[\iindex{Symmetric monoidal poset}]
    \label{def:sym-monoidal-poset}
    A \emph{symmetric monoidal poset} is a monoidal poset~$\posA=\tup{\posAset, \posAleq, \mtimescat, \idmoncat}$ such that, for all~$\posela, \poselb \in \posA$,
    \begin{equation}
        \posela \mtimescat \poselb = \poselb \mtimescat \posela.
    \end{equation}
\end{ctdefinition}

\begin{example}[Reals with addition]
    \label{ex:monoidal-pos-reals}
    Consider the real numbers~\reals with the poset structure given the usual ordering.
    Consider 0 as the monoidal unit and the operation~$+\colon \reals\cartprod \reals\sto \reals$ as mononidal product.
    It is easy to see that the conditions of~\cref{def:monoidal-poset} are satisfied:
    \begin{enumerate}[(a)]
        \item Given~$p_1,p_2,q_1,q_2\in \reals$, we know:
              \begin{equation*}
                  \prfperiod{
                      p_1\Rleq  p_2
                  }{
                      q_1\Rleq  q_2
                  }{
                      (p_1+p_2) \Rleq  (q_1+q_2)
                  }
              \end{equation*}
        \item $0+p=p+0=0$,~$\forall p\in \reals$.
        \item $(p+q)+r=p+(q+r)$,~$\forall p,q,r\in \reals$.
    \end{enumerate}
\end{example}

\begin{counterexample}
    Someone proposes now to substitute the monoidal unit in \cref{ex:monoidal-pos-reals} with 1 and the monoidal product with multiplication ``$\cdot$''.
    This does not form a monoidal poset anymore.
    To see a simple counterexample, consider the fact that~$-5\Rleq 0$ and~$-4\Rleq 3$.
    However,~$(-5)\cdot (-4) \not{\Rleq} 0 \cdot 3$.
\end{counterexample}

\begin{example}[Boolean monoid]
    The booleans form a monoidal poset $\tupp{\Bool,\posleqof{\Bool},\true,\booland}$
    with the unit being~$\true$ and the product being $\booland$.
    The action of the monoidal product ``$\booland$'' can be summarized in a table:
    \begin{center}
        \begin{tabular}{c|cc}
            $\booland$ & $\false$ & $\true$  \\
            \hline
            $\false$   & $\false$ & $\false$ \\
            $\true$    & $\false$ & $\true$
        \end{tabular}
    \end{center}
    From this table, it is clear that given~$\ela_1\posleqof{\Bool}\elb_1$ and~$\ela_2\posleqof{\Bool} \elb_2$, one has~$\ela_1\booland x_2\posleqof{\Bool} \elb_1\booland \elb_2$ (if you do not believe it, try all possible combinations).
    Furthermore,~$\ela\booland \true=\ela=\true \booland \ela$.
\end{example}

\showslides{
    \begin{forslides}
        \begin{equation*}
            \label{eq:monpos_1}
            \prftree{p_1\leq p_2}{q_1\leq q_2}{p_1+p_2\leq q_1+q_2}
        \end{equation*}
        \begin{equation*}
            \label{eq:monpos_2}
            0+p=p+0=0
        \end{equation*}
        \begin{equation*}
            \label{eq:monpos_3}
            (p+q)+r=p+(q+r)
        \end{equation*}

        \includesag{scooter}
        \includesag{av}
        \includesag{av_scooter}
        \includesag{av_scooter_bis}

    \end{forslides}
}

\section{Monoidal-time procedures}
\label{sec:ProcMod}

Now that we know about posets, monotone functions and monoidal posets, we can extend the example of \ProcSizeTime in \vref{def:ProcSizeTime}.

Before, we thought of sized sets (\cref{def:sized-set}) as a datatype that can be measured with integer sizes.
However, this does not capture some important cases.
For example, if we are dealing with \emph{trees}, from the point of view of computation it could be important to think about multidimensional sizes: for example, we might want to account for number of nodes, number of edges, maximum branching factor, and so on.
Still, we want to know when an instance is bigger than another: this is a perfect job for posets.

\begin{definition}[Poset-sized sets]
    \label{def:poset-sized-set}
    A poset-sized set is a tuple $\tupp{\setA, \Sigma_{\setA}, \sizefun}$, where $\setA$ is a set, $\Sigma_\setA$ is a poset, and  $\sizefun \colon \setA \sto \Sigma_\setA$ is the size function.
\end{definition}

In \ProcSizeTime, we assumed that time was measured using real numbers.
We can generalize this to an arbitrary poset, for example allowing counting ``number of operations''.
We need an additional structure: in \vref{eq:timefun-composition} we needed a ``+'' to sum the time of successive procedures.
Therefore, we assume that we have a time monoidal poset \TimeMonoidal.

\begin{definition}
    [Semicategory $\ProcMod$]
    \label{def:ProcMod}
    For a given monoidal poset $\tupp{\TimeMonoidal, \mtimescat_{\TimeMonoidal}}$, the semicategory~$\ProcMod$ consists of the following constituents:
    \begin{enumerate}
        \item \emph{Objects}: The objects are poset-sized sets.
        \item \emph{Morphisms}: A morphism
              \begin{equation}
                  \mora \colon \Obja \mtoin\ProcSize \Obja
              \end{equation}
              between the two objects
              \begin{equation}
                  \Obja = \tupp{\setA, \Sigma_{\setA}, \sizefun_{\setA}}
                  \qqand
                  \Objb = \tupp{\setB, \Sigma_{\setA}, \sizefun_{\setB}}
              \end{equation}
              is a tuple
              \begin{equation}
                  \tupp{\mora_e, \sizetran, \timefun },
              \end{equation}
              where:
              \begin{enumerate}
                  \item $\mora_e : \setA \sto \setB$ is the function computed;
                  \item $\sizetran: \Sigma_{\setA} \toinPos \Sigma_{\setB}$ is a monotone function that keeps track of how the size changes.
                  \item $\timefun: \Sigma_{\setA} \toinPos \TimeMonoidal$ is a monotone function that gives computation time as a function of instance size;
              \end{enumerate}

        \item \emph{Composition}: The composition of
              \begin{equation}
                  \tupp{\mora_1, \sizetran_1,  \timefun_1  }
                  \qqand
                  \tupp{\morb_2, \sizetran_2,  \timefun_2  }
              \end{equation}
              is given by
              \begin{equation}
                  \tupp{
                      \mora_{1;2},
                      \sizetran_{1;2},
                      \timefun_{1,2}
                  }.
              \end{equation}
              where
              \begin{equation}
                  \mora_{1;2} = \mora_1 \mthen \morb_2,
              \end{equation}
              \begin{equation}
                  \sizetran_{1;2} = \sizetran_1 \mthen \sizetran_2,
              \end{equation}
              and $\timefun_{1,2}$ is defined as
              \begin{equation}
                  \definemapperiod{
                      \timefun_{1,2}
                  }{
                      \Sigma_{\setA}
                  }{
                      \TimeMonoidal
                  }{
                      \sigma_{\setA}
                  }{
                      \timefun_1(\sigma_{\setA}) \mtimescat_{\TimeMonoidal} \timefun_2(\sizetran_1(\sigma_{\setA}))
                  }
              \end{equation}
    \end{enumerate}
\end{definition}

\iflabelexists{sub:monoidal-space-time}{
    \begin{remark}[Spoilers]
        This example will be extended in \vref{sub:monoidal-space-time}, where we will add a notion of memory and parallel computation.
    \end{remark}
}
