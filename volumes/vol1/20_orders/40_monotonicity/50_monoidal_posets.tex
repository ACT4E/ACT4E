% !TEX root = chapter-standalone.tex

\section{Monoidal posets}
\label{sec:monoidal-posets}
\linkvideo{spring2021-par-feedback:mon-cat:mon-pos} % Monoidal posets


A monoidal poset is a poset that is also a monoid, and in which the monoidal product is a monotone map that is compatible with the order.


% In order to ``warm up", we first consider the definition of a monoidal structure for a poset.
% Posets are a simpler special case of categories, and the following definition is a special case of the general definition of a monoidal category.

\begin{ctdefinition}[\iindex{Monoidal poset}]
    \label{def:monoidal-poset}
    A \emph{monoidal structure} on a poset~$\Cat{P} = \tup{\posAset, \posAleq}$ is specified by:

    \constit
    \begin{enumerate}
        \item A monotone map~$\mtimescat \colon \Cat{P} \Ctimes \Cat{P} \fto \Cat{P}$, called the \emph{monoidal product}.

              \noindent
              Note that here we are implicitly assuming~$\Cat{P} \Ctimes \Cat{P}$ as having the product order.
              In detail, monotonicity means that, for all~$\posela_1, \posela_2, \poselb_1, \poselb_2 \in \posA$:
              \begin{equation}
                  \prfperiod{\posela_1 \posAleq \poselb_1}{\posela_2 \posAleq \poselb_2}{ (\posela_1 \mtimescat  \posela_2) \posAleq  (\poselb_1 \mtimescat  \poselb_2)}
              \end{equation}
        \item An element~$\idmoncat \in \posA$, called the \emph{monoidal unit}.
    \end{enumerate}

    \condit
    \begin{enumerate}
        \item Associativity: for all~$\posela, \poselb, \poselc \in \posA$:
              \begin{equation}
                  (\posela \mtimescat \poselb)
                  \mtimescat \poselc =  \posela  \mtimescat ( \poselb \mtimescat \poselc).
              \end{equation}
        \item Left and right unitality: for all~$\posela \in \posA$:
              \begin{equation}
                  \idmoncat \mtimescat \posela = \posela \quad \quad \text{ and } \quad \quad \posela \mtimescat \idmoncat = \posela.
              \end{equation}
    \end{enumerate}

    \noindent A poset equipped with a monoidal structure is called a \emph{monoidal poset}.
\end{ctdefinition}

\begin{ctdefinition}[\iindex{Symmetric monoidal poset}]
    \label{def:sym-monoidal-poset}
    A \emph{symmetric monoidal poset} is a monoidal poset~$\posA=\tup{\posAset, \posAleq, \mtimescat, \idmoncat}$ such that, for all~$\posela, \poselb \in \posA$,
    \begin{equation}
        \posela \mtimescat \poselb = \poselb \mtimescat \posela.
    \end{equation}
\end{ctdefinition}

\begin{example}[Reals with addition]
    \label{ex:monoidal-pos-reals}
    Consider the real numbers~\reals with the poset structure given the usual ordering.
    Consider 0 as the monoidal unit and the operation~$+\colon \reals\cartprod \reals\sto \reals$ as mononidal product.
    It is easy to see that the conditions of~\cref{def:monoidal-poset} are satisfied:
    \begin{enumerate}[(a)]
        \item Given~$p_1,p_2,q_1,q_2\in \reals$, we know:
              \begin{equation*}
                  \prfperiod{
                      p_1\Rleq  p_2
                  }{
                      q_1\Rleq  q_2
                  }{
                      (p_1+p_2) \Rleq  (q_1+q_2)
                  }
              \end{equation*}
        \item $0+p=p+0=0$,~$\forall p\in \reals$.
        \item $(p+q)+r=p+(q+r)$,~$\forall p,q,r\in \reals$.
    \end{enumerate}
\end{example}

\begin{counterexample}
    Someone proposes now to substitute the monoidal unit in \cref{ex:monoidal-pos-reals} with 1 and the monoidal product with multiplication ``$\cdot$''.
    This does not form a monoidal poset anymore.
    To see a simple counterexample, consider the fact that~$-5\Rleq 0$ and~$-4\Rleq 3$.
    However,~$(-5)\cdot (-4) \not{\Rleq} 0 \cdot 3$.
\end{counterexample}

\begin{example}[Boolean monoid]
    The booleans form a monoidal poset $\tupp{\Bool,\posleqof{\Bool},\true,\booland}$
    with the unit being~$\true$ and the product being $\booland$.
    The action of the monoidal product ``$\booland$'' can be summarized in a table:
    \begin{center}
        \begin{tabular}{c|cc}
            $\booland$ & $\false$ & $\true$  \\
            \hline
            $\false$   & $\false$ & $\false$ \\
            $\true$    & $\false$ & $\true$
        \end{tabular}
    \end{center}
    From this table, it is clear that given~$\ela_1\posleqof{\Bool}\elb_1$ and~$\ela_2\posleqof{\Bool} \elb_2$, one has~$\ela_1\booland x_2\posleqof{\Bool} \elb_1\booland \elb_2$ (if you do not believe it, try all possible combinations).
    Furthermore,~$\ela\booland \true=\ela=\true \booland \ela$.
\end{example}

\showslides{
    \begin{forslides}
        \begin{equation*}
            \label{eq:monpos_1}
            \prftree{p_1\leq p_2}{q_1\leq q_2}{p_1+p_2\leq q_1+q_2}
        \end{equation*}
        \begin{equation*}
            \label{eq:monpos_2}
            0+p=p+0=0
        \end{equation*}
        \begin{equation*}
            \label{eq:monpos_3}
            (p+q)+r=p+(q+r)
        \end{equation*}

        \includesag{scooter}
        \includesag{av}
        \includesag{av_scooter}
        \includesag{av_scooter_bis}

    \end{forslides}
}

\subsection{Monoidal-time procedures}
\label{sub:ProcMod}

Now that we know about posets, monotone functions and monoidal posets, we can extend the example of \ProcSizeTime in \vref{def:ProcSizeTime}.

Before, we thought of sized sets (\cref{def:sized-set}) as a datatype that can be measured with integer sizes. However, this does not capture some important cases. For example, if we are dealing with \emph{trees}, from the point of view of computation it could be important to think about multidimensional sizes: for example, we might want to account for number of nodes, number of edges, maximum branching factor, and so on. Still, we want to know when an instance is bigger than another: this is a perfect job for posets.

\begin{definition}[Poset-sized sets]\label{def:poset-sized-set}
    A poset-sized set is a tuple $\tupp{\setA, \Sigma_{\setA}, \sizefun}$, where $\setA$ is a set, $\Sigma_\setA$ is a poset, and  $\sizefun \colon \setA \sto \Sigma_\setA$ is the size function.
\end{definition}

\newcommand{\TimeMonoidal}{\Cat{T}}
\newcommand{\SpaceMonoidal}{\Cat{S}}
\newcommand{\SpaceTime}{\SpaceMonoidal\TimeMonoidal}
\newcommand{\ProcMod}{\Cat{ProcSizeTime}_{\TimeMonoidal}}
\newcommand{\ProcSTMod}{\Cat{ProcSizeTime}_{\SpaceTime}}
\newcommand{\spacefun}{\operatorname{space}}


In \ProcSizeTime, we assumed that time was measured using real numbers. We can generalize this to an arbitrary poset, for example allowing counting ``number of operations''.
We need an additional structure: in \vref{eq:timefun-composition} we needed a ``+'' to sum the time of successive procedures. Therefore, we assume that we have a time monoidal poset \TimeMonoidal.


\begin{definition}[Semicategory $\ProcMod$]
    \label{def:ProcMod}
    For a given monoidal poset $\tupp{\TimeMonoidal, \mtimescat_{\TimeMonoidal}}$, the semicategory~$\ProcMod$ consists of the following constituents:
    \begin{enumerate}
        \item \emph{Objects}: The objects are poset-sized sets.
        \item \emph{Morphisms}: A morphism
        \begin{equation}
            \mora \colon \Obja \mtoin\ProcSize \Obja
        \end{equation}
        between the two objects
        \begin{equation}
            \Obja = \tupp{\setA, \Sigma_{\setA}, \sizefun_{\setA}}
            \qqand
            \Objb = \tupp{\setB, \Sigma_{\setA}, \sizefun_{\setB}}
        \end{equation}
        is a tuple
        \begin{equation}
            \tupp{\mora_e, \sizetran, \timefun },
        \end{equation}
        where:
        \begin{enumerate}
            \item $\mora_e : \setA \sto \setB$ is the function computed;
            \item $\sizetran: \Sigma_{\setA} \toinPos \Sigma_{\setB}$ is a monotone function that keeps track of how the size changes.
            \item $\timefun: \Sigma_{\setA} \toinPos \TimeMonoidal$ is a monotone function that gives computation time as a function of instance size;
        \end{enumerate}

        \item \emph{Composition}: The composition of
        \begin{equation}
            \tupp{\mora_1, \sizetran_1,  \timefun_1  }
            \qqand
            \tupp{\morb_2, \sizetran_2,  \timefun_2  }
        \end{equation}
        is given by
        \begin{equation}
            \tupp{
                \mora_{1;2},
                \sizetran_{1;2},
                \timefun_{1,2}
            }.
        \end{equation}
        where
        \begin{equation}
            \mora_{1;2} = \mora_1 \mthen \morb_2,
        \end{equation}
        \begin{equation}
            \sizetran_{1;2} = \sizetran_1 \mthen \sizetran_2,
        \end{equation}
        and $\timefun_{1,2}$ is defined as
        \begin{equation}\label{eq:timefun-composition}
            \definemapperiod{
                \timefun_{1,2}
            }{
                \Sigma_{\setA}
            }{
                \TimeMonoidal
            }{
                \sigma_{\setA}
            }{
                \timefun_1(\sigma_{\setA}) \mtimescat_{\TimeMonoidal} \timefun_2(\sizetran_1(\sigma_{\setA}))
            }
        \end{equation}
    \end{enumerate}
\end{definition}



\iflabelexists{sub:monoidal-space-time}{
    \begin{remark}[Spoilers]
       This example will be extended in \vref{sub:monoidal-space-time}, where we will add a notion of memory and parallel computation.
    \end{remark}
}

\subsection{Monoidal-space-time procedures}
\label{sub:monoidal-space-time}
We continue the example in \cref{sub:ProcMod}.

Procedures need both computation (time) and memory (space).

\todographics{Simple graphics to accompany explanation.}
Time and space are somehow orthogonal.
%
Informally, consider two procedures that need time and memory given by $\tupp{t_1,m_1}$ and $\tupp{t_2, m_2}$. If we compose them in series, we need to sum the times, but we can re-use the same memory. We can bound the resources consumption  by $\tupp{t_1+t_2,\max(m_1, m_2)}$.
If instead we run them in parallel, we can save on the time, but we need separate memories, so that the consumption is $\tupp{\max(t_1,t_2), m_1 + m_2}$.

We capture this more generally as follows. We require both time and space to be monoidal lattices $\tupp{\TimeMonoidal, \mtimescat_{\TimeMonoidal}, \join_{\TimeMonoidal}}$ and
$\tupp{\SpaceMonoidal, \mtimescat_{\SpaceMonoidal}, \join_{\SpaceMonoidal}}$.
%
We will define series and parallel composition as follows:
\begin{equation}
    \begin{aligned}
        \tupp{t_1,m_1} \mthen_{\SpaceTime}  \tupp{t_2,m_2} &= \tupp{t_1 \mtimescat_{\TimeMonoidal} t_2, m_1 \join_{\SpaceMonoidal} m_2}, \\
        \tupp{t_1,m_1} \mtimescat_{\SpaceTime}  \tupp{t_2,m_2} &= \tupp{t_1 \join_{\TimeMonoidal} t_2, m_1 \mtimescat_{\SpaceMonoidal} m_2}.
    \end{aligned}
\end{equation}
We use the join operation $\join$ to model the idea of $\max$.

We now generalize the definition of $\ProcMod$ into $\ProcSTMod$.



\begin{definition}[Semicategory $\ProcSTMod$]
    \label{def:ProcMod}
    For given monoidal lattices $\tupp{\TimeMonoidal, \mtimescat_{\TimeMonoidal}, \join_{\TimeMonoidal}}$ and $\tupp{\SpaceMonoidal, \mtimescat_{\SpaceMonoidal}, \join_{\SpaceMonoidal}}$, the semicategory $\ProcSTMod$ consists of the following constituents:
    \begin{enumerate}
        \item \emph{Objects}: The objects are poset-sized sets.
        \item \emph{Morphisms}: A morphism
        \begin{equation}
            \mora \colon \Obja \mtoin\ProcSTMod \Obja
        \end{equation}
        between the two objects
        \begin{equation}
            \Obja = \tupp{\setA, \Sigma_{\setA}, \sizefun_{\setA}}
            \qqand
            \Objb = \tupp{\setB, \Sigma_{\setA}, \sizefun_{\setB}}
        \end{equation}
        is a tuple
        \begin{equation}
            \tupp{\mora_e, \sizetran, \timefun, \spacefun },
        \end{equation}
        where:
        \begin{enumerate}
            \item $\mora_e : \setA \sto \setB$ is the function computed;
            \item $\sizetran: \Sigma_{\setA} \toinPos \Sigma_{\setB}$ is a monotone function that keeps track of how the size changes.
            \item $\timefun: \Sigma_{\setA} \toinPos \TimeMonoidal$ is a monotone function that gives computation time as a function of instance size;
            \item $\spacefun: \Sigma_{\setA} \toinPos \SpaceMonoidal$ is a monotone function that gives memory needed as a function of instance size.
        \end{enumerate}

        \item \emph{Composition}: The composition of
        \begin{equation}
            \tupp{\mora_1, \sizetran_1,  \timefun_1 , \spacefun_1 }
            \qqand
            \tupp{\morb_2, \sizetran_2,  \timefun_2 , \spacefun_2 }
        \end{equation}
        is given by
        \begin{equation}
            \tupp{
                \mora_{1;2},
                \sizetran_{1;2},
                \timefun_{1,2},
                \spacefun_{1,2}
            }.
        \end{equation}
        where
        \begin{equation}
            \mora_{1;2} = \mora_1 \mthen \morb_2,
        \end{equation}
        \begin{equation}
            \sizetran_{1;2} = \sizetran_1 \mthen \sizetran_2,
        \end{equation}
        \begin{equation}
            \definemapperiod{
                \timefun_{1,2}
            }{
                \Sigma_{\setA}
            }{
                \TimeMonoidal
            }{
                \sigma_{\setA}
            }{
                \timefun_1(\sigma_{\setA}) \mtimescat_{\TimeMonoidal} \timefun_2(\sizetran_1(\sigma_{\setA}))
            }
        \end{equation}
        \begin{equation}
            \definemapperiod{
                \spacefun_{1,2}
            }{
                \Sigma_{\setA}
            }{
                \SpaceMonoidal
            }{
                \sigma_{\setA}
            }{
                \spacefun_1(\sigma_{\setA}) \join_{\SpaceMonoidal} \spacefun_2(\sigma_{\setA}) 
            }
        \end{equation}
    \end{enumerate}
\end{definition}

We can also give $\ProcSTMod$ the structure of a stacking category as follows:

\begin{lemma}
    $\ProcSTMod$ is a stacking semicategory as follows.
    For two objects 
    \begin{equation}
        \Obja = \tupp{\setA, \Sigma_{\setA}, \sizefun_{\setA}} 
        \qqand 
        \Objb = \tupp{\setB, \Sigma_{\setB}, \sizefun_{\setB}}
    \end{equation}
    we define the combined object $\Obja \mtimescatob \Objb$ by combining the sets and functions 
    \begin{equation}
        \Obja \mtimescatob \Objb = \tupp{ 
            \Tupcat \setA \setB, 
            \Tupcat {\Sigma_{\setA}} {\Sigma_{\setA}}, 
            \sizefun_{\setA\setB}
            },
    \end{equation}
    where 
    \begin{equation}
        \definemapperiod{
            \sizefun_{\setA\setB}
        }{
            \Tupcat \setA \setB
        }{
            \Tupcat {\Sigma_{\setA}} {\Sigma_{\setA}}
        }{
            \tup{a,b} 
        }{
            \tup{
                \sizefun_{\setA}(a),
                \sizefun_{\setA}(b)
            } 
        }
    \end{equation}

    For two morphisms 
    \begin{equation}
        \mora_1 \colon \Obja_1 \mto \Objb_1
        \qqand 
        \mora_2 \colon \Obja_2 \mto \Objd_2,
    \end{equation}
    % where the four objects involved are:
    % \begin{align}
    %     \Obja &= \tupp{\setA, \Sigma_{\setA}, \sizefun_{\setA}} \\
    %     \Objb &= \tupp{\setB, \Sigma_{\setB}, \sizefun_{\setB}} \\
    %     \Objc &= \tupp{\setC, \Sigma_{\setC}, \sizefun_{\setC}} \\
    %     \Objd &= \tupp{\setD, \Sigma_{\setD}, \sizefun_{\setD}} 
    % \end{align}
    represented as follows:
    \begin{align}
        \mora_1    &= \tupp{\mora^e_1, \sizetran_1,  \timefun_1,
        \spacefun_{1}  } \\
        \mora_2   &= \tupp{\mora^e_2, \sizetran_2,  \timefun_2, \spacefun_{2} }
    \end{align}
    we define the parallel stack as 
    \begin{equation}
        \mora_1 \mtimescatmor \mora_2 = \tupp{
            \mora^e_{1\otimes2}, 
            \sizetran_{1\otimes2}, 
             \timefun_{1\otimes2}, 
             \spacefun_{1\otimes2} 
        },
    \end{equation}
    where
    \begin{equation}
        \mora_{1\otimes2} = \tupcat {\mora_1}  {\morb_2},
    \end{equation}
    \begin{equation}
        \sizetran_{1\otimes2} =  \tupcat {\sizetran_1}  {\sizetran_2},
    \end{equation}
    \begin{equation}
        \definemapperiod{
            \timefun_{1\otimes 2}
        }{
            \Tupcat {\Sigma_{\setA}} {\Sigma_{\setB}}
        }{
            \TimeMonoidal
        }{
            \tupcat {\sigma_{\setA}} {\sigma_{\setB}}
        }{
            \timefun_1(\sigma_{\setA}) \join_{\TimeMonoidal} \timefun_2(\sigma_{\setB})
        }
    \end{equation}
    \begin{equation}
        \definemapperiod{
            \spacefun_{1\otimes2}
        }{
            \Tupcat {\Sigma_{\setA}} {\Sigma_{\setB}}
        }{
            \SpaceMonoidal
        }{
            \sigma_{\setA}
        }{
            \spacefun_1(\sigma_{\setA}) \mtimescat_{\SpaceMonoidal} \spacefun_2(\sigma_{\setB}) 
        }
    \end{equation}
\end{lemma}