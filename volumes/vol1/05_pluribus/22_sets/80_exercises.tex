

\section{Code exercises}

We go on assuming that you have already completed the tutorial in \cref{sec:exercise-tutorial}.

\subsection{Properties}

\begin{gradedexercise}[\exname{TestFiniteSetProperties}]
  Given two finite sets, check if they are a subset of the other.
  Implement the interface in \cref{fig:FiniteSetProperties}.

\end{gradedexercise}

\begin{figure}
\classsource{FiniteSetProperties}{}
\caption{The \classname{FiniteSetProperties} interface}
\label{fig:FiniteSetProperties}
\end{figure}

Check your results with

\begin{console}
 make check-TestFiniteSetProperties
\end{console}

\subsection{Computing union of sets}


\begin{gradedexercise}[\exname{TestMakeSetUnion}]
  Implement the interface in \cref{fig:MakeSetUnion}.
  The \str{@overload} annotations means that:
   \begin{itemize}
   \item if the method is given all \FiniteSet, it should return a \FiniteSet;
    \item if the method is give all \EnumerableSet, it should return an \EnumerableSet;
    \item otherwise, in the general case, it should return a \Setoid.
    \end{itemize}
\end{gradedexercise}


\begin{figure}
\classsource{MakeSetUnion}{}
\caption{The \classname{MakeSetUnion} interface}
\label{fig:MakeSetUnion}
\end{figure}

Check your results with
\begin{console}
  make check-TestMakeSetUnion
\end{console}



\subsection{Reading union of sets}

\margindatafilefig{set_union}{Union}{fig:set_union}

Extend now the code you wrote for loading sets to allow the format in \cref{fig:set_product}.

This is the algorithm to implement.

Given a dictionary:
\begin{enumerate}
\item If it has a field \str{elements}, it is a finite set described with elements directly.
\item If it has a field \str{union_components}, then the value must be a list of set representation dictionaries.
\item Otherwise, it is an error --- for now; we will introduce many more ways to describe sets.
\end{enumerate}

In particular, note that these are valid representations.
\begin{table*}[h]
\begin{tabular}{cccc}
An empty set  &
The union of 1 empty set &
The union of 2 empty sets  &
The union of zero sets \\
%
\datafile{set_empty}{min_lines=5} &
\datafile{set_union_empty1}{min_lines=5}&
\datafile{set_union_empty2}{min_lines=5}&
\datafile{set_union_zero}{min_lines=5}\\
\end{tabular}
\end{table*}

\subsection{Compute the product of two sets}

When we compute the union of two sets, we want to forget the structure. With products we want to remember to structure.
So we define a \classname{SetProduct} to be a special \Setoid that remembers its factors.

\classsource{SetProduct}{}


The semantics is the following:
\begin{itemize}
    \item The method \funcname{components} returns the ordered list of components.
    \item The method \funcname{pack} takes a number of arguments and creates an element of the product.
    \item The method \funcname{projections} returns the list of projection mappings.
            The $i$-th projection mapping takes an element of the product and returns the $i$-th component.

\end{itemize}


\begin{gradedexercise}[\exname{TestMakeSetProduct}]
  Given two sets, compute their product. Implement the interface in \cref{fig:MakeSetProduct}.

  Test your results using

\begin{console}
  make check-MakeSetProduct
\end{console}

\end{gradedexercise}


\begin{figure}
\classsource{MakeSetProduct}{}
\caption{The \classname{MakeSetProduct} interface}
\label{fig:MakeSetProduct}
\end{figure}



The interface above means that if you are passed 2 \FiniteSet{}s, you should return a \FiniteSet.
Otherwise, you should return a \Setoid.

\subsection{Loading product of two sets}


\margindatafilefig{set_product}{Product}{fig:set_product}

Extend now the code you wrote for loading sets to allow the format in \cref{fig:set_product}.

We add another clause to the parsing algorithm:
\begin{enumerate}
\item \dots
\item If there is a field \str{product_components}, it must be a list of sets, and the semantics is the product of those sets.
\end{enumerate}

Some special cases follow.

The product of 3 sets:

\margindatafile{set_product111}%

The product of 2 sets, of which one is empty:

\margindatafile{set_product10}%


\subsection{Mapping}

Our interface for a \classname{Mapping} is this:

\classsource{Mapping}{}

A \classname{Mapping} as a source and a target, which, in general, are setoids.

Then, a \classname{Mapping} is able to take an element from the source setoid and return an element in the second setoid.
Here we use Python's syntax sugar. If an object defines as \funcname{__call__} method, then these are equivalent:

\begin{minted}{python}
assert myobject(x) == myobject.__call__(x)
\end{minted}

Therefore, once you implement a \classname{Mapping} you can pass it around like if it was a Python function.

We also define a subclass \classname{FiniteMap} which is constrained to have both source and target be a \FiniteSet rather than a \Setoid.

\classsource{FiniteMap}{}


\margindatafilefig{map1}{A map}{fig:map1}

We define a YAML representation for finite maps as in~\cref{fig:map1}.

The fields \pystr{source} and \pystr{target} are two sets. These are expressions that you can pass to the set constructors you developed previously.

The field \pystr{values} is an array of pairs: each pair~$\tup{x, y}$ means that~$x$ maps to~$y$.

For the data to be well-formed it is necessary that for each element in the domain, there is exactly one row for that element.
If that is not the case, throw an exception.



\begin{gradedexercise}[Representation]
  Create a function to load the data.


%
  \classsource{FiniteMapRepresentation}{}

\end{gradedexercise}

\subsection{Operations}


\begin{gradedexercise}[Composition]
  Implement the composition of finite maps.


%
  \methodsource{FiniteMapOperations}{compose}{}

\end{gradedexercise}


\begin{gradedexercise}[Obtain relation]
  Given a FiniteMap, obtain the relation.


%
  \methodsource{FiniteMapOperations}{as_relation}{}

\end{gradedexercise}
\subsection{Disjoint union}
\begin{gradedexercise}
  Given two finite sets, compute the disjoint union.

\end{gradedexercise}

