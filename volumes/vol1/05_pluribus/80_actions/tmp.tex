% !TEX root = chapter-standalone.tex

\section{Moore machines}

We now look at processes, especially dynamical systems, and see them as categories that act on sequences.

We have already seen linear discrete time systems.

We can generalize by allowing non-linear functions, so to have
the definition as follows. We call these \textbf{Moore} machines.

\begin{equation}
    \begin{cases}
    \prdyn \colon \prin \cartprod \prst \sto \prst \\
    \prreadout \colon \prst \sto \prout
    \end{cases}
\end{equation}


We also need to have an $x_0 \in \prst$ to act as the initial state.

Suppose we have two morphisms
\begin{equation}
  \mora = \tupp{\prin_{\mora},\prst_{\mora},\prout_{\mora},\prdyn_{\mora},\prreadout_{\mora},\prstart_{\mora}}
\end{equation}
and
\begin{equation}
\morb = \tupp{\prin_{\morb},\prst_{\morb},\prout_{\morb},\prdyn_{\morb},\prreadout_{\morb},\prstart_{\morb}},
\end{equation}
such that $\prout_{\mora} \subseteq \prin_{\morb}$. The composition of these two systems should have a joint state that is the product of the states.

Here is one way to do it 

\begin{equation}
  \begin{aligned}
  \prin &= \prin_{\mora}   \\
  \prst &= \prst_{\mora} \cartprod \prst_{\morb} \\
  \prout &= \prout_{\morb} \\
  \end{aligned}
\end{equation}

\begin{equation}
  \definemap{
    \prdyn
    }{
      \prin_{\mora} \times (\prst_{\mora} \times \prst_{\morb}) 
    }{
      (\prst_{\mora} \times \prst_{\morb})
    }{
      \tup{u, \tup{x_{\mora}, x_{\morb}}}
    }{
    \tup{ \prdyn_{\mora} (u, x_{\mora}), \prdyn_{\morb}(\prreadout_{\mora}(x_{\mora}), x_{\morb})}
    }
\end{equation}

\begin{equation}
  \definemap{
    \prreadout
    }{
      (\prst_{\mora} \times \prst_{\morb}) 
    }{
      \prout_{\morb}
    }{
      \tup{x_{\mora}, x_{\morb}}
    }{
      \prreadout_{\morb}(x_{\morb})
    }
\end{equation}

However, if we define it using the Cartesian product $\prst_{\mora} \cartprod \prst_{\morb}$, we cannot compose the systems in an associative way. When we have three systems, composing in the two ways would bring
$(\prst_{\mora} \cartprod \prst_{\morb}) \cartprod \prst_{\morc}$ and 
$\prst_{\mora} \cartprod (\prst_{\morb} \cartprod \prst_{\morc}$, which are \emph{isomorphic} sets but not equal.
Elements of these sets are of the form $\tup{\tup{a,b},c}$ and 
$\tup{a, \tup{b,c}}$. You can clearly spot the isomorphism. 

We can avoid lengthy book-keeping by using a slightly different construction. 

Let's consider the monoid of sequences of sets.

\begin{equation}
\prst_{\mora} \setconcat \prst_{\morb} \setconcat \prst_{\morc} \in \seqsof\Set
\end{equation}

for which we have 

\begin{equation}
  (\prst_{\mora} \setconcat \prst_{\morb} )\setconcat \prst_{\morc} =
  \prst_{\mora} \setconcat \prst_{\morb} \setconcat \prst_{\morc} =
  \prst_{\mora} \setconcat (\prst_{\morb} \setconcat \prst_{\morc})
\end{equation}
  
and for elements 

\begin{equation}
  \tupca a   = a
\end{equation}
\begin{equation}
   \tupcat a b \elconcat c = \tupcatt a b c
\end{equation}

\begin{equation}
  \prftree{a \colon A}{b \colon B}{ \tupcat a b \colon (A \setconcat B) }
\end{equation}
  
\begin{equation}
  \prftree{a \colon A}{ \tupcat a b \colon (A \setconcat B) }{  b \colon  B }
\end{equation}
  

\begin{equation}
  \prftree{ f \colon A \to C}{ g \colon B \to C}{ \tupcat f g \colon (A\setconcat B)\to C }
\end{equation}


Here is a different way to do it:

\begin{equation}
  \begin{aligned}
  \prin &= \prst_{\mora}   \\
  \prst &= \prst_{\mora} \setconcat \prst_{\morb} \\
  \prout &= \prout_{\morb} \\
  \end{aligned}
\end{equation}

\begin{equation}
  \definemap{
    \prdyn
    }{
      \prin_{\mora} \times (\prst_{\mora} \setconcat \prst_{\morb}) 
    }{
      (\prst_{\mora} \setconcat \prst_{\morb})
    }{
      \tup{u, \tupcat{x_{\mora}}{x_{\morb}}}
    }{
      \tupcat{ \prdyn_{\mora} (u, x_{\mora})}{\prdyn_{\morb}(\prreadout_{\mora}(x_{\mora}), x_{\morb})}
    }
\end{equation}

\begin{equation}
  \definemap{
    \prreadout
    }{
      (\prst_{\mora} \setconcat \prst_{\morb}) 
    }{
      \prout_{\morb}
    }{
      \tupcat{x_{\mora}}{x_{\morb}}
    }{
      \prreadout_{\morb}(x_{\morb})
    }
\end{equation}


With this definition we can define the semi-category $\Moore$ of Moore machines. 

\begin{definition}[\Moore]
  \label{def:Moore}
  The \emph{semi-category of Moore machines} \Moore is given by:
  \begin{enumerate}
    \item \emph{Objects:} sets.
    \item \emph{Morphisms:} A morphism is a tuple
    \begin{equation}
    \mora = \tupp{\prin_{\mora},\prst_{\mora},\prout_{\mora},\prdyn_{\mora},\prreadout_{\mora},\prstart_{\mora}}
    \end{equation}
    where
    \begin{itemize}
      \item $\prin$, $\prst$, $\prout$ are sets;
      \item $  \prdyn \colon \prin \to \Endof \prst$
      \item $ \prreadout \colon \prst \sto \prout$
  \end{itemize}
    \item \emph{Composition of morphisms:} Given by 
    \begin{equation}
      \begin{aligned}
      \prin_{\mora\mthen\morb} &= \prst_{\mora}   \\
      \prst_{\mora\mthen\morb} &= \prst_{\mora} \setconcat \prst_{\morb} \\
      \prout_{\mora\mthen\morb} &= \prout_{\morb} \\
      \end{aligned}
    \end{equation}
    % 
    \begin{equation}
      \definemap{
        \prdyn_{\mora\mthen\morb}
        }{
          \prin_{\mora} \times (\prst_{\mora} \setconcat \prst_{\morb}) 
        }{
          (\prst_{\mora} \setconcat \prst_{\morb})
        }{
          \tup{u, \tupcat{x_{\mora}}{x_{\morb}}}
        }{
          \tupcat{ \prdyn_{\mora} (u, x_{\mora})}{\prdyn_{\morb}(\prreadout_{\mora}(x_{\mora}), x_{\morb})}
        }
    \end{equation}
    % 
    \begin{equation}
      \definemap{
        \prreadout_{\mora\mthen\morb}
        }{
          (\prst_{\mora} \setconcat \prst_{\morb}) 
        }{
          \prout_{\morb}
        }{
          \tupcat{x_{\mora}}{x_{\morb}}
        }{
          \prreadout_{\morb}(x_{\morb})
        }
    \end{equation}
    
  \end{enumerate}
\end{definition}

\section{Action on sequences}

Let's now look at how machines like the above acts on sequences. 

For now we only have defined monoid actions. So let's take the set of machines systems with $\prin = \prout = \prgen$, which is the homset $\HomSet\Moore\prgen\prgen$.

Given a finite input sequence $u: \natnumbers \to \prgen$ of length $n$, the output is an instantaneous transformation of the state:

\begin{equation}
  \begin{aligned}
  y_0 &= \prreadout(x_0) \\ 
  y_1 &= \prreadout(x_1) \\ 
  y_2 &= \prreadout(x_2) \\ 
  ... &= ...  \\
  y_{k} &= \prreadout(x_{k-1}) 
\end{aligned} 
\end{equation}

The state is computed recursively as follows 
\begin{equation}
  \begin{aligned}
  x_0 &= \prdyn(u_0, \prstart) \\ 
  x_1 &= \prdyn(u_1, x_0) \\ 
  x_2 &= \prdyn(u_2, x_1) \\ 
  ... &= ... \\
  x_{k} &= \prdyn(u_{k}, x_{k-1}) 
  \end{aligned}
\end{equation}

Therefore, given a machine $\mora \colon \prgen_{\Moore} \to \prgen$ we have defined a map from $\natnumbers \to \prgen$ to itself. Let's call it $\act$.
% 
\begin{equation}
\act_{\mora}:  (\natnumbers \to \prgen)  \sto  (\natnumbers \to \prgen)
\end{equation}
% 
or, more formally,
% 
  \begin{equation}
    \act: \HomSet\Moore\prgen\prgen \sto \Autof {\natnumbers \to \prgen}
\end{equation}
%
Note that both $\HomSet\Moore\prgen\prgen$ and $\Autof {\natnumbers \to \prgen}$ are semigroups. Could it be that $\act$ is a semigroup morphism? (and consequently, is $\act$ a left semigroup action)?

Let's check the condition for it being a morphism (\cref{XXX}):
\begin{equation}
  \act ( \mora \mthen_{\Moore} \morb) \stackrel{?}{=}  \act ( \mora) \mthen_{\Autof  {\natnumbers \to \prgen}} \act(\morb)
\end{equation}


\section{Other machines}


\begin{table*}[b]
  \caption{Some types of signals and processes}
  \label{tab:processes-types}
  \begin{tabular}{rccc}
  & \multicolumn{2}{c}{\textbf{Signals}} & \textbf{Processes} \\
  &\rule{0pt}{10pt} one-sided & two-sided &   \\
  Moore machines ($\Moore$) &
  $\natnumbers \sto \prgen$
  &
  $\wnumbers \sto \prgen$
  &
  \begin{minipage}{4cm}\raggedright
  \begin{equation*}\label{eq:a}
      \begin{cases}
      \prdyn \colon \prin \sto \Endof \prst \\
      \prreadout \colon \prst \sto \prout
      \end{cases}
  \end{equation*}
  \end{minipage}
  \\
  
  More machines ($\More$)& $\seqsof \prgen$ &  $\streamsof \prgen$ &
  \begin{minipage}{4cm}\raggedright
  \begin{equation*}
  \begin{cases}
  \prdyn \colon \prin \sto \Endof \prst \\
  \prreadout \colon \prst \sto \seqsof \prout
  \end{cases}
  \end{equation*}
  
  \end{minipage}
  \\
  event-based (\tmpEB) & $\seqsof{(\natnumbers \cartprod \prgen)}$&
   $\streamsof{(\natnumbers \cartprod \prgen)}$&
  \begin{minipage}{4cm}\raggedright
  \begin{equation*}
  \begin{cases}
  \prdyn \colon (\natnumbers \cartprod \prin) \sto \Endof \prst \\
  \prreadout \colon \prst \sto \seqsof{ (\natnumbers \cartprod \prout)}
  \end{cases}
  \end{equation*}
  \end{minipage}\\
  continuous  (\tmpDS) & $\nonNegReals \sto \prgen$ & $\reals \sto \prgen$ &
  \begin{minipage}{4cm}\raggedright
  \begin{equation*}
  \begin{cases}
    \prdyn\colon \prin \to \vectorfield(\prst) \\
  \prreadout\colon \prst \sto   \prout
  \end{cases}
  \end{equation*}
  \end{minipage}
  \\
  \end{tabular}
  \end{table*}
  

  
But there are many different types of machines. 

A Moore machine outputs 1 element at each time step; what if the machine was able to output more than one or zero output?

The signature of this would be this:
\begin{equation*}
  \begin{cases}
  \prdyn \colon \prin \sto \Endof \prst \\
  \prreadout \colon \prst \sto \seqsof \prout
  \end{cases}
\end{equation*}
where the output is not just $\prout$ but $\seqsof \prout$: the machine can produce zero or more outputs. We call these \emph{More} machines.
  
\begin{exercise}
Define the category $\More$ of More machines.
\end{exercise}

We have these act on $\seqsof \prgen$; the timing information is not there.

Another type of machine are the event-based machines, with signature 
\begin{equation*}
  \begin{cases}
    \prdyn \colon (\natnumbers \cartprod \prin) \sto \Endof \prst \\
    \prreadout \colon \prst \sto \seqsof{ (\natnumbers \cartprod \prout)}
    \end{cases}    
\end{equation*}

The natural numbers are the deltas between events. (This could be generalized to $\nonNegReals$.)

Continuous-time dynamical systems would be described as 
% 
\begin{equation}
\begin{cases}
  \prdyn\colon \prin \to \vectorfield(\prst) \\
\prreadout\colon \prst \sto   \prout
\end{cases}
\end{equation}
% 
One should put more conditions on the objects--typically, that they are manifolds, and more constraints about the dynamics for the trajectories to exist.



\section{Action of a category}

Now it is time to generalize from actions of a semigroup to action of a semicategory. 

Let $\CatC$ a general process category, as in \cref{tab:processes-types}.

We want a process in $\HomSet\CatC\Obja\Objb$ to induce a map between signals. 

Note that each process type has a different signal types. 

For example, a Moore machine in $\HomSet\Moore\Obja\Objb$ will map the set $\natnumbers \to \Obja$ to the set $\natnumbers \to \Objb$. 
A More machine in  $\HomSet\More\Obja\Objb$  will map the set  $\seqsof \Obja$ to the set $\seqsof \Objb$. 
An event based machine will map the set  $\seqsof{\natnumbers \cartprod \Obja}$ to the set $\seqsof{\natnumbers \cartprod \Objb}$.

To look at this generically, we need to consider a map $\varphi$ that maps the base set $\Obja$ to the actual set $\varphi(\Obja)$. For example:
\begin{equation}
  \definemap{\varphi_{\Moore}}{\Set}{\Set}{\Obja}{(\natnumbers \to \Obja)}
\end{equation}
\begin{equation}
\definemap{\varphi_{\More}}{\Set}{\Set}{\Obja}{\seqsof \Obja}
\end{equation}
\begin{equation}
\definemap{\varphi_{\tmpEB}}{\Set}{\Set}{\Obja}{\seqsof{\natnumbers \cartprod \Obja}}
\end{equation}
\begin{equation}
\definemap{\varphi_{\tmpDS}}{\Set}{\Set}{\Obja}{(\nonNegReals \to \Obja)}
\end{equation}
Note for the last one we need to define manifolds.


Then we need another map $\gamma$ that given a process in $\HomSet\CatC\Obja\Objb$ 
produces a map from $\varphi(\Obja)$ to $\varphi(\Objb)$.
% 
\begin{equation}
  \gamma: \HomSet\CatC\Obja\Objb \to  (\varphi(\Obja) \sto \varphi(\Objb))
\end{equation}
% 
Interpreting the arrows as morphisms in sets, we can say:
\begin{equation}
  \gamma: \HomSet\CatC\Obja\Objb \to  \HomSet\Set{\varphi(\Obja)}{\varphi(\Objb) }
\end{equation}

\begin{ctdefinition}[Semi-category action]
  A semi-category action of a semi-category $\CatC$ is defined by 
  \begin{itemize}
    \item a map $\varphi$ that associates from each object $\Obja \in \ObC$, a set $\varphi(\Obja)$;
    \item a map $\gamma$ that associates to each morphism a function:
    \begin{equation}
      \gamma: \HomSet\CatC\Obja\Objb \to  \HomSet\Set{\varphi(\Obja)}{\varphi(\Objb) }
    \end{equation}
  \end{itemize}
  Moreover, this condition need hold:
  \begin{equation}
    \gamma(\mora\then\morb) = \gamma(\mora) \mthen \gamma(\morb)
  \end{equation}
\end{ctdefinition}

